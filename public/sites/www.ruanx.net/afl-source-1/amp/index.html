<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <title>AFL源码阅读（一）：启程</title>

    <meta name="description" content="开始阅读 AFL 的源码。本文分析了 AFL 项目的文件结构，确定了阅读代码的顺序，并详细解释了 afl-gcc 和 afl-as 代码。" />
    <link rel="icon" href="../../content/images/size/w256h256/2020/02/small-3.png" type="image/png" />
    <link rel="canonical" href="../index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Pion1eer" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="AFL源码阅读（一）：启程" />
    <meta property="og:description" content="开始阅读 AFL 的源码。本文分析了 AFL 项目的文件结构，确定了阅读代码的顺序，并详细解释了 afl-gcc 和 afl-as 代码。" />
    <meta property="og:url" content="https://www.ruanx.net/afl-source-1/" />
    <meta property="og:image" content="https://www.ruanx.net/content/images/2023/05/output-2.jpg" />
    <meta property="article:published_time" content="2023-05-07T12:45:20.000Z" />
    <meta property="article:modified_time" content="2023-05-08T07:00:12.000Z" />
    <meta property="article:tag" content="Fuzzing" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="AFL源码阅读（一）：启程" />
    <meta name="twitter:description" content="开始阅读 AFL 的源码。本文分析了 AFL 项目的文件结构，确定了阅读代码的顺序，并详细解释了 afl-gcc 和 afl-as 代码。" />
    <meta name="twitter:url" content="https://www.ruanx.net/afl-source-1/" />
    <meta name="twitter:image" content="https://www.ruanx.net/content/images/2023/05/output-2.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ruan Xingzhi" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Fuzzing" />
    <meta property="og:image:width" content="640" />
    <meta property="og:image:height" content="480" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Pion1eer",
        "url": "https://www.ruanx.net/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.ruanx.net/content/images/size/w256h256/2020/02/small-3.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ruan Xingzhi",
        "image": {
            "@type": "ImageObject",
            "url": "https://www.ruanx.net/content/images/2020/05/blue.jpeg",
            "width": 1024,
            "height": 1024
        },
        "url": "https://www.ruanx.net/author/blue/",
        "sameAs": []
    },
    "headline": "AFL源码阅读（一）：启程",
    "url": "https://www.ruanx.net/afl-source-1/",
    "datePublished": "2023-05-07T12:45:20.000Z",
    "dateModified": "2023-05-08T07:00:12.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://www.ruanx.net/content/images/2023/05/output-2.jpg",
        "width": 640,
        "height": 480
    },
    "keywords": "Fuzzing",
    "description": "开始阅读 AFL 的源码。本文分析了 AFL 项目的文件结构，确定了阅读代码的顺序，并详细解释了 afl-gcc 和 afl-as 代码。",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.ruanx.net/"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.8" />
    <link rel="alternate" type="application/rss+xml" title="Pion1eer" href="../../rss/index.rss" />

    <style amp-custom>*,
    *::before,
    *::after {
        box-sizing: border-box;
    }

    html {
        overflow-x: hidden;
        overflow-y: scroll;
        font-size: 62.5%;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    body {
        min-height: 100vh;
        margin: 0;
        padding: 0;
        color: #3a4145;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.7rem;
        line-height: 1.55em;
        font-weight: 400;
        font-style: normal;
        background: #fff;
        scroll-behavior: smooth;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    p,
    ul,
    ol,
    li,
    dl,
    dd,
    hr,
    pre,
    form,
    table,
    video,
    figure,
    figcaption,
    blockquote {
        margin: 0;
        padding: 0;
    }

    ul[class],
    ol[class] {
        padding: 0;
        list-style: none;
    }

    img {
        display: block;
        max-width: 100%;
    }

    input,
    button,
    select,
    textarea {
        font: inherit;
        -webkit-appearance: none;
    }

    fieldset {
        margin: 0;
        padding: 0;
        border: 0;
    }

    label {
        display: block;
        font-size: 0.9em;
        font-weight: 700;
    }

    hr {
        position: relative;
        display: block;
        width: 100%;
        height: 1px;
        border: 0;
        border-top: 1px solid currentcolor;
        opacity: 0.1;
    }

    ::selection {
        text-shadow: none;
        background: #cbeafb;
    }

    mark {
        background-color: #fdffb6;
    }

    small {
        font-size: 80%;
    }

    sub,
    sup {
        position: relative;
        font-size: 75%;
        line-height: 0;
        vertical-align: baseline;
    }
    sup {
        top: -0.5em;
    }
    sub {
        bottom: -0.25em;
    }

    ul li + li {
        margin-top: 0.6em;
    }

    a {
        color: var(--ghost-accent-color, #1292EE);
        text-decoration-skip-ink: auto;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 0;
        font-weight: 700;
        color: #121212;
        line-height: 1.4em;
    }

    h1 {
        font-size: 3.4rem;
        line-height: 1.1em;
    }

    h2 {
        font-size: 2.4rem;
        line-height: 1.2em;
    }

    h3 {
        font-size: 1.8rem;
    }

    h4 {
        font-size: 1.7rem;
    }

    h5 {
        font-size: 1.6rem;
    }

    h6 {
        font-size: 1.6rem;
    }

    amp-img {
        height: 100%;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }

    amp-img img {
        object-fit: cover;
    }

    .page-header {
        padding: 50px 5vmin 30px;
        text-align: center;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .page-header a {
        color: #121212;
        font-weight: 700;
        text-decoration: none;
        font-size: 1.6rem;
        letter-spacing: -0.1px;
    }

    .post {
        max-width: 680px;
        margin: 0 auto;
    }

    .post-header {
        margin: 0 5vmin 5vmin;
        text-align: center;
    }

    .post-meta {
        margin: 1rem 0 0 0;
        text-transform: uppercase;
        color: #738a94;
        font-weight: 500;
        font-size: 1.3rem;
    }

    .post-image {
        margin: 0 0 5vmin;
    }

    .post-image img {
        display: block;
        width: 100%;
        height: auto;
    }

    .post-content {
        padding: 0 5vmin;
    }

    .post-content > * + * {
        margin-top: 1.5em;
    }

    .post-content [id]:not(:first-child) {
        margin: 2em 0 0;
    }

    .post-content > [id] + * {
        margin-top: 1rem;
    }

    .post-content [id] + .kg-card,
    .post-content blockquote + .kg-card {
        margin-top: 40px;
    }

    .post-content > ul,
    .post-content > ol,
    .post-content > dl {
        padding-left: 1.9em;
    }

    .post-content hr {
        margin-top: 40px;
    }

    .post .post-content hr + * {
        margin-top: 40px;
    }

    .post-content amp-img {
        background-color: #f8f8f8;
    }

    .post-content blockquote {
        position: relative;
        font-style: italic;
    }

    .post-content blockquote::before {
        content: "";
        position: absolute;
        left: -1.5em;
        top: 0;
        bottom: 0;
        width: 0.3rem;
        background: var(--ghost-accent-color, #1292EE);
    }

    .post-content blockquote.kg-blockquote-alt {
        font-size: 1.2em;
        font-style: italic;
        line-height: 1.6em;
        text-align: center;
        color: #738a94;
        padding: 0.75em 3em 1.25em;
    }

    .post-content blockquote.kg-blockquote-alt::before {
        display: none;
    }

    .post-content :not(.kg-card):not([id]) + .kg-card {
        margin-top: 40px;
    }

    .post-content .kg-card + :not(.kg-card) {
        margin-top: 40px;
    }

    .kg-card figcaption {
        padding: 1.5rem 1.5rem 0;
        text-align: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.4em;
        opacity: 0.6;
    }

    .kg-card figcaption strong {
        color: rgba(0,0,0,0.8);
    }

    .post-content :not(pre) code {
        vertical-align: middle;
        padding: 0.15em 0.4em 0.15em;
        border: #e1eaef 1px solid;
        font-weight: 400;
        font-size: 0.9em;
        line-height: 1em;
        color: #15171a;
        background: #f0f6f9;
        border-radius: 0.25em;
    }

    .post-content > pre {
        overflow: scroll;
        padding: 16px 20px;
        color: #fff;
        background: #1F2428;
        border-radius: 5px;
        box-shadow: 0 2px 6px -2px rgba(0,0,0,.1), 0 0 1px rgba(0,0,0,.4);
    }

    .kg-embed-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    }

    .kg-image-card img {
        margin: auto;
    }

    .kg-gallery-card + .kg-gallery-card {
        margin-top: 0.75em;
    }

    .kg-gallery-container {
        position: relative;
    }

    .kg-gallery-row {
        display: flex;
        flex-direction: row;
        justify-content: center;
    }

    .kg-gallery-image {
        width: 100%;
        height: 100%;
    }

    .kg-gallery-row:not(:first-of-type) {
        margin: 0.75em 0 0 0;
    }

    .kg-gallery-image:not(:first-of-type) {
        margin: 0 0 0 0.75em;
    }

    .kg-bookmark-card,
    .kg-bookmark-publisher {
        position: relative;
    }

    .kg-bookmark-container,
    .kg-bookmark-container:hover {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row-reverse;
        color: currentColor;
        background: rgba(255,255,255,0.6);
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        text-decoration: none;
        border-radius: 3px;
        box-shadow: 0 2px 6px -2px rgba(0, 0, 0, 0.1), 0 0 1px rgba(0, 0, 0, 0.4);
        overflow: hidden;
    }

    .kg-bookmark-content {
        flex-basis: 0;
        flex-grow: 999;
        padding: 20px;
        order: 1;
    }

    .kg-bookmark-title {
        font-weight: 600;
        font-size: 1.5rem;
        line-height: 1.3em;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        max-height: 45px;
        margin: 0.5em 0 0 0;
        font-size: 1.4rem;
        line-height: 1.55em;
        overflow: hidden;
        opacity: 0.8;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    .kg-bookmark-metadata {
        margin-top: 20px;
    }

    .kg-bookmark-metadata {
        display: flex;
        align-items: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.3em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        overflow: hidden;
    }

    .kg-bookmark-metadata amp-img {
        width: 18px;
        height: 18px;
        max-width: 18px;
        max-height: 18px;
        margin-right: 10px;
    }

    .kg-bookmark-thumbnail {
        display: flex;
        flex-basis: 20rem;
        flex-grow: 1;
        justify-content: flex-end;
    }

    .kg-bookmark-thumbnail amp-img {
        max-height: 200px;
    }

    .kg-bookmark-author {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

    .kg-bookmark-publisher::before {
        content: "•";
        margin: 0 .5em;
    }

    .kg-toggle-card-icon {
        display: none;
    }

    .kg-toggle-content {
        margin-top: 0.8rem;
    }

    .kg-product-card-container {
        background: transparent;
        padding: 20px;
        width: 100%;
        border-radius: 5px;
        box-shadow: inset 0 0 0 1px rgb(124 139 154 / 25%);
    }

    .kg-product-card-description p {
        margin-top: 1.5em;
    }

    .kg-product-card-description ul {
        margin-left: 24px;
    }

    .kg-product-card-title {
        font-size: 1.9rem;
        font-weight: 700;
    }

    .kg-product-card-rating-star {
        height: 28px;
        width: 20px;
        margin-right: 2px;
    }

    .kg-product-card-rating-star svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
    opacity: 0.15;
    }

    .kg-product-card-rating-active.kg-product-card-rating-star svg {
    opacity: 1;
    }

    .kg-nft-card-container {
        position: relative;
        display: flex;
        flex: auto;
        flex-direction: column;
        text-decoration: none;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.4rem;
        font-weight: 400;
        box-shadow: 0 2px 6px -2px rgb(0 0 0 / 10%), 0 0 1px rgb(0 0 0 / 40%);
        width: 100%;
        max-width: 512px;
        color: #15212A;
        background: #fff;
        border-radius: 5px;
        transition: none;
        margin: 0 auto;
    }

    .kg-nft-metadata {
        padding: 2.0rem;
    }

    .kg-nft-image-container {
        position: relative;
    }

    .kg-nft-image {
        display: flex;
        border-radius: 5px 5px 0 0;
    }

    .kg-nft-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
    }

    .kg-nft-header h4.kg-nft-title {
        font-size: 1.9rem;
        font-weight: 700;
        margin: 0;
        color: #15212A;
    }

    .kg-nft-header amp-img {
        max-width: 114px;
        max-height: 26px;
    }

    .kg-nft-opensea-logo {
        margin-top: 2px;
        width: 100px;
    }

    .kg-nft-creator {
        font-family: inherit;
        color: #95A1AD;
    }

    .kg-nft-creator span {
        font-weight: 500;
        color: #15212A;
    }

    .kg-nft-card p.kg-nft-description {
        font-size: 1.4rem;
        line-height: 1.4em;
        margin: 2.0rem 0 0;
        color: #222;
    }

    .kg-button-card {
        display: flex;
        position: static;
        align-items: center;
        width: 100%;
        justify-content: center;
    }

    .kg-btn {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 2.0rem;
        height: 4.0rem;
        line-height: 4.0rem;
        font-size: 1.65rem;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
    }

    .kg-btn:hover {
        opacity: 0.85;
    }

    .kg-btn-accent {
        background-color: var(--ghost-accent-color, #1292EE);
        color: #fff;
    }

    .kg-callout-card {
        display: flex;
        padding: 20px 28px;
        border-radius: 3px;
    }

    .kg-callout-card-grey {
        background: rgba(124, 139, 154, 0.13);
    }

    .kg-callout-card-white {
        background: transparent;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-callout-card-blue {
        background: rgba(33, 172, 232, 0.12);
    }

    .kg-callout-card-green {
        background: rgba(52, 183, 67, 0.12);
    }

    .kg-callout-card-yellow {
        background: rgba(240, 165, 15, 0.13);
    }

    .kg-callout-card-red {
        background: rgba(209, 46, 46, 0.11);
    }

    .kg-callout-card-pink {
        background: rgba(225, 71, 174, 0.11);
    }

    .kg-callout-card-purple {
        background: rgba(135, 85, 236, 0.12);
    }

    .kg-callout-card-accent {
        background: var(--ghost-accent-color);
        color: #fff;
    }

    .kg-callout-card-accent a {
        color: #fff;
    }

    .kg-callout-emoji {
        padding-right: 16px;
        line-height: 1.3;
        font-size: 1.25em;
    }

    .kg-header-card {
        padding: 6em 3em;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }

    .kg-header-card.kg-size-small {
        padding-top: 4em;
        padding-bottom: 4em;
    }

    .kg-header-card.kg-size-large {
        padding-top: 12em;
        padding-bottom: 12em;
    }

    .kg-header-card.kg-width-full {
        padding-left: 4em;
        padding-right: 4em;
    }

    .kg-header-card.kg-align-left {
        text-align: left;
        align-items: flex-start;
    }

    .kg-header-card.kg-style-dark {
        background: #15171a;
        color: #ffffff;
    }

    .kg-header-card.kg-style-light {
        color: #15171a;
        border: 1px solid rgba(124, 139, 154, 0.25);
        border-width: 1px 0;
    }

    .kg-header-card.kg-style-accent {
        background-color: var(--ghost-accent-color);
    }

    .kg-header-card.kg-style-image {
        background-color: #e7e7eb;
        background-size: cover;
        background-position: center center;
    }

    .kg-header-card h2 {
        font-size: 4em;
        font-weight: 700;
        line-height: 1.1em;
        margin: 0;
    }

    .kg-header-card h2 strong {
        font-weight: 800;
    }

    .kg-header-card.kg-size-small h2 {
        font-size: 3em;
    }

    .kg-header-card.kg-size-large h2 {
        font-size: 5em;
    }

    .kg-header-card h3 {
        font-size: 1.25em;
        font-weight: 500;
        line-height: 1.3em;
        margin: 0;
    }

    .kg-header-card h3 strong {
        font-weight: 600;
    }

    .kg-header-card.kg-size-small h3 {
        font-size: 1em;
    }

    .kg-header-card.kg-size-large h3 {
        font-size: 1.5em;
    }

    .kg-header-card:not(.kg-style-light) h2,
    .kg-header-card:not(.kg-style-light) h3 {
        color: #ffffff;
    }

    .kg-header-card a.kg-header-card-button {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 1.2em;
        height: 2.4em;
        line-height: 1em;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
        background-color: var(--ghost-accent-color);
        color: #ffffff;
        margin: 1.75em 0 0;
    }

    .kg-header-card a.kg-header-card-button:hover {
        opacity: 0.85;
    }

    .kg-header-card.kg-size-large a.kg-header-card-button {
        margin-top: 2em;
    }

    .kg-header-card.kg-size-small a.kg-header-card-button {
        margin-top: 1.5em;
    }

    .kg-header-card.kg-style-image a.kg-header-card-button,
    .kg-header-card.kg-style-dark a.kg-header-card-button {
        background: #ffffff;
        color: #15171a;
    }

    .kg-header-card.kg-style-accent a.kg-header-card-button {
        background: #ffffff;
        color: var(--ghost-accent-color);
    }

    .kg-audio-card {
        display: flex;
        width: 100%;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-audio-thumbnail {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 80px;
        min-width: 80px;
        height: 80px;
        background: transparent;
        object-fit: cover;
        aspect-ratio: 1/1;
        border-radius: 3px 0 0 3px;
    }

    .kg-audio-thumbnail.placeholder {
        background: var(--ghost-accent-color);
    }

    .kg-audio-thumbnail.placeholder svg {
        width: 24px;
        height: 24px;
        fill: white;
    }

    .kg-audio-player-container {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 100%;
        --seek-before-width: 0%;
        --volume-before-width: 100%;
        --buffered-width: 0%;
    }

    .kg-audio-title {
        width: 100%;
        padding: 8px 12px 0;
        border: none;
        font-family: inherit;
        font-size: 1.1em;
        font-weight: 700;
        background: transparent;
    }

    .kg-audio-player {
        display: none;
    }

    .kg-width-full.kg-card-hascaption {
        display: grid;
        grid-template-columns: inherit;
    }

    .post-content table {
        border-collapse: collapse;
        width: 100%;
    }

    .post-content th {
        padding: 0.5em 0.8em;
        text-align: left;
        font-size: .75em;
        text-transform: uppercase;
    }

    .post-content td {
        padding: 0.4em 0.7em;
    }

    .post-content tbody tr:nth-child(2n + 1) {
        background-color: rgba(0,0,0,0.1);
        padding: 1px;
    }

    .post-content tbody tr:nth-child(2n + 2) td:last-child {
        box-shadow:
            inset 1px 0 rgba(0,0,0,0.1),
            inset -1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:nth-child(2n + 2) td {
        box-shadow: inset 1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:last-child {
        border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .page-footer {
        padding: 60px 5vmin;
        margin: 60px auto 0;
        text-align: center;
        background-color: #f8f8f8;
    }

    .page-footer h3 {
        margin: 0.5rem 0 0 0;
    }

    .page-footer p {
        max-width: 500px;
        margin: 1rem auto 1.5rem;
        font-size: 1.7rem;
        line-height: 1.5em;
        color: rgba(0,0,0,0.6)
    }

    .powered {
        display: inline-flex;
        align-items: center;
        margin: 30px 0 0;
        padding: 6px 9px 6px 6px;
        border: rgba(0,0,0,0.1) 1px solid;
        font-size: 12px;
        line-height: 12px;
        letter-spacing: -0.2px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-weight: 500;
        color: #222;
        text-decoration: none;
        background: #fff;
        border-radius: 6px;
    }

    .powered svg {
        height: 16px;
        width: 16px;
        margin: 0 6px 0 0;
    }

    @media (max-width: 600px) {
        body {
            font-size: 1.6rem;
        }
        h1 {
            font-size: 3rem;
        }

        h2 {
            font-size: 2.2rem;
        }
    }

    @media (max-width: 400px) {
        h1 {
            font-size: 2.6rem;
            line-height: 1.15em;
        }
        h2 {
            font-size: 2rem;
            line-height: 1.2em;
        }
        h3 {
            font-size: 1.7rem;
        }
    }

    :root {--ghost-accent-color: #15171A;}
    </style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="page-header">
        <a href="../../index.html">
                <amp-img class="site-icon" src="https://www.ruanx.net/content/images/2020/02/small-3.png" width="50" height="50" layout="fixed" alt="Pion1eer"></amp-img>
        </a>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">AFL源码阅读（一）：启程</h1>
                <section class="post-meta">
                    Ruan Xingzhi -
                    <time class="post-date" datetime="2023-05-07">07 May 2023</time>
                </section>
            </header>
            <figure class="post-image">
                <amp-img src="https://www.ruanx.net/content/images/2023/05/output-2.jpg" width="600" height="340" layout="responsive" 
                alt="AFL源码阅读（一）：启程"
                ></amp-img>
            </figure>
            <section class="post-content">

                <p>　　笔者明年年底就该研究生毕业了，然而毕业论文的题目还没有着落。一番考察之后，认为 fuzzing 方向还算是有事可做；于是打算在 fuzzing 领域研究得更深一些。</p><p>　　众所周知，AFL 系的 fuzzer 有几个缺陷：</p><ol><li>发现的「有价值的漏洞」太少。fuzzer 指出的大量 bug 都是「无关紧要」的，例如缺乏验证而执行一个 division by zero，令程序收到 FPE 崩溃。这类漏洞要么本身就缺乏价值，要么就很难以利用，以至于需要通过讲故事的方式构造出一个利用场景。而另一方面，AFL 忽略了逻辑漏洞，因为只有 crash 才会被报告。</li><li>fuzzer 的搜索能力太差。例如，AFL 难以构造出能通过 magic number、checksum 检查的输入，实践上往往需要研究员手动注释掉这些检查。</li></ol><p>　　关于第一个困难，笔者认为暂且没有很好的解决思路。归根结底，一个漏洞到底有没有价值，需要很多外部知识——例如，假如某个输入能让程序额外运行一秒钟，这对于 nginx 来说是巨大问题；但对于 checkpng 之类的小程序，便是无关紧要的。一个缓冲区 over-read 漏洞，对于 openssl 是致命的，但对于 gimp 这类程序而言，只是多了个让程序崩溃的 bug，大家并不特别关心其安全方面的危险。由于一个漏洞的价值难以衡量，笔者决定不钻研这个问题，仍以 crash 数量为衡量 fuzzer 好坏的第一标准。</p><p>　　而第二个困难，便是很有可能做出改进的地方。首先，fuzzer 不可能搜出所有 bug——使用反证法，假设存在这样的 fuzzer，那么我们就能获得一个求解任意约束问题的 oracle。例如，我们提供下面的程序：</p><pre><code class="language-python">cin &gt;&gt; p;
if(N % p == 0)
    abort();</code></pre><p>　　如果真的存在一个 fuzzer 能找到程序中的所有漏洞，那它就一定能报告一个 $p$ 使得 $p \mid n$，从而令程序 crash。这像是天方夜谭，现阶段我们不存在这样强大的求解器。</p><p>　　既然不存在完美的求解器，那么我们可能会考虑让 fuzzer 拥有更加细致的求解能力。但这样的能力往往与 fuzz 效率是负相关的：以符号执行方法寻找 bug，实际表现并不比 AFL 更好。<strong>AFL 的设计哲学中有这样一个观点：如果一条路径需要很艰难地触发，那我们可以考虑加快 fuzz 速度，以尝试寻找更简单的触发方法。</strong>沿着这条设计思路，AFL 严格地控制每次程序执行的时间。</p><p>　　明显，fuzzer 需要在执行速度与求解能力上作出权衡。有一些方法试图在不太影响性能的情况下，加强 AFL 的求解能力。例如，<a href="https://nesa.zju.edu.cn/download/lcy_pdf_ems_ndss22.pdf">EMS</a> 方法认为，从 fuzz 一个程序的过程中学到的经验，能帮助我们 fuzz 其他程序。显而易见，我们对 libpng 进行 fuzz，可以学到很多 PNG 格式相关的 magic number；拿这些知识去 fuzz imagemagick，很可能是有效果的。EMS 并未引入约束求解器，而是从其他程序样本中学习「$A\to B$」这样的变异模式，在宏观上看，确实提升了 AFL 的搜索能力。</p><p>　　笔者也打算从「执行速度与求解能力的权衡」这方面着手，去优化 AFL。也就是说，笔者希望寻找一些不太影响 fuzz 执行速度的方法，去优化 fuzzer 的搜索能力。这样，势必要对 AFL 进行一些修改，因此笔者决定阅读一遍 AFL 源码。</p><p>　　坦率地讲，这是笔者第一次全面阅读中等规模项目的源码。因此操作流程上一定有不规范的地方，望读者在评论区指正。</p><h3 id="0x00-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90">0x00 项目文件分析</h3><p>　　笔者选择阅读 AFL 的源码而非 AFL++，因为 AFL++ 引入了不少新功能和优化技术，代码应该比 AFL 更加繁杂。另外，笔者打算在 AFL 的基础上进行修改，因此选择原始 AFL 是最好的。</p><p>　　AFL 项目的仓库是 <a href="https://github.com/google/AFL">https://github.com/google/AFL</a>，现已停止开发。据阅读 Linux 源码的人说，读源码可以先从最初几个 commit 着手，因为当时没有太多冗杂功能，core insight 比较突出。不过 Github 上并没有 2013 年版本的 AFL，因此作罢，直接阅读最新版代码。</p><p>　　把项目导入 Understand 源码阅读器，看一下 Metrics Treemap：</p><figure class="kg-card kg-image-card kg-width-wide"><amp-img src="https://www.ruanx.net/content/images/2023/05/image-1.png" class="kg-image" alt width="3267" height="1431" srcset="https://www.ruanx.net/content/images/size/w600/2023/05/image-1.png 600w, https://www.ruanx.net/content/images/size/w1000/2023/05/image-1.png 1000w, https://www.ruanx.net/content/images/size/w1600/2023/05/image-1.png 1600w, https://www.ruanx.net/content/images/size/w2400/2023/05/image-1.png 2400w" layout="responsive"></amp-img></figure><p>　　可见 <code>afl-fuzz.c</code> 有 8000 余行，是最大的源码文件。其余的 <code>afl-tim.c, afl-analyze.c, afl-showmap.c</code> 等文件有 1000 行左右。观察一下代码依赖关系：</p><figure class="kg-card kg-image-card"><amp-img src="https://www.ruanx.net/content/images/2023/05/image-2.png" class="kg-image" alt width="1075" height="1040" srcset="https://www.ruanx.net/content/images/size/w600/2023/05/image-2.png 600w, https://www.ruanx.net/content/images/size/w1000/2023/05/image-2.png 1000w, https://www.ruanx.net/content/images/2023/05/image-2.png 1075w" layout="responsive"></amp-img></figure><p>　　我们来看这个项目的 CI 配置，即 <code>.travis.yml</code> 文件。</p><pre><code class="language-yaml">language: c

env:
  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_STOP_MANUALLY=1
  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_EXIT_WHEN_DONE=1
 # TODO: test AFL_BENCH_UNTIL_CRASH once we have a target that crashes
  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_BENCH_JUST_ONE=1

before_install:
  - sudo apt update
  - sudo apt install -y libtool libtool-bin automake bison libglib2.0

# TODO: Look into splitting off some builds using a build matrix.
# TODO: Move this all into a bash script so we don't need to write bash in yaml.
script:
  - make
  - ./afl-gcc ./test-instr.c -o test-instr-gcc
  - mkdir seeds
  - echo "" &gt; seeds/nil_seed
  - if [ -z "$AFL_STOP_MANUALLY" ];
    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;
    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;
    fi
  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3
  - rm -r out/*
  - ./afl-clang ./test-instr.c -o test-instr-clang
  - if [ -z "$AFL_STOP_MANUALLY" ];
    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;
    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;
    fi
  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 2
  - make clean
  - CC=clang CXX=clang++ make
  - cd llvm_mode
  # TODO: Build with different versions of clang/LLVM since LLVM passes don't
  # have a stable API.
  - CC=clang CXX=clang++ LLVM_CONFIG=llvm-config make
  - cd ..
  - rm -r out/*
  - ./afl-clang-fast ./test-instr.c -o test-instr-clang-fast
  - if [ -z "$AFL_STOP_MANUALLY" ];
    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;
    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;
    fi
  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3
  # Test fuzzing libFuzzer targets and trace-pc-guard instrumentation.
  - clang -g -fsanitize-coverage=trace-pc-guard ./test-libfuzzer-target.c -c
  - clang -c -w llvm_mode/afl-llvm-rt.o.c
  - wget https://raw.githubusercontent.com/llvm/llvm-project/main/compiler-rt/lib/fuzzer/afl/afl_driver.cpp
  - clang++ afl_driver.cpp afl-llvm-rt.o.o test-libfuzzer-target.o -o test-libfuzzer-target
  - timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-libfuzzer-target
  - cd qemu_mode
  - ./build_qemu_support.sh
  - cd ..
  - gcc ./test-instr.c -o test-no-instr
  - if [ -z "$AFL_STOP_MANUALLY" ];
    then ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;
    else timeout --preserve-status 5s ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;
    fi
  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 12 -p 9</code></pre><p>　　这个 CI 流程是先编译 AFL，再执行一些测试。我们逐条解释这些脚本：</p><pre><code class="language-bash"># 编译 AFL
make

# 用 afl-gcc 编译靶标程序
./afl-gcc ./test-instr.c -o test-instr-gcc

# 准备语料集
mkdir seeds
echo "" &gt; seeds/nil_seed

# 执行一次时长 5s 的 fuzz
if [ -z "$AFL_STOP_MANUALLY" ];
then ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;
else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;
fi

# 检查 fuzzer 是否正确生成了 fuzzer_stats 文件（这个文件保存了 fuzzer 的当前状态，以便恢复 fuzz）
.travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3

# 清理
rm -r out/*

# 用 afl-clang 执行一遍 fuzz，大致与 afl-gcc 的流程一致
./afl-clang ./test-instr.c -o test-instr-clang
if [ -z "$AFL_STOP_MANUALLY" ];
then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;
else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;
fi
.travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 2
make clean

# 用 llvm_mode 执行一遍 fuzz
CC=clang CXX=clang++ make
cd llvm_mode
CC=clang CXX=clang++ LLVM_CONFIG=llvm-config make
cd ..
rm -r out/*
./afl-clang-fast ./test-instr.c -o test-instr-clang-fast
if [ -z "$AFL_STOP_MANUALLY" ];
then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;
else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;
fi
.travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3

# 测试对 libFuzzer 的兼容性
clang -g -fsanitize-coverage=trace-pc-guard ./test-libfuzzer-target.c -c
clang -c -w llvm_mode/afl-llvm-rt.o.c
wget https://raw.githubusercontent.com/llvm/llvm-project/main/compiler-rt/lib/fuzzer/afl/afl_driver.cpp
clang++ afl_driver.cpp afl-llvm-rt.o.o test-libfuzzer-target.o -o test-libfuzzer-target
timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-libfuzzer-target

# 测试 qemu mode
cd qemu_mode
./build_qemu_support.sh
cd ..
gcc ./test-instr.c -o test-no-instr
if [ -z "$AFL_STOP_MANUALLY" ];
  then ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;
  else timeout --preserve-status 5s ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;
  fi
.travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 12 -p 9</code></pre><h3 id="0x01-%E5%86%B3%E5%AE%9A%E9%98%85%E8%AF%BB%E9%A1%BA%E5%BA%8F">0x01 决定阅读顺序</h3><p>　　AFL 不是一个简单的 CRUD 项目，其内部充斥着各种精细的优化手段。我们现在需要寻找一个切入点，去阅读项目源码。直接阅读 <code>afl-fuzz.c</code> 恐怕会陷入「看到一个函数 -&gt; 寻找函数定义 -&gt; 看到里面调用了另一个函数……」这样的循环，因此笔者准备先读项目的其他部分，积攒一些理解，然后再读 <code>afl-fuzz.c</code>。这就如同在阅读一个图片处理库的核心源码之前，先读一个调用了这个库的小程序的源码，熟悉各种 API 的用途，从而读核心源码的时候也更容易。</p><p>　　我们阅读源码的主要目标应该是：</p><ol><li>理清静态插桩过程（gcc、clang、llvm mode）</li><li>理清 fuzz 过程：如何变异、如何将 input 传递给程序、如何收集覆盖度信息</li><li>理清 qemu mode 的插桩和执行过程</li></ol><p>　　因此，我们决定阅读顺序：</p><ol><li>阅读 <code>afl-gcc.c</code> 和 <code>afl-as.c</code>，即静态插桩相关代码</li><li>阅读 <code>afl-tmin.c</code> ，这个工具的用途是「将一个 input case 缩小，但与原 input 拥有相同的覆盖度」。它会完整地演示如何收集程序的覆盖度信息，而不涉及 <code>afl-fuzz.c</code> 中的其他流程。这将给我们提供一个绝佳的切面，以研究 AFL 收集覆盖度的方法</li><li>阅读 <code>afl-fuzz.c</code></li></ol><p>　　那么，我们现在从 <code>afl-gcc.c</code> 开始。</p><h3 id="0x02-afl-gcc-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E5%99%A8">0x02 afl-gcc 编译命令生成器</h3><p>　　由于阅读过程中少不了动态调试，我们用 VS Code 远程连接到 Linux 虚拟机上。导入源码，发现 clangd 插件找不到 <code>AFL_PATH</code> 常量。</p><figure class="kg-card kg-image-card kg-card-hascaption"><amp-img src="https://www.ruanx.net/content/images/2023/05/image-3.png" class="kg-image" alt width="1827" height="718" srcset="https://www.ruanx.net/content/images/size/w600/2023/05/image-3.png 600w, https://www.ruanx.net/content/images/size/w1000/2023/05/image-3.png 1000w, https://www.ruanx.net/content/images/size/w1600/2023/05/image-3.png 1600w, https://www.ruanx.net/content/images/2023/05/image-3.png 1827w" layout="responsive"></amp-img><figcaption>▲ clangd 找不到 <code>AFL_PATH</code></figcaption></figure><p>　　看一眼 Makefile：</p><pre><code class="language-makefile">PREFIX     ?= /usr/local
BIN_PATH    = $(PREFIX)/bin
HELPER_PATH = $(PREFIX)/lib/afl
DOC_PATH    = $(PREFIX)/share/doc/afl
MISC_PATH   = $(PREFIX)/share/afl</code></pre><p>　　原来这些常量都是 make 指定的。根据一篇 <a href="https://stackoverflow.com/questions/67887552/make-clangd-aware-of-macros-given-from-the-compiler">Stackoverflow</a> 回答，发现 clangd 可以从 <code>compile_commands.json</code> 中获取编译 flag； 根据 <a href="https://clangd.llvm.org/installation#project-setup">clangd 官网</a>，使用下面的命令就能生成这个 json：</p><pre><code class="language-bash">make clean
bear -- make</code></pre><p>　　尝试一下之后，问题果然解决了。下面来看代码。</p><p></p><p>　　根据注释， <code>afl-gcc</code> 是 <code>gcc, g++, clang, clang++</code> 的包装器。它的作用是设置一些编译参数，然后调用这些编译器。事实上，<strong>编译出来的 <code>afl-clang, afl-g++</code> 等文件都是指向 <code>afl-gcc</code> 的软链接。</strong></p><p>　　<code>afl-gcc</code> 需要知道 <code>afl-as</code> 的路径。<code>afl-as</code> 是插桩器，我们将会在后文分析它的逻辑。默认情况下， <code>afl-as</code> 位于 <code>/usr/local/lib/afl/</code> ，不过也可以透过 <code>AFL_PATH</code> 指定。</p><div class="kg-card kg-callout-card kg-callout-card-grey"><div class="kg-callout-emoji">📓</div><div class="kg-callout-text"><strong>一些细节：</strong> <br />如果 <code>AFL_HARDEN</code> 打开， <code>afl-gcc</code> 会给下游编译器传递一些开关（ <code>-D_FORTIFY_SOURCE=2, -fstack-protector-all</code>），使得内存 bug 更容易暴露和复现。如果 <code>AFL_USE_ASAN</code> 打开，将会使用 ASan。<br /><br />另外， <code>afl-gcc</code> 允许用户使用非标准的下游编译器（也就是说，并非 gcc 或 clang）。设置 <code>AFL_CC</code> 和 <code>AFL_CXX</code> 即可。</div></div><p>　　　先看 <code>main</code> 函数：</p><pre><code class="language-c">/* Main entry point */

int main(int argc, char** argv) {

  // 如果不是 QUIET 模式，则输出作者信息
  if (isatty(2) &amp;&amp; !getenv("AFL_QUIET")) {
    SAYF(cCYA "afl-cc " cBRI VERSION cRST " by &lt;lcamtuf@google.com&gt;\n");
  } else be_quiet = 1;

  // 如果不带参数调用，则输出帮助文档后退出
  if (argc &lt; 2) {
    SAYF("\n"
         "This is a helper application for afl-fuzz. It serves as a drop-in replacement\n"
         "for gcc or clang, letting you recompile third-party code with the required\n"
         "runtime instrumentation. A common use pattern would be one of the following:\n\n"

         "  CC=%s/afl-gcc ./configure\n"
         "  CXX=%s/afl-g++ ./configure\n\n"

         "You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n"
         "Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n",
         BIN_PATH, BIN_PATH);

    exit(1);
  }

  // 寻找 afl-as
  find_as(argv[0]);

  // 修改编译参数
  edit_params(argc, argv);

  // 执行下游编译器
  execvp(cc_params[0], (char**)cc_params);

  FATAL("Oops, failed to execute '%s' - check your PATH", cc_params[0]);

  return 0;

}</code></pre><p>　　逻辑很清晰：<strong>先调用 <code>find_as(argv[0])</code> 寻找 <code>afl-as</code> ；然后修改编译器参数，并执行下游编译器。</strong>我们按顺序看，先观察负责寻找 <code>afl-as</code> 的 <code>find_as</code> 函数：</p><pre><code class="language-c">/* Try to find our "fake" GNU assembler in AFL_PATH or at the location derived
   from argv[0]. If that fails, abort. */

static void find_as(u8* argv0) {
  // 从环境变量中读取 $AFL_PATH
  u8 *afl_path = getenv("AFL_PATH");
  u8 *slash, *tmp;

  // 如果存在环境变量 $AFL_PATH，且 $AFL_PATH/as 存在，则成功找到
  if (afl_path) {

    tmp = alloc_printf("%s/as", afl_path);

    if (!access(tmp, X_OK)) {
      as_path = afl_path;
      ck_free(tmp);
      return;
    }

    ck_free(tmp);

  }

  // 于 argv[0] 所在的目录下寻找 afl-as
  slash = strrchr(argv0, '/');

  if (slash) {

    u8 *dir;

    *slash = 0;
    dir = ck_strdup(argv0);
    *slash = '/';

    tmp = alloc_printf("%s/afl-as", dir);

    if (!access(tmp, X_OK)) {
      as_path = dir;
      ck_free(tmp);
      return;
    }

    ck_free(tmp);
    ck_free(dir);

  }

  // fallback，如果前两个位置都找不到，则去编译 afl-gcc 时定义的 AFL_PATH 去找
  // 默认情况下，AFL_PATH 由 Makefile 定义成 "/usr/local/lib/afl"
  if (!access(AFL_PATH "/as", X_OK)) {
    as_path = AFL_PATH;
    return;
  }

  FATAL("Unable to find AFL wrapper binary for 'as'. Please set AFL_PATH");
 
}</code></pre><p>　　我们平时一般使用 <code>/work/afl/afl-gcc</code> 来调用 <code>afl-gcc</code>，所以正常情况下，会找到 <code>/work/afl/afl-as</code> 这个文件。</p><hr></hr><p>　　接下来，阅读 <code>edit_params</code> 函数，看看下游编译器的参数是如何生成的。</p><p>　　首先，分析自己的 <code>argv[0]</code> ，确定自己需要调用哪个下游编译器——例如，如果 <code>argv[0]</code> 是 <code>/work/afl/afl-clang++</code> ，则下游编译器是 <code>clang++</code> 。另外，上文提到过，AFL 允许用户自己指定下游编译器，如果 <code>AFL_CC</code> 和 <code>AFL_CXX</code> 存在，则会覆盖掉默认编译器。</p><p>　　接下来，<strong>将自己的 <code>argv[]</code> 复制一份，稍后将会原样传递给下游编译器。</strong>由于这一步骤的存在，我们可以直接使用 <code>afl-gcc</code> 代替原有的 <code>gcc</code> 指令。</p><ul><li><code>-integrated-as</code> 和 <code>-pipe</code> 开关会被忽略。</li><li><code>-B</code> 参数会被覆盖为 <code>as_path</code> 。根据 gcc 文档：This option specifies where to find the executables, libraries, include files, and data files <strong>of the compiler itself</strong>.</li><li>如果是 clang 模式，则打开 <code>-no-integrated-as</code> 开关。</li><li>如果 <code>AFL_HARDEN</code> 打开，则设置 <code>-fstack-protector-all</code> 和 <code>-D_FORTIFY_SOURCE=2</code> 。</li><li>若传入的编译参数中本来就有 <code>-fsanitize=address</code> 或 <code>-fsanitize=memory</code>，则设置环境变量 <code>AFL_USE_ASAN</code> 为 1；<br />否则执行以下步骤： <br />- 如果 <code>AFL_USE_ASAN</code> 打开，则设置 <code>-U_FORTIFY_SOURCE</code> 和 <code>-fsanitize=address</code><br />- 如果 <code>AFL_USE_MSAN</code> 打开，则设置 <code>-U_FORTIFY_SOURCE</code> 和 <code>-fsanitize=memory</code></li></ul><p>　　默认情况下（未设置 <code>AFL_DONT_OPTIMIZE</code> 环境变量），会加入以下优化开关：</p><pre><code class="language-plaintext">-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></pre><p>　　如果 <code>AFL_NO_BUILTIN</code> 环境变量被打开，则加入以下开关：</p><figure class="kg-card kg-code-card"><pre><code class="language-plaintext">-fno-builtin-strcmp
-fno-builtin-strncmp
-fno-builtin-strcasecmp
-fno-builtin-strncasecmp
-fno-builtin-memcmp
-fno-builtin-strstr
-fno-builtin-strcasestr</code></pre><figcaption>▲ 关于这些 no-builtin 开关的用途，详见 <a href="https://stackoverflow.com/questions/54281780/what-exactly-is-fno-builtin-doing-here">Stackoverflow 讨论</a> </figcaption></figure><p>　　以上就是 <code>edit_params</code> 的全流程。注意到，<strong>最关键的一步是加入了 <code>-B as_path</code> 这个 flag，使得下游编译器在汇编过程中，以 <code>afl-as</code> 替换了原生的汇编器。</strong>而具体的插桩过程，则是 <code>afl-as</code> 负责实现。我们在下一章节去阅读 <code>afl-as</code> 的源码。</p><p>　　本节阅读的 <code>edit_params</code> 函数源码如下：</p><pre><code class="language-c">/* Copy argv to cc_params, making the necessary edits. */

static void edit_params(u32 argc, char** argv) {
  u8 fortify_set = 0, asan_set = 0;
  u8 *name;

#if defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)
  u8 m32_set = 0;
#endif

  // 确定使用哪个下游编译器
  cc_params = ck_alloc((argc + 128) * sizeof(u8*));

  name = strrchr(argv[0], '/');
  if (!name) name = argv[0]; else name++;

  if (!strncmp(name, "afl-clang", 9)) {

    clang_mode = 1;

    setenv(CLANG_ENV_VAR, "1", 1);

    if (!strcmp(name, "afl-clang++")) {
      u8* alt_cxx = getenv("AFL_CXX");
      cc_params[0] = alt_cxx ? alt_cxx : (u8*)"clang++";
    } else {
      u8* alt_cc = getenv("AFL_CC");
      cc_params[0] = alt_cc ? alt_cc : (u8*)"clang";
    }

  } else {

    /* With GCJ and Eclipse installed, you can actually compile Java! The
       instrumentation will work (amazingly). Alas, unhandled exceptions do
       not call abort(), so afl-fuzz would need to be modified to equate
       non-zero exit codes with crash conditions when working with Java
       binaries. Meh. */

#ifdef __APPLE__

    if (!strcmp(name, "afl-g++")) cc_params[0] = getenv("AFL_CXX");
    else if (!strcmp(name, "afl-gcj")) cc_params[0] = getenv("AFL_GCJ");
    else cc_params[0] = getenv("AFL_CC");

    if (!cc_params[0]) {

      SAYF("\n" cLRD "[-] " cRST
           "On Apple systems, 'gcc' is usually just a wrapper for clang. Please use the\n"
           "    'afl-clang' utility instead of 'afl-gcc'. If you really have GCC installed,\n"
           "    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n");

      FATAL("AFL_CC or AFL_CXX required on MacOS X");

    }

#else

    if (!strcmp(name, "afl-g++")) {
      u8* alt_cxx = getenv("AFL_CXX");
      cc_params[0] = alt_cxx ? alt_cxx : (u8*)"g++";
    } else if (!strcmp(name, "afl-gcj")) {
      u8* alt_cc = getenv("AFL_GCJ");
      cc_params[0] = alt_cc ? alt_cc : (u8*)"gcj";
    } else {
      u8* alt_cc = getenv("AFL_CC");
      cc_params[0] = alt_cc ? alt_cc : (u8*)"gcc";
    }

#endif /* __APPLE__ */

  }


  // 复制自己的 argv
  while (--argc) {
    u8* cur = *(++argv);

    if (!strncmp(cur, "-B", 2)) {

      if (!be_quiet) WARNF("-B is already set, overriding");

      if (!cur[2] &amp;&amp; argc &gt; 1) { argc--; argv++; }
      continue;

    }

    if (!strcmp(cur, "-integrated-as")) continue;

    if (!strcmp(cur, "-pipe")) continue;

#if defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)
    if (!strcmp(cur, "-m32")) m32_set = 1;
#endif

    if (!strcmp(cur, "-fsanitize=address") ||
        !strcmp(cur, "-fsanitize=memory")) asan_set = 1;

    if (strstr(cur, "FORTIFY_SOURCE")) fortify_set = 1;

    cc_params[cc_par_cnt++] = cur;

  }

  cc_params[cc_par_cnt++] = "-B";
  cc_params[cc_par_cnt++] = as_path;

  if (clang_mode)
    cc_params[cc_par_cnt++] = "-no-integrated-as";

  if (getenv("AFL_HARDEN")) {

    cc_params[cc_par_cnt++] = "-fstack-protector-all";

    if (!fortify_set)
      cc_params[cc_par_cnt++] = "-D_FORTIFY_SOURCE=2";

  }

  // 若传入的编译参数中本来就打开了 ASan 或 MSan，则这里把 $AFL_USE_ASAN 也打开
  if (asan_set) {

    /* Pass this on to afl-as to adjust map density. */

    setenv("AFL_USE_ASAN", "1", 1);

  } else if (getenv("AFL_USE_ASAN")) {

    if (getenv("AFL_USE_MSAN"))
      FATAL("ASAN and MSAN are mutually exclusive");

    if (getenv("AFL_HARDEN"))
      FATAL("ASAN and AFL_HARDEN are mutually exclusive");

    cc_params[cc_par_cnt++] = "-U_FORTIFY_SOURCE";
    cc_params[cc_par_cnt++] = "-fsanitize=address";

  } else if (getenv("AFL_USE_MSAN")) {

    if (getenv("AFL_USE_ASAN"))
      FATAL("ASAN and MSAN are mutually exclusive");

    if (getenv("AFL_HARDEN"))
      FATAL("MSAN and AFL_HARDEN are mutually exclusive");

    cc_params[cc_par_cnt++] = "-U_FORTIFY_SOURCE";
    cc_params[cc_par_cnt++] = "-fsanitize=memory";


  }

  if (!getenv("AFL_DONT_OPTIMIZE")) {

#if defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)

    /* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself
       works OK. This has nothing to do with us, but let's avoid triggering
       that bug. */

    if (!clang_mode || !m32_set)
      cc_params[cc_par_cnt++] = "-g";

#else

      cc_params[cc_par_cnt++] = "-g";

#endif

    cc_params[cc_par_cnt++] = "-O3";
    cc_params[cc_par_cnt++] = "-funroll-loops";

    /* Two indicators that you're building for fuzzing; one of them is
       AFL-specific, the other is shared with libfuzzer. */

    cc_params[cc_par_cnt++] = "-D__AFL_COMPILER=1";
    cc_params[cc_par_cnt++] = "-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1";

  }

  if (getenv("AFL_NO_BUILTIN")) {

    cc_params[cc_par_cnt++] = "-fno-builtin-strcmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strncmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strcasecmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strncasecmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-memcmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strstr";
    cc_params[cc_par_cnt++] = "-fno-builtin-strcasestr";

  }

  cc_params[cc_par_cnt] = NULL;

}</code></pre><h3 id="0x03-afl-as-%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9%E5%99%A8">0x03 afl-as 静态插桩器</h3><p>　　<code>afl-as</code> 是原生 GNU as 的 wrapper。我们先阅读 <code>main</code> 函数：</p><pre><code class="language-c">/* Main entry point */

int main(int argc, char** argv) {

  s32 pid;
  u32 rand_seed;
  int status;
  u8* inst_ratio_str = getenv("AFL_INST_RATIO");

  struct timeval tv;
  struct timezone tz;

  clang_mode = !!getenv(CLANG_ENV_VAR);

  if (isatty(2) &amp;&amp; !getenv("AFL_QUIET")) {

    SAYF(cCYA "afl-as " cBRI VERSION cRST " by &lt;lcamtuf@google.com&gt;\n");
 
  } else be_quiet = 1;

  if (argc &lt; 2) {

    SAYF("\n"
         "This is a helper application for afl-fuzz. It is a wrapper around GNU 'as',\n"
         "executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n"
         "don't want to run this program directly.\n\n"

         "Rarely, when dealing with extremely complex projects, it may be advisable to\n"
         "set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n"
         "instrumenting every discovered branch.\n\n");

    exit(1);

  }

  gettimeofday(&amp;tv, &amp;tz);

  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();

  srandom(rand_seed);

  edit_params(argc, argv);

  if (inst_ratio_str) {

    if (sscanf(inst_ratio_str, "%u", &amp;inst_ratio) != 1 || inst_ratio &gt; 100) 
      FATAL("Bad value of AFL_INST_RATIO (must be between 0 and 100)");

  }

  if (getenv(AS_LOOP_ENV_VAR))
    FATAL("Endless loop when calling 'as' (remove '.' from your PATH)");

  setenv(AS_LOOP_ENV_VAR, "1", 1);

  /* When compiling with ASAN, we don't have a particularly elegant way to skip
     ASAN-specific branches. But we can probabilistically compensate for
     that... */

  if (getenv("AFL_USE_ASAN") || getenv("AFL_USE_MSAN")) {
    sanitizer = 1;
    inst_ratio /= 3;
  }

  if (!just_version) add_instrumentation();

  if (!(pid = fork())) {

    execvp(as_params[0], (char**)as_params);
    FATAL("Oops, failed to execute '%s' - check your PATH", as_params[0]);

  }

  if (pid &lt; 0) PFATAL("fork() failed");

  if (waitpid(pid, &amp;status, 0) &lt;= 0) PFATAL("waitpid() failed");

  if (!getenv("AFL_KEEP_ASSEMBLY")) unlink(modified_file);

  exit(WEXITSTATUS(status));

}</code></pre><p>　　可见工作流程是：</p><ol><li>初始化随机数种子</li><li>在汇编指令序列上插桩  </li><li>修改 as 参数</li><li>调用 as 生成可执行文件，并清理现场</li></ol><p>　　先来看 <code>afl-as</code> 是如何读取并修改 as 参数的。源码中有很多对应 MacOS 的内容，我们只关注 Linux x86，故删去这些段落。精简后的代码如下：</p><pre><code class="language-c">/* Examine and modify parameters to pass to 'as'. Note that the file name
   is always the last parameter passed by GCC, so we exploit this property
   to keep the code simple. */

static void edit_params(int argc, char** argv) {

  u8 *tmp_dir = getenv("TMPDIR"), *afl_as = getenv("AFL_AS");
  u32 i;

  /* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR
     is not set. We need to check these non-standard variables to properly
     handle the pass_thru logic later on. */

  if (!tmp_dir) tmp_dir = getenv("TEMP");
  if (!tmp_dir) tmp_dir = getenv("TMP");
  if (!tmp_dir) tmp_dir = "/tmp";

  as_params = ck_alloc((argc + 32) * sizeof(u8*));

  as_params[0] = afl_as ? afl_as : (u8*)"as";

  as_params[argc] = 0;

  for (i = 1; i &lt; argc - 1; i++) {

    if (!strcmp(argv[i], "--64")) use_64bit = 1;
    else if (!strcmp(argv[i], "--32")) use_64bit = 0;

    as_params[as_par_cnt++] = argv[i];

  }

  input_file = argv[argc - 1];

  if (input_file[0] == '-') {

    if (!strcmp(input_file + 1, "-version")) {
      just_version = 1;
      modified_file = input_file;
      goto wrap_things_up;
    }

    if (input_file[1]) FATAL("Incorrect use (not called through afl-gcc?)");
    else input_file = NULL;

  } else {

    /* Check if this looks like a standard invocation as a part of an attempt
       to compile a program, rather than using gcc on an ad-hoc .s file in
       a format we may not understand. This works around an issue compiling
       NSS. */

    if (strncmp(input_file, tmp_dir, strlen(tmp_dir)) &amp;&amp;
        strncmp(input_file, "/var/tmp/", 9) &amp;&amp;
        strncmp(input_file, "/tmp/", 5)) pass_thru = 1;

  }

  modified_file = alloc_printf("%s/.afl-%u-%u.s", tmp_dir, getpid(),
                               (u32)time(NULL));

wrap_things_up:

  as_params[as_par_cnt++] = modified_file;
  as_params[as_par_cnt]   = NULL;

}</code></pre><p>　　可见，这个过程很类似于 <code>afl-gcc</code> 修改参数的逻辑：</p><ol><li>首先确定 as 程序的名字，默认就是 GNU as，但用户也可以提供 <code>AFL_AS</code> 来覆盖</li><li>设置临时文件 <code>modified_file</code> 路径为 <code>/tmp/.afl-pid-timestamp.s</code></li><li>将自己程序的 <code>argv</code> 原样复制给 <code>as</code> </li></ol><p>　　那么，整个 <code>afl-as</code> 程序的逻辑就是：读入原来的汇编代码，生成一个插了桩的新汇编代码（存放在临时目录），调用 GNU as 来将新汇编代码转化成机器码。</p><p>　　接下来，我们阅读插桩过程的核心部分。</p><hr></hr><p>　　<code>add_instrumentation</code> 是一个 200 多行的函数，其中逻辑比较复杂。我们不妨先实际执行一遍 as 过程，看看它是如何插桩的。</p><p>　　编写一段简单的代码：</p><pre><code class="language-c">#include &lt;stdio.h&gt;

void work() {
    for(int i=1; i&lt;=10; i++) {
        printf("Hello, world %d\n", i);
    }
}

int main(void) {
    work();
    return 0;
}</code></pre><p>　　编译、插桩：</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">AFL_DONT_OPTIMIZE=1 ../afl-gcc target.c -o target -O0 -fno-asynchronous-unwind-tables</code></pre><figcaption>▲ 使用 <code>-fno-asynchronous-unwind-tables</code> 以去除 .cfi 指令。见 <a href="https://stackoverflow.com/questions/2529185/what-are-cfi-directives-in-gnu-assembler-gas-used-for">Stackoverflow</a> </figcaption></figure><p>　　我们修改了 <code>afl-as</code> 的源码，让它将插桩前、插桩后的汇编代码都保留到文件系统中。插桩前的汇编代码为： </p><pre><code class="language-c">	.file	"target.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hello, world %d\n"
	.text
	.globl	work
	.type	work, @function
work:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$16, %rsp
	movl	$1, -4(%rbp)
	jmp	.L2
.L3:
	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
	addl	$1, -4(%rbp)
.L2:
	cmpl	$10, -4(%rbp)
	jle	.L3
	nop
	nop
	leave
	ret
	.size	work, .-work
	.globl	main
	.type	main, @function
main:
	pushq	%rbp
	movq	%rsp, %rbp
	movl	$0, %eax
	call	work
	movl	$0, %eax
	popq	%rbp
	ret
	.size	main, .-main
	.ident	"GCC: (Debian 12.2.0-14) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
</code></pre><p>　　插桩后的代码为：</p><pre><code class="language-c">	.file	"target.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hello, world %d\n"
	.text
	.globl	work
	.type	work, @function
work:

/* --- AFL TRAMPOLINE (64-BIT) --- */

.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x00000af3, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp

/* --- END --- */

	pushq	%rbp
	movq	%rsp, %rbp
	subq	$16, %rsp
	movl	$1, -4(%rbp)
	jmp	.L2
.L3:

/* --- AFL TRAMPOLINE (64-BIT) --- */

.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x00003d9b, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp

/* --- END --- */

	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
	addl	$1, -4(%rbp)
.L2:

/* --- AFL TRAMPOLINE (64-BIT) --- */

.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x0000d5a5, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp

/* --- END --- */

	cmpl	$10, -4(%rbp)
	jle	.L3

/* --- AFL TRAMPOLINE (64-BIT) --- */

.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x000078e0, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp

/* --- END --- */

	nop
	nop
	leave
	ret
	.size	work, .-work
	.globl	main
	.type	main, @function
main:

/* --- AFL TRAMPOLINE (64-BIT) --- */

.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x0000c35b, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp

/* --- END --- */

	pushq	%rbp
	movq	%rsp, %rbp
	movl	$0, %eax
	call	work
	movl	$0, %eax
	popq	%rbp
	ret
	.size	main, .-main
	.ident	"GCC: (Debian 12.2.0-14) 12.2.0"
	.section	.note.GNU-stack,"",@progbits

/* --- AFL MAIN PAYLOAD (64-BIT) --- */
/* 此处省略 300 余行 */</code></pre><p>　　可见，在每一个基本块入口处，afl-as 插入了一段代码。除此之外，在整个程序的末尾，插入了一段 300 多行的 AFL main payload。暂且先不管 AFL main payload，我们先分析在每个 branch 开始的位置插入的代码，这类代码形如：</p><pre><code class="language-c">/* --- AFL TRAMPOLINE (64-BIT) --- */
.align 4

leaq -(128+24)(%rsp), %rsp
movq %rdx,  0(%rsp)
movq %rcx,  8(%rsp)
movq %rax, 16(%rsp)
movq $0x000078e0, %rcx
call __afl_maybe_log
movq 16(%rsp), %rax
movq  8(%rsp), %rcx
movq  0(%rsp), %rdx
leaq (128+24)(%rsp), %rsp
/* --- END --- */</code></pre><p>　　<a href="https://github.com/google/AFL/blob/master/docs/technical_details.txt">AFL 白皮书</a>中说，上述代码本质上实现了如下逻辑：</p><pre><code class="language-c">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;
shared_mem[cur_location ^ prev_location]++; 
prev_location = cur_location &gt;&gt; 1;</code></pre><p>　　这里有一点值得注意：为什么需要把 <code>cur_location</code> 右移一位再赋值给 <code>prev_location</code> ？我们来看一个例子。设两个入口点的随机值分别为 $A, B$，假设不存在这个右移，那么由于异或运算的交换律，$A\to B$ 和 $B \to A$ 都会使得 <code>mem[A ^ B]++</code>，这样就丢失了方向信息。而 AFL 中存在这个右移，使得 $A\to B$ 实际上引发的是 <code>mem[(A&gt;&gt;1)^B]++</code> ，而 $B\to A$ 引发 <code>mem[(B&gt;&gt;1)^A]++</code> ，巧妙地区分开了这两种不同方向。</p><p>　　现在我们来分析一下这段汇编，看它是如何实现上述伪代码逻辑的。</p><ol><li>将 <code>rsp</code> 下降一段距离</li><li>将 <code>rdx, rcx, rax</code> 的值存放到栈上</li><li>将 <code>rcx</code> 设为一个立即数（由 afl-as 随机生成）</li><li>调用 <code>__afl_maybe_log</code></li><li>恢复 <code>rdx, rcx, rax</code> 和 <code>rsp</code> </li></ol><p>　　这已经解释了 <code>cur_location</code> 的来历。它是随机生成的，现在存放在 <code>rcx</code> 寄存器中。接下来调用 <code>__afl_maybe_log</code> ，可以猜测，它要实现「<code>mem</code> 自增」和「保存 <code>prev_location</code>」两项任务。</p><p>　　跟进 <code>__afl_maybe_log</code> 看看：</p><pre><code class="language-c">__afl_maybe_log:

  lahf
  seto  %al

  /* Check if SHM region is already mapped. */

  movq  __afl_area_ptr(%rip), %rdx
  testq %rdx, %rdx
  je    __afl_setup

__afl_store:

  /* Calculate and store hit for the code location specified in rcx. */

  xorq __afl_prev_loc(%rip), %rcx
  xorq %rcx, __afl_prev_loc(%rip)
  shrq $1, __afl_prev_loc(%rip)

  incb (%rdx, %rcx, 1)

__afl_return:

  addb $127, %al
  sahf
  ret</code></pre><p>　　首先解释一下 <code>lahf</code> 和 <code>seto  %al</code> 这两行代码的意思。它们是负责存储 eflags 寄存器的值——将低 8 位保存在 <code>ah</code>，将 OF 位保存在 <code>al</code>，并在桩代码退出时执行 <code>addb $127, %al</code> 和 <code>sahf</code> 恢复现场，<strong>使得整个桩代码对原程序透明</strong>。</p><p>　　<code>__afl_maybe_log</code> 先检查共享内存区域是否已经映射。如果还未映射，则跳转到 <code>__afl_setup</code> 进行初始化；否则继续执行 <code>__afl_store</code> 逻辑，<code>rdx</code> 寄存器指向共享内存区块。</p><p>　　<code>__afl_store</code> 执行过程为：</p><ol><li>将目前存储着 <code>cur_loc</code> 的 <code>rcx</code> 寄存器异或上 <code>prev_loc</code> </li><li>将 <code>prev_loc</code> 设为 <code>cur_loc</code> （这里利用了异或运算的自反性）</li><li>将 <code>prev_loc</code> 右移一位</li><li>增加 hit count</li></ol><p>　　这些过程执行完后，恢复 eflags 并返回。现在，我们弄清了插入到基本块起始处的桩代码的逻辑。至于 <code>AFL MAIN PAYLOAD</code> 那一段几百行的汇编，与 fork server 有关，我们下一篇文章再研究。</p><p>　　在研究明白 <code>afl-as</code> 的行为之后，回头再看 <code>add_instrumentation</code> 函数。可以发现它是一个 parser，每次扫描并原样输出一行汇编码，如果发现这个地方要插桩，则把桩代码插进去。至于具体的桩代码，它们定义在 <code>afl-as.h</code> 中，有 32 位、64 位两个版本。我们上文已经详细解释了 64 位版本。</p><p>　　在扫描完成之后，于文件末尾写入 main payload。它也是有 32 位和 64 位版本。</p><p>　　以上，我们理解了插桩过程是如何进行的。而 <code>add_instrumentation</code> 函数之实现细节，正如我们所熟悉的各种词法分析器一样，写得很琐碎：大部分代码是在分类讨论各种 token（Linux 的、MacOS 的、OpenBSD 的），没有仔细研读的必要。</p><hr></hr><p>　　在本文中，我们阅读了 <code>afl-gcc</code> 和 <code>afl-as</code> 的源码，初步了解了 AFL 编译和插桩过程。本文只分析了插入到基本块入口的桩代码，并未详细解释插入到整个汇编代码文件末尾的 main payload。这部分内容留到下一篇文章。</p><p></p>

            </section>

        </article>
    </main>
    <footer class="page-footer">
            <amp-img class="site-icon" src="https://www.ruanx.net/content/images/2020/02/small-3.png" width="50" height="50" layout="fixed" alt="Pion1eer"></amp-img>
        <h3>Pion1eer</h3>
            <p>Stand with Ukraine 💙💛</p>
        <p><a href="../../index.html">Read more posts →</a></p>
        <a class="powered" href="https://ghost.org" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 156 156"><g fill="none" fill-rule="evenodd"><rect fill="#15212B" width="156" height="156" rx="27"/><g transform="translate(36 36)" fill="#F6F8FA"><path d="M0 71.007A4.004 4.004 0 014 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0130 84H4a4 4 0 01-4-4.007v-8.986zM50 71.007A4.004 4.004 0 0154 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0180 84H54a4 4 0 01-4-4.007v-8.986z"/><rect y="34" width="84" height="17" rx="4"/><path d="M0 4.007A4.007 4.007 0 014.007 0h41.986A4.003 4.003 0 0150 4.007v8.986A4.007 4.007 0 0145.993 17H4.007A4.003 4.003 0 010 12.993V4.007z"/><rect x="67" width="17" height="17" rx="4"/></g></g></svg> Published with Ghost</a>
    </footer>
    
</body>
</html>
